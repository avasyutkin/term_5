Федеральное агентство по образованию
САНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ
ПОЛИТЕХНИЧЕСКИЙ УНИВЕРСИТЕТ
С. А. НЕСТЕРОВ
ИНФОРМАЦИОННАЯ БЕЗОПАСНОСТЬ И ЗАЩИТА
ИНФОРМАЦИИ
Рекомендовано Учебно-методическим объединением
по университетскому политехническому образованию в качестве
учебного пособия для студентов высших учебных заведений,
обучающихся по направлению подготовки
220100 – «Системный анализ и управление»
Санкт-Петербург
Издательство Политехнического университета
2009
ББК 32.81
Н 56
Рецензенты:
Доктор технических наук, профессор Санкт-Петербургского института
информатики и автоматизации РАН И. В. Котенко
Кандидат физико-математических наук, доцент Санкт-Петербургского
государственного политехнического университета А. Н. Фирсов
Нестеров С. А. Информационная безопасность и защита инфор-
мации: Учеб. пособие. – СПб.: Изд-во Политехн. ун-та, 2009. – 126 с.
Системно излагаются теоретические основы информационной безо-
пасности и описываются практические аспекты, связанные с их реализаци-
ей. Пособие состоит из трех разделов: «Теоретические основы защиты
информации», «Основы криптографии», «Защита информации в IP-сетях».
Предназначено для студентов, обучающихся по направлению 220100
– «Системный анализ и управление». Также может быть полезно широко-
му кругу специалистов в области информационных технологий.
Печатается по решению редакционно-издательского совета Санкт-
Петербургского государственного политехнического университета при
финансовой поддержке в форме гранта Президента Российской Федера-
ции МК-9472.2006.9.
© Нестеров С. А., 2009
© Санкт-Петербургский государственный
ISBN 978-5-7422-2286-6 политехнический университет, 2009
3
ОГЛАВЛЕНИЕ
Список принятых сокращений .................................................................. 5
Введение ...................................................................................................... 6
1. Теоретические основы информационной безопасности .................... 8
1.1. Базовые понятия .................................................................................. 8
1.2. Общая схема процесса обеспечения безопасности ........................ 12
1.3. Идентификация, аутентификация, управление доступом.
Защита от несанкционированного доступа ........................................... 14
1.3.1. Парольные системы аутентификации .......................................... 16
1.4. Модели безопасности ........................................................................ 18
1.4.1. Модель Харрисона-Рузо-Ульмана ................................................ 21
1.4.2. Модель Белла-ЛаПадула ................................................................ 25
1.4.3. Ролевая модель безопасности ...................................................... 29
1.5. Процесс построения и оценки системы обеспечения
безопасности. Стандарт ISO/IEC 15408 ................................................. 31
2. Основы криптографии ......................................................................... 35
2.1. Основные понятия. Классификация шифров ................................. 35
2.1.1. Виды шифров .................................................................................. 40
2.2. Симметричные шифры ..................................................................... 42
2.2.1. Схема Фейстеля .............................................................................. 42
2.2.2. Шифр DES ....................................................................................... 45
2.2.3. Шифр ГОСТ 28147-89 .................................................................... 54
2.2.4. Шифр Blowfish ................................................................................ 57
2.3. Управление криптографическими ключами для симметричных
шифров ....................................................................................................... 59
2.3.1. Протокол Kerberos .......................................................................... 62
2.4. Асимметричные шифры ................................................................... 67
2.4.1 Основные понятия ........................................................................... 67
2.4.2. Распределение ключей по схеме Диффи-Хеллмана ................... 71
2.4.3. Криптографическая система RSA ................................................. 74
2.4.4. Криптографическая система Эль-Гамаля .................................... 77
2.4.5. Совместное использование симметричных и асимметричных
шифров ....................................................................................................... 79
2.5. Хэш-функции ..................................................................................... 80
2.5.1. Хэш-функции без ключа ................................................................ 80
2.5.2. Алгоритм SHA-1 ............................................................................. 82
2.5.3. Хэш-функции с ключом ................................................................. 84
4
2.6. Инфраструктура открытых ключей. Цифровые сертификаты .... 85
3. Защита информации в IP-сетях ........................................................... 95
3.1. Протокол защиты электронной почты S/MIME ............................. 95
3.2. Протоколы SSL и TLS ....................................................................... 97
3.3. Протоколы IPSec и распределение ключей .................................. 102
3.3.1. Протокол AH ................................................................................. 104
3.3.2. Протокол ESP ................................................................................ 107
3.3.3. Протокол SKIP .............................................................................. 109
3.3.4. Протоколы ISAKMP и IKE .......................................................... 112
3.3.5. Протоколы IPSec и трансляция сетевых адресов ...................... 117
3.4. Межсетевые экраны ........................................................................ 119
Библиографический список ................................................................... 124
5
СПИСОК ПРИНЯТЫХ СОКРАЩЕНИЙ
ACL – Access Control List – список управления доступом
AH – Authentication Header – протокол аутентифицирующего заголов-
ка
CA – Certification Authority – центр сертификации или удостоверяю-
щий центр
CBC – Cipher Block Chaining – сцепление блоков шифра (режим рабо-
ты шифра DES)
CFB – Cipher FeedBack – обратная связь по шифртексту (режим рабо-
ты шифра DES)
CRL – Certificate Revocation List – список отозванных сертификатов
ECB – Electronic Code Book – электронная кодовая книга (режим ра-
боты шифра DES)
ESP – Encapsulating Security Payload – протокол инкапсулирующей
защиты данных
ICV – Integrity Check Value – значение контроля целостности
MAC – Message Authentication Code – код аутентификации сообще-
ний, имитовставка
OFB – Output FeedBack – обратная связь по выходу (режим работы
шифра DES)
PKI – Public Key Infrastructure – инфраструктура открытых ключей
SA – Security Association – контекст защиты или ассоциация безопас-
ности
SPI – Security Parameter Index – индекс параметров защиты
АС – автоматизированная система (обработки информации)
ИТ – информационные технологии
МЭ – межсетевой экран
НСД – несанкционированный доступ
ОО – объект оценки
ЦС – центр сертификации
ЭЦП – электронная цифровая подпись
6
ВВЕДЕНИЕ
Современный специалист в области информационных техноло-
гий должен обладать знаниями и навыками обеспечения информаци-
онной безопасности. Связано это с тем, что в информационных сис-
темах предприятий и организаций хранится и обрабатывается крити-
чески важная информация, нарушение конфиденциальности, целост-
ности или доступности, которой может привести к нежелательным
последствиям. Поэтому вопросам обеспечения информационной
безопасности должно уделяться внимание на всех этапах разработки и
эксплуатации информационных систем.
В данном пособии изложен материал учебной дисциплины
«Информационная безопасность и защита информации», в ходе изу-
чения которой, студенты получают базовые знания о теории защиты
информации, методах и средствах обеспечения информационной
безопасности, а также практические навыки организации защиты ин-
формационных систем. Пособие включает в себя три раздела.
В разделе 1 «Теоретические основы защиты информации» вво-
дятся базовые понятия, связанные с обеспечением информационной
безопасности, рассматриваются основные угрозы безопасности и ме-
ры противодействия им. Также делается обзор формальных моделей
безопасности и современных стандартов в этой области.
Раздел 2 «Основы криптографии» включает описание основных
понятий криптографии. Также изучаются наиболее распространенные
алгоритмы симметричного и асимметричного шифрования, форми-
рования дайджестов сообщений с помощью хэш-функций, процесс
создания инфраструктуры открытых ключей (PKI).
В разделе 3 «Защита информации в IP-сетях» рассматриваются
протоколы криптографической защиты данных, передаваемых по те-
лекоммуникационным сетям, использующим стек протоколов TCP/IP,
использование межсетевых экранов для защиты сетей.
7
Пособие рекомендуется для студентов, обучающихся по направ-
лению 220100 – «Системный анализ и управление», и также мо-
жет быть полезно широкому кругу специалистов в области информа-
ционных технологий.
8
1. ТЕОРЕТИЧЕСКИЕ ОСНОВЫ
ИНФОРМАЦИОННОЙ БЕЗОПАСНОСТИ
1.1. БАЗОВЫЕ ПОНЯТИЯ
Начнем изучение дисциплины с определения ряда базовых по-
нятий.
Информация – это сведения о лицах, предметах, фактах, собы-
тиях, явлениях и процессах независимо от формы их представления.
Информация может существовать в различных формах в виде сово-
купностей некоторых знаков (символов, сигналов и т. д.) на носителях
различных типов. Она может представлять ценность для отдельных
лиц или организаций.
Защищаемая информация – информация, являющаяся предме-
том собственности и подлежащая защите в соответствии с требова-
ниями правовых документов или требованиями, устанавливаемыми
собственниками информации. Собственниками информации могут
быть: государство, юридическое лицо, группа физических лиц, от-
дельное физическое лицо [1].
В последнее время, все большие объемы информации, в том
числе и критически важной для отдельных людей, организаций или
государств, хранятся, обрабатываются и передаются с использовани-
ем автоматизированных систем (АС) обработки информации. Систе-
ма обработки информации – совокупность технических средств и
программного обеспечения, а также методов обработки информации
и действий персонала, необходимых для выполнения автоматизиро-
ванной обработки информации [2]. Объект информатизации – сово-
купность информационных ресурсов, средств и систем обработки ин-
формации, используемых в соответствии с заданной информационной
технологией, а также средств их обеспечения, помещений или объек-
9
тов (зданий, сооружений, технических средств), в которых эти сред-
ства и системы установлены, или помещений и объектов, предназна-
ченных для ведения конфиденциальных переговоров.
В зависимости от конкретных условий, может решаться задача
обеспечения комплексной безопасности объекта информатизации или
защиты отдельных ресурсов – информационных, программных и т. д.
Информационные ресурсы (активы) – отдельные документы и
отдельные массивы документов, документы и массивы документов,
содержащиеся в информационных системах (библиотеках, архивах,
фондах, банках данных, информационных системах других видов).
Рассматривая вопросы безопасности АС, можно говорить о на-
личии некоторых «желательных» состояний системы, через которые и
описывается ее «защищенность» или «безопасность». Безопасность
является таким же свойством системы, как надежность или произво-
дительность, и в последнее время ей уделяется все большее внимание.
Чтобы указать на причины выхода системы из безопасного состояния,
вводятся понятия «угроза» и «уязвимость».
Угроза (безопасности информации) – совокупность условий и
факторов, создающих потенциальную или реально существующую
опасность нарушения безопасности информации.
Источник угрозы безопасности информации – субъект (физиче-
ское лицо, материальный объект или физическое явление), являю-
щийся непосредственной причиной возникновения угрозы безопасно-
сти информации. По типу источника угрозы делят на связанные и не-
связанные с деятельностью человека. Примерами могут служить уда-
ление пользователем файла с важной информацией и пожар в здании,
соответственно. Угрозы, связанные с деятельностью человека, разде-
ляют на угрозы случайного и преднамеренного характера. В послед-
нем случае источник угрозы называют нарушителем или злоумыш-
ленником.
Уязвимость (информационной системы) – свойство информа-
ционной системы, обуславливающее возможность реализации угроз
10
безопасности обрабатываемой в ней информации. Например, угроза
потери информации из-за сбоя в сети электропитания реализуется, ес-
ли в АС не применяются источники бесперебойного питания или
средства резервного электроснабжения (это является уязвимостью).
Если говорить об информационных ресурсах, то реализация уг-
розы может привести к таким последствиям как получение информа-
ции людьми, которым она не предназначена, уничтожение или изме-
нение информации, недоступность ресурсов для пользователей. Та-
ким образом, мы подошли к определению трех основных угроз безо-
пасности.
Угроза конфиденциальности (угроза раскрытия) – это угроза, в
результате реализации которой, конфиденциальная или секретная ин-
формация становится доступной лицу, группе лиц или какой-либо ор-
ганизации, которой она не предназначалась. Здесь надо пояснить раз-
ницу между секретной и конфиденциальной информацией. В отечест-
венной литературе «секретной» обычно называют информацию, отно-
сящуюся к разряду государственной тайны, а «конфиденциальной» –
персональные данные, коммерческую тайну и т. п.
Угроза целостности – угроза, в результате реализации которой
информация становится измененной или уничтоженной. Необходимо
отметить, что и в нормальном режиме работы АС данные могут изме-
няться и удаляться. Являются ли эти действия легальными или нет,
должно определяться политикой безопасности. Политика безопасно-
сти – совокупность документированных правил, процедур, практиче-
ских приемов или руководящих принципов в области безопасности
информации, которыми руководствуется организация в своей дея-
тельности.
Угроза отказа в обслуживании (угроза доступности) – угроза,
реализация которой приведет к отказу в обслуживании клиентов АС,
несанкционированному использованию ресурсов злоумышленниками
по своему усмотрению.
Ряд авторов [3] дополняют приведенную классификацию, вводя
11
угрозу раскрытия параметров АС, включающей в себя подсистему
защиты. Угроза считается реализованной, если злоумышленником в
ходе нелегального исследования системы определены все ее уязвимо-
сти. Данную угрозу относят к разряду опосредованных: последствия
ее реализации не причиняют какой-либо ущерб обрабатываемой ин-
формации, но дают возможность для реализации первичных (непо-
средственных) угроз.
Таким образом, безопасность информации – это состояние за-
щищенности информации, при котором обеспечены ее конфиденци-
альность, доступность и целостность. А защита информации может
быть определена как деятельность, направленная на предотвращение
утечки защищаемой информации, несанкционированных и непредна-
меренных воздействий на защищаемую информацию. Выделяются
следующие направления защиты информации:
- правовая защита информации – защита информации правовы-
ми методами, включающая в себя разработку законодательных и нор-
мативных правовых документов (актов), регулирующих отношения
субъектов по защите информации, применение этих документов (ак-
тов), а также надзор и контроль за их исполнением;
- техническая защита информации – защита информации, за-
ключающаяся в обеспечении некриптографическими методами безо-
пасности информации (данных), подлежащей (подлежащих) защите в
соответствии с действующим законодательством, с применением тех-
нических, программных и программно-технических средств;
- криптографическая защита информации – защита информа-
ции с помощью ее криптографического преобразования1;
- физическая защита информации – защита информации путем
применения организационных мероприятий и совокупности средств,
создающих препятствия для проникновения или доступа неуполно-
моченных физических лиц к объекту защиты.
1
Вопросы, связанные с криптографической защитой информации, будут
более подробно рассмотрены в разделе 2.
12
Защита информации осуществляется с использованием способов
и средств защиты. Способ защиты информации – порядок и правила
применения определенных принципов и средств защиты информации.
Средство защиты информации – техническое, программное, про-
граммно-техническое средство, вещество и (или) материал, предна-
значенные или используемые для защиты информации. Отдельно вы-
деляют:
- средства контроля эффективности защиты информации;
- средства физической защиты информации;
- криптографические средства защиты информации.
1.2. ОБЩАЯ СХЕМА ПРОЦЕССА ОБЕСПЕЧЕНИЯ
БЕЗОПАСНОСТИ
Рассмотрим теперь взаимосвязь основных субъектов и объектов
обеспечения безопасности, как это предлагается в международном
стандарте ISO/IEC-15408 (в России он принят как ГОСТ Р ИСО/МЭК
15408-2002 [4]).
Безопасность связана с защитой активов от угроз. Разработчики
стандарта отмечают, что следует рассматривать все разновидности
угроз, но в сфере безопасности наибольшее внимание уделяется тем
из них, которые связаны с действиями человека. Рисунок 1.1 иллюст-
рирует взаимосвязь между высокоуровневыми понятиями безопасно-
сти.
За сохранность активов отвечают их владельцы, для которых
они имеют ценность. Существующие или предполагаемые нарушите-
ли также могут придавать значение этим активам и стремиться ис-
пользовать их вопреки интересам их владельца. Действия нарушите-
лей приводят к появлению угроз. Как уже отмечалось выше, угрозы
реализуются через имеющиеся в системе уязвимости.
Владельцы активов анализируют возможные угрозы, чтобы оп-
ределить, какие из них могут быть реализованы в отношении рас-
13
сматриваемой системы. В результате анализа определяются риски
(т. е. события или ситуации, которые предполагают возможность
ущерба) и проводится их анализ.
Рис. 1.1. Понятия безопасности и их взаимосвязь
Владельцы актива предпринимают контрмеры для уменьшения
уязвимостей и выполнения политики безопасности. Но и после введе-
ния этих контрмер могут сохраняться остаточные уязвимости и соот-
ветственно – остаточный риск.
оценивают
хотят минимизировать
предпринимают чтобы уменьшить
которые
которые могут направлены на
быть уменьшены
могут знать
ведущие к
которые используют
которые для
повышают
порождают
для
хотят злоупотребить и/или могут нанести ущерб
ВЛАДЕЛЬЦЫ
КОНТРМЕРЫ
УЯЗВИМОСТИ
РИСК
ИСТОЧНИКИ УГРОЗ АКТИВЫ
(НАРУШИТЕЛИ)
УГРОЗЫ
14
1.3. ИДЕНТИФИКАЦИЯ, АУТЕНТИФИКАЦИЯ, УПРАВЛЕНИЕ
ДОСТУПОМ. ЗАЩИТА ОТ НЕСАНКЦИОНИРОВАННОГО
ДОСТУПА
В этом разделе будут рассмотрены вопросы, связанные с защи-
той информации от несанкционированного доступа (НСД).
Защита информации от несанкционированного доступа –
защита информации, направленная на предотвращение получения
защищаемой информации заинтересованными субъектами с наруше-
нием установленных нормативными и правовыми документами (ак-
тами) или обладателями информации прав или правил разграничения
доступа к защищаемой информации.
Для защиты от НСД, как правило, используется идентификация,
аутентификация и управление доступом. В дополнение к перечислен-
ным, могут применяться и другие методы.
Идентификация – присвоение пользователям идентификаторов
(уникальных имен или меток) под которыми система «знает» пользо-
вателя. Кроме идентификации пользователей, может проводиться
идентификация групп пользователей, ресурсов АС и т. д. Идентифи-
кация нужна и для других системных задач, например, для ведения
журналов событий. В большинстве случаев идентификация сопрово-
ждается аутентификацией. Аутентификация – установление подлин-
ности – проверка принадлежности пользователю предъявленного им
идентификатора. Например, в начале сеанса работы в АС пользова-
тель вводит имя и пароль. На основании этих данных система прово-
дит идентификацию (по имени пользователя) и аутентификацию (со-
поставляя имя пользователя и введенный пароль).
Управление доступом – метод защиты информации путем регу-
лирования использования всех ресурсов системы.
Система идентификации и аутентификации является одним из
ключевых элементов инфраструктуры защиты от НСД любой инфор-
15
мационной системы. Обычно выделяют 3 группы методов аутентифи-
кации.
1. Аутентификация по наличию у пользователя уникального
объекта заданного типа. Иногда этот класс методов аутентификации
называют по-английски “I have” («у меня есть»). В качестве примера
можно привести аутентификацию с помощью смарт-карт или элек-
тронных USB-ключей.
2. Аутентификация, основанная на том, что пользователю из-
вестна некоторая конфиденциальная информация – “I know” («я
знаю»). Например, аутентификация по паролю. Более подробно па-
рольные системы рассматриваются далее в этом разделе.
3. Аутентификация пользователя по его собственным уникаль-
ным характеристикам – “I am” («я есть»). Эти методы также называ-
ются биометрическими. Биометрические методы аутентификации де-
лят на статические и динамические.
Примеры аутентификации по статическим признакам – это про-
верка отпечатка пальца, рисунка радужной оболочки глаз, геометрии
кисти руки, сравнение с фотографией и т. д. Достоинством этих мето-
дов является достаточно высокая точность. Но надо отметить, что по-
добные методы, как правило, требуют наличия специализированного
оборудования (например, специальные сканеры) и имеют ограничен-
ную область применения (например, при аутентификации по отпечат-
ку пальца, из-за грязи на руке человек может не пройти аутентифика-
цию, т. е. подобные методы неприменимы на стройках и на многих
производствах).
Примеры динамической аутентификации – аутентификация по
голосу (при произнесении заранее определенной фразы или произ-
вольного текста), аутентификация по «клавиатурному почерку» (про-
веряются особенности работы пользователя на клавиатуре, такие как
время задержки при нажатии клавиш в различных сочетаниях) и т. д.
Нередко используются комбинированные схемы аутентифика-
ции, объединяющие методы разных классов. Например, двухфактор-
16
ная аутентификация – пользователь предъявляет системе смарт-карту
и вводит пин-код для ее активации.
Аутентификация может быть односторонней, когда одна сторо-
на аутентифицирует другую (например, сервер проверяет подлин-
ность клиентов), и двусторонней, когда стороны проводят взаимную
проверку подлинности.
Также аутентификация может быть непосредственной, когда в
процедуре аутентификации участвуют только две стороны, или с уча-
стием доверенной стороны. В последнем случае в процессе аутенти-
фикации участвуют не только стороны, проверяющие подлинность
друг друга, но и другая или другие, вспомогательные. Эту третью
сторону иногда называют сервером аутентификации
(англ. «authentication server») или арбитром (англ. «arbitrator»).
1.3.1. Парольные системы аутентификации
Наиболее распространенными на данный момент являются па-
рольные системы аутентификации. Определим ряд понятий, исполь-
зующихся при описании подобных систем.
Идентификатор пользователя – уникальная информация, по-
зволяющая различить отдельных пользователей парольной системы
(провести идентификацию). Это может быть имя учетной записи
пользователя в системе или специально генерируемые уникальные
числовые идентификаторы.
Пароль пользователя – секретная информация, известная только
пользователю (и возможно – системе), которая используется для про-
хождения аутентификации. В зависимости от реализации системы,
пароль может быть одноразовым или многоразовым. При прочих рав-
ных условиях, системы с одноразовыми паролями являются более на-
дежными. В них исключаются некоторые риски связанные с перехва-
том паролей – пароль действителен только на одну сессию и, если ле-
гальный пользователь его уже задействовал, нарушитель не сможет
такой пароль повторно использовать. Но системы с многоразовыми
17
паролями (в них пароль может быть использован многократно) проще
реализовать и дешевле поддерживать, поэтому они более распростра-
нены.
Учетная запись пользователя – совокупность идентификатора,
пароля и, возможно, дополнительной информации, служащей для
описания пользователя. Учетные записи хранятся в базе данных па-
рольной системы.
Парольная система – это программный или программно-
аппаратный комплекс, реализующий функции идентификации и ау-
тентификации пользователей компьютерной системы путем проверки
паролей. В отдельных случаях подобная система может выполнять
дополнительные функции, такие как генерация и распределение
криптографических ключей и т. д. Как правило, парольная система
включает в себя интерфейс пользователя, интерфейс администратора,
базу учетных записей, модули сопряжения с другими компонентами
подсистемы безопасности (подсистемой разграничения доступа, реги-
страции событий и т. д.).
Рассмотрим некоторые рекомендации по администрированию
парольной системы, использующей многоразовые пароли.
1. Задание минимальной длины используемых в системе паро-
лей. Это усложняет атаку путем подбора паролей. Как правило, реко-
мендуют устанавливать минимальную длину в 6-8 символов.
2. Установка требования использовать в пароле разные группы
символов – большие и маленькие буквы, цифры, специальные симво-
лы. Это также усложняет подбор.
3. Периодическая проверка администраторами безопасности ка-
чества используемых паролей путем имитации атак1, таких как под-
бор паролей «по словарю» (т. е. проверка на использование в качестве
1 Компьютерная атака – целенаправленное несанкционированное
воздействие на информацию, на ресурс автоматизированной информаци-
онной системы или получение несанкционированного доступа к ним с
применением программных или программно-аппаратных средств.
18
пароля слов естественного языка и простых комбинаций символов,
таких как «1234»).
4. Установление максимального и минимального сроков жизни
пароля, использование механизма принудительной смены старых па-
ролей. При внедрении данной меры надо учитывать, что при невысо-
кой квалификации пользователей, от администратора потребуются
дополнительные усилия по разъяснению пользователям того, что «от
них требует система».
5. Ограничение числа неудачных попыток ввода пароля (блоки-
рование учетной записи после заданного числа неудачных попыток
войти в систему). Данная мера позволяет защититься от атак путем
подбора паролей. Но при необдуманном внедрении также может при-
вести к дополнительным проблемам – легальные пользователи из-за
ошибок ввода паролей по невнимательности могут блокировать свои
учетные записи, что потребует от администратора дополнительных
усилий.
6. Ведение журнала истории паролей, чтобы пользователи, по-
сле принудительной смены пароля, не могли вновь выбрать себе ста-
рый, возможно скомпрометированный пароль.
1.4. МОДЕЛИ БЕЗОПАСНОСТИ
Как уже отмечалось в разделе 1.1, важным этапом процесса
обеспечения безопасности АС является разработка политики безопас-
ности. Если отсутствует политика безопасности, невозможно даже
четко провести разграничение между санкционированным (легаль-
ным) доступом к информации и НСД.
Политика безопасности может быть описана формальным или
неформальным образом. Формальное описание политики безопасно-
сти производится в рамках модели безопасности. С этой точки зрения,
модель безопасности можно определить как абстрактное описание
19
поведения целого класса систем, без рассмотрения конкретных дета-
лей их реализации.
Большинство моделей безопасности оперируют терминами
«сущность», «субъект», «объект».
Сущность – любая именованная составляющая защищаемой
АС.
Субъект – активная сущность, которая может инициировать за-
просы ресурсов и использовать их для выполнения каких-либо вы-
числительных операций. В качестве субъекта может выступать вы-
полняющаяся в системе программа или «пользователь» (не реальный
человек, а сущность АС).
Объект – пассивная сущность, используемая для хранения или
получения информации. В качестве объекта может рассматриваться,
например, файл с данными.
Обычно предполагается, что существует безошибочный способ
различения объектов и субъектов.
Доступ – взаимодействие между субъектом и объектом, в ре-
зультате которого производится перенос информации между ними.
Два фундаментальных типа доступа: чтение – операция, результатом
которой является перенос информации от объекта к субъекту; за-
пись – операция, результатом которой является перенос информации
от субъекта к объекту.
Также предполагается существование монитора безопасности
объектов, т. е. такого субъекта, который будет активизироваться при
любом обращении к объектам, может различать (на базе определен-
ных правил) легальные и несанкционированные обращения, и разре-
шать только легальный доступ.
В литературе выделяются три основных класса моделей полити-
ки безопасности: дискреционные, мандатные и ролевые.
Основу дискреционной (избирательной) политики безопасности
составляет дискреционное управление доступом, которое характери-
зуется следующими свойствами [3]:
20
- все субъекты и объекты должны быть идентифицированы;
- права доступа субъекта к объекту системы определяются на
основании некоторого внешнего по отношению к системе правила.
Правила дискреционного управления доступом часто задаются
матрицей доступов. В подобной матрице строки соответствуют субъ-
ектам системы, столбцы – объектам, элементы матрицы описывают
права доступа для соответствующей пары «субъект - объект».
Одной из наиболее известных дискреционных моделей является
модель Харрисона-Рузо-Ульмана, часто называемая матричной моде-
лью. Она будет подробно описана ниже.
Этот тип управления доступом наиболее часто используется в
операционных системах в связи с относительной простотой реализа-
ции. В этом случае, правила управления доступом часто описываются
через списки управления доступом (англ. «Access Control List», сокр.
ACL). Список связан с защищаемым объектом и хранит перечень
субъектов и их разрешений на данный объект. В качестве примера
можно привести использование ACL для описания прав доступа поль-
зователей и групп к файлу в файловой системе NTFS в операционных
системах семейства Windows NT.
Основу мандатной политики безопасности составляет мандат-
ное управление доступом, которое подразумевает, что:
- все субъекты и объекты должны быть идентифицированы;
- задан линейно упорядоченный набор меток секретности;
- каждому объекту системы присвоена метка секретности, опре-
деляющая ценность содержащейся в нем информации – его уровень
секретности;
- каждому субъекту системы присвоена метка секретности, оп-
ределяющая уровень доверия к нему – его уровень доступа;
- решение о разрешении доступа субъекта к объекту принимает-
ся исходя из типа доступа и сравнения метки субъекта и объекта.
21
Чаще всего мандатную политику безопасности описывают в
терминах модели Белла-ЛаПадула, которая будет рассмотрена ниже в
данном разделе.
Управление доступом, основанное на ролях, оперирует в терми-
нах «роль», «пользователь», «операция». Вся информация рассматри-
вается как принадлежащая организации (а не пользователю, ее соз-
давшему). Решения о разрешении или отказе в доступе принимаются
на основе информации о той функции (роли), которую пользователь
выполняет в организации. Роль можно понимать как множество дей-
ствий, которые разрешены пользователю для выполнения его долж-
ностных обязанностей. Администратор описывает роли и авторизует
пользователей на выполнение данной роли. Таким образом, ролевые
модели содержат как признаки мандатных, так и признаки избира-
тельных моделей.
1.4.1. Модель Харрисона-Рузо-Ульмана
Модель Харрисона-Рузо-Ульмана (матричная модель) использу-
ется для анализа системы защиты, реализующей дискреционную по-
литику безопасности. При этом система представляется конечным ав-
томатом, функционирующим согласно определенным правилам пере-
хода.
При использовании матричной модели доступа должны быть
определены множества субъектов S, объектов O и прав доступа R. В
качестве субъектов системы рассматриваются в первую очередь вы-
полняющиеся программы, поэтому предполагается, что SO. Усло-
вия доступа субъекта sS к объекту oO определяются матрицей
доступа. Пусть, например, множество прав доступа состоит из прав на
чтение (r), запись (w), выполнение (e). Запрет будет соответствовать
пустому множеству прав доступа (). Тогда матрица доступа может
быть такой, как представлено в табл. 1.1.
22
Таблица 1.1
Пример матрицы доступа
o1 o2 o3 o4
s1 rwe  rw rw
s2 e rwe r 
Здесь мы предполагаем, что объекты o1, o2 – это исполняемые
файлы, которые после запуска становятся субъектами s1 и s2.
Могут определяться и другие наборы прав, например, {чтение,
запись, владение}.
При описании систем с большим числом объектов и субъектов,
размерность матрицы доступа может получиться весьма значитель-
ной. Для ее снижения, одинаковые по имеющимся правам субъекты и
сходные по значимости объекты можно организовать в группы и да-
вать разрешения группе субъектов на группу объектов.
Функционирование системы рассматривается с точки зрения
изменений в матрице доступа. Модель определяет 6 примитивных
операций: «создать»/«уничтожить» объект и субъект, «вне-
сти»/«удалить» право доступа субъекта к объекту. Их описание при-
ведено в табл. 1.2.
Начальное состояние системы описывается множеством прав
доступа R, множеством субъектов S, множеством объектов O (SO,
мощности указанных множеств |S|=i, |O|=j, ij), матрицей доступа Mij
(элемент матрицы, соответствующий субъекту s и объекту o обозна-
чается M[s,o] и является подмножеством множества прав доступа).
Конечное состояние (после выполнения операции) – S’, O’, M’, R
(множество прав доступа не изменяется).
Из примитивных операторов могут составляться команды. Ко-
манда состоит из двух частей: условия, при котором она выполняется,
и последовательности операторов.
23
Таблица 1.2
Элементарные операции модели Харрисона-Рузо-Ульмана
Операция Результат операции
«создать» субъект s’, где
s’S
S’=S{s’}; O’=O{s’};
M’[s,o]= M[s,o] для всех sS, oO;
M’[s’,o]=  для всех oO’, M’[s,s’]= 
для всех sS’
«создать» объект o’, где
o’O
S’=S; O’=O{o’};
M’[s,o]= M[s,o] для всех sS, oO;
M’[s,o’]=  для всех sS’
«уничтожить» субъект
s’, где s’S
S’=S\{s’}; O’=O\{s’};
M’[s,o]= M[s,o] для всех sS’, oO’;
«уничтожить» объект o’,
где o’O
S’=S; O’=O\{o’};
M’[s,o]= M[s,o] для всех sS’, oO’;
«внести» право r’R в
M[s’,o’], где s’S, o’O
S’=S; O’=O; M’[s,o]=M[s,o] для ss’,sS’,
oo’, oO’;
M’[s’,o’]=M[s’,o’] {r’}
«удалить» право r’R из
M[s’,o’], где s’S, o’O
S’=S; O’=O; M’[s,o]=M[s,o] для ss’,sS’,
oo’, oO’;
M’[s’,o’]=M[s’,o’]\ {r’}
Общий вид команды [3]:
command С (x1, …, xk):
if r1 M[xs1,xo1] and … and rm M[xsm,xom] then
α1;
…
αn;
end ,
24
где r1, …, rm R – права доступа, α1, …, αn – последовательность при-
митивных операторов. При выполнении команды, система переходит
из состояния Q в новое состояние Q’. При этом, если хотя бы одно из
условий команды не выполнено, Q=Q’. Для примера, рассмотрим
команду создания субъектом s файла f. Множество прав доступа –
чтение (read), запись (write), владение (own). Cчитаем, что для созда-
ния файла не требуется выполнения каких-либо дополнительных ус-
ловий.
command «создать файл» (s, f)
«создать» объект f;
«внести» право владения own в M[s,f];
«внести» право на чтение read в M[s,f];
«внести» право на запись write в M[s,f];
end
Как показали результаты анализа данной модели безопасности,
задача построения алгоритма проверки безопасности систем, реали-
зующих дискреционную политику безопасности, не может быть ре-
шена в общем случае.
Введем ряд определений.
Будем считать, что возможна утечка права r  R в результате
выполнения команды c, если при переходе системы в конечное со-
стояние Q’ выполняется примитивный оператор, вносящий r в эле-
мент матрицы доступов M, до этого r не содержавший.
Начальное состояние Q0 называется безопасным по отношению
к некоторому праву r, если невозможен переход системы в такое со-
стояние Q, в котором может возникнуть утечка права r.
Система называется монооперационной, если каждая команда
содержит только один примитивный оператор.
Для модели Харрисона-Рузо-Ульмана были доказаны следую-
щие утверждения:
25
1. существует алгоритм, который проверяет, является ли исход-
ное состояние монооперационной системы безопасным для данного
права r;
2. задача проверки безопасности произвольных систем алгорит-
мически неразрешима.
Таким образом, с одной стороны, общая модель Харрисона-
Рузо-Ульмана может выражать большое разнообразие политик дис-
креционного доступа, но при этом не существует алгоритма проверки
их безопасности. С другой стороны, можно предпочесть моноопера-
ционную систему, для которой алгоритм проверки безопасности су-
ществует, но данный класс систем является слишком узким. Напри-
мер, монооперационные системы не могут выразить политику, даю-
щую субъектам права на созданные ими объекты, т.к. не существует
одной операции, которая и создает объект, и одновременно помечает
его как принадлежащий создающему субъекту.
1.4.2. Модель Белла-ЛаПадула
Классической мандатной моделью безопасности является мо-
дель Белла–ЛаПадула. В ней для описания системы используются:
S – множество субъектов (например, множество пользователей и
программ);
O – множество объектов (например, множество файлов);
L – линейно упорядоченное множество уровней безопасности
(например, «общий доступ», «для служебного пользования», «секрет-
но», «совершенно секретно»);
F: SO  L – функция, определяющая уровень безопасности
субъекта или объекта в данном состоянии;
V – множество состояний – множество упорядоченных пар
(F, M), где M – матрица доступа субъектов к объектам (матрица,
строки которой соответствуют субъектам системы, столбцы – объек-
там, элемент матрицы Mso, далее обозначаемый как M[s,o], описывает
права на доступ субъекта s к объекту o).
26
Система описывается начальным состоянием v0V, множеством
запросов R и функцией переходов T: (VR) V, описывающей пере-
ход системы из состояния в состояние под действием запроса.
В модели Белла–ЛаПадула вводится определение двух свойств
безопасности системы: безопасность по чтению и безопасность по за-
писи.
Состояние (F,M) безопасно по чтению тогда и только тогда, ко-
гда для  sS,  oO выполняется требование:
чтениеM[s,o]  F(s)F(o) ,
т. е. субъект s может прочитать информацию из объекта o, только ес-
ли уровень секретности o меньше или равен уровню доступа s. Дан-
ное свойство безопасности также называется правилом запрета чте-
ния с верхнего уровня.
Состояние (F,M) безопасно по записи тогда и только тогда, ко-
гда для  sS,  oO выполняется требование:
записьM[s,o]  F(o)F(s) ,
т. е. субъект s может записать информацию в объект o, только если
уровень секретности o выше или равен уровню доступа s. Данное
свойство безопасности также называется правилом запрета записи на
нижний уровень.
Состояние системы vV безопасно тогда и только тогда, когда
оно безопасно и по чтению, и по записи.
Система (v0,R,T) безопасна тогда и только тогда, когда ее на-
чальное состояние v0 безопасно и любое состояние, достижимое из v0
после выполнения конечной последовательности запросов из R, также
безопасно.
Большим достоинством модели Белла–ЛаПадула является то,
что для нее доказана основная теорема безопасности. В общем случае,
данная теорема формулируется следующим образом: если начальное
состояние системы безопасно и все переходы из состояния в состоя-
ние не нарушают ограничений, сформулированных политикой безо-
пасности, то любое состояние системы, достижимое за конечное чис-
27
ло переходов будет безопасным. В случае модели Белла-ЛаПадула,
ограничения не позволяют нарушить безопасность по чтению и запи-
си.
Основная теорема безопасности для модели Белла – ЛаПадула.
Система (v0,R,T) (т. е. система с начальным состоянием v0, мно-
жеством запросов R, функцией переходов T) безопасна тогда и только
тогда, когда состояние v0 безопасно и функция переходов T такова,
что для  vV, достижимого из состояния v0 после выполнения ко-
нечной последовательности запросов из R (таких что T(v,r)=v*, где
v=(F,M) – исходное состояние, v*=(F*,M*) – состояние после перехо-
да), для  sS,  oO выполняются следующие условия:
1. если чтениеM*[s,o] и чтениеM[s,o], то F*(s)F*(o);
2. если чтениеM[s,o] и F*(s)<F*(o), то чтениеM*[s,o];
3. если записьM*[s,o] и записьM[s,o], то F*(o)F*(s);
4. если записьM[s,o] и F*(o)<F*(s), то записьM*[s,o].
Кратко рассмотрим доказательство теоремы.
Необходимость. Если система безопасна, то начальное состоя-
ние v0 безопасно по определению. Пусть существует некоторое со-
стояние v*, достижимое из v0 путем выполнения конечного числа за-
просов из R и полученное в результате перехода из безопасного со-
стояния v: T(v,r)=v*. Тогда, если при таком переходе нарушено хотя
бы одно из первых двух ограничений, накладываемых теоремой на
функцию T, то состояние v* не будет безопасным по чтению. Если
функция T нарушает одно из двух последних условий теоремы, то со-
стояние v* не будет безопасным по записи. Таким образом, при нару-
шении условий теоремы система становится небезопасной. Необхо-
димость доказана.
Достаточность. Используем метод доказательства от против-
ного. Пусть система небезопасна. В этом случае, либо начальное со-
стояние v0 небезопасно, что противоречит условиям теоремы, либо
должно существовать небезопасное состояние v*, достижимое из
28
безопасного начального состояния v0 путем выполнения конечного
числа запросов из R. В этом случае, обязательно будет иметь место
переход T(v,r)=v*, при котором состояние v – безопасно, а v* - нет.
Однако четыре условия теоремы делают такой переход невозможным.
Несмотря на достоинства модели Белла–ЛаПадула, при ее стро-
гой реализации в реальных АС возникает ряд проблем.
1. Завышение уровня секретности, связанное с одноуровневой
природой объектов и правилом безопасности по записи. Если субъект
с высоким уровнем доступа хочет записать что-то в объект с низким
уровнем секретности, то сначала приходится повысить уровень сек-
ретности объекта, а потом осуществлять запись. Таким образом, даже
один параграф, добавленный в большой документ субъектом с высо-
ким уровнем доступа, повышает уровень секретности всего этого до-
кумента. Если по ходу работы изменения в документ вносят субъекты
со все более высоким уровнем доступа, уровень секретности доку-
мента также постоянно растет.
2. Запись вслепую. Эта проблема возникает, когда субъект про-
изводит операцию записи в объект с более высоким уровнем безопас-
ности, чем его собственный. В этом случае, после завершения опера-
ции записи, субъект не сможет проверить правильность выполнения
записи при помощи контрольного чтения, так как ему это запрещено в
соответствии с правилом безопасности по чтению.
3. Проблема удаленного чтения-записи. В распределенных сис-
темах при удаленном чтении файла создаются два потока: от субъекта
к объекту (запросы на чтение, подтверждения, прочая служебная ин-
формация) и от объекта к субъекту (сами запрашиваемые данные).
При этом, например, если F(s)>F(o), то первый поток будет противо-
речить свойству безопасности по записи. На практике для решения
этой проблемы надо разделять служебные потоки (запросы, подтвер-
ждения) и собственно передачу информации.
4. Доверенные субъекты. Модель Белла–ЛаПадула не учитыва-
29
ет, что в реальной системе, как правило, существуют субъекты, дей-
ствующие в интересах администратора, а также системные процессы,
например, драйверы. Жесткое соблюдение правил запрета чтения с
верхнего уровня и запрета записи на нижний уровень в ряде случаев
делает невозможной работу подобных процессов. Соответственно, их
также приходится выделять.
1.4.3. Ролевая модель безопасности
Ролевая модель безопасности появилась как результат развития
дискреционной модели. Однако она обладает новыми по отношению
к исходной модели свойствами: управление доступом в ней осущест-
вляется как на основе определения прав доступа для ролей, так и пу-
тем сопоставления ролей пользователям и установки правил, регла-
ментирующих использование ролей во время сеансов.
В ролевой модели понятие «субъект» замещается понятиями
«пользователь» и «роль» [5]. Пользователь – человек, работающий с
системой и выполняющий определенные служебные обязанности.
Роль – это активно действующая в системе абстрактная сущность, с
которой связан набор полномочий, необходимых для выполнения оп-
ределенной деятельности. Подобное разделение хорошо отражает
особенности деятельности различных организаций, что привело к
распространению ролевых политик безопасности. При этом, как один
пользователь может быть авторизован администратором на выполне-
ние одной или нескольких ролей, так и одна роль может быть сопос-
тавлена одному или нескольким пользователям.
При использовании ролевой политики, управление доступом
осуществляется в две стадии:
- для каждой роли указывается набор полномочий (разрешений на
доступ к различным объектам системы);
- каждому пользователю сопоставляется список доступных ему
ролей.
30
При определении ролевой политики безопасности используются
следующие множества:
U – множество пользователей;
R – множество ролей;
P – множество полномочий (разрешений) на доступ к объектам
системы;
S – множество сеансов работы пользователя с системой.
Как уже отмечалось выше, ролям сопоставляются полномочия, а
пользователям – роли. Это задается путем определения следующих
множеств:
PA P R – определяет множество полномочий, установлен-
ных ролям (для наглядности условно может быть представлено в виде
матрицы доступа);
UAU  R – устанавливает соответствие между пользователя-
ми и доступными им ролями.
Рассмотрим процесс определения прав доступа для пользовате-
ля, открывшего сеанс работы с системой (в рамках одного сеанса ра-
ботает только один пользователь). Правила управления доступом за-
даются с помощью следующих функций:
user : S U – для каждого сеанса sS эта функция определяет
пользователя, который осуществляет этот сеанс работы с системой:
user(s)  u | uU ;
roles – для каждого сеанса sS данная функция определяет
подмножество ролей, которые могут быть одновременно доступны
пользователю в ходе этого сеанса: roles(s) {r | (user(s),r ) UA} i i   ;
permissions : S P – для каждого сеанса sS эта функция за-
дает набор доступных в нем полномочий, который определяется пу-
тем объединения полномочий всех ролей, задействованных в этом се-
ансе:  ( ) ( ) { | ( , ) } permissions s r roles s pi pi r PA    .
В качестве критерия безопасности ролевой модели используется
следующее правило: система считается безопасной, если любой поль-
31
зователь системы, работающий в сеансе sS , может осуществлять
действия, требующие полномочия pP только в том случае, если
p permissions(s) .
Существует несколько разновидностей ролевых моделей управ-
ления доступом, различающихся видом функций user, roles и
permissions, а также ограничениями, накладываемыми на множества
PAи UA.
В частности, может определяться иерархическая организация
ролей, при которой роли организуются в иерархии, и каждая роль на-
следует полномочия всех подчиненных ей ролей.
Могут быть определены взаимоисключающие роли (т. е. такие
роли, которые не могут быть одновременно назначены одному поль-
зователю). Также может вводиться ограничение на одновременное
использование ролей в рамках одной сессии, количественные ограни-
чения при назначении ролей и полномочий, может производиться
группировка ролей и полномочий.
1.5. ПРОЦЕСС ПОСТРОЕНИЯ И ОЦЕНКИ СИСТЕМЫ
ОБЕСПЕЧЕНИЯ БЕЗОПАСНОСТИ. СТАНДАРТ ISO/IEC 15408
Одним из наиболее распространенных современных стандартов
в области информационной безопасности является международный
стандарт ISO/IEC 15408. Он был разработан на основе стандарта
«Общие критерии безопасности информационных технологий»
вер.2.1. В 2002 году этот стандарт был принят в России как ГОСТ Р
ИСО/МЭК 15408-2002 «Информационная технология. Методы обес-
печения безопасности. Критерии оценки безопасности информацион-
ных технологий» [4], часто называемый в литературе «Общие крите-
рии».
Стандарт разработан таким образом, чтобы удовлетворить по-
требности трех групп специалистов: разработчиков, экспертов по сер-
32
тификации и пользователей объекта оценки. Под объектом оценки
(ОО) в стандарте понимаются «подлежащие оценке продукт инфор-
мационных технологий (ИТ) или система с руководствами админист-
ратора и пользователя». К таким объектам относятся, например, опе-
рационные системы, прикладные программы, информационные сис-
темы и т. д. Ранее, в разделе 1.2 пособия рассматривалась определяе-
мая стандартом взаимосвязь высокоуровневых понятий в области ин-
формационной безопасности (рис.1.1).
«Общие критерии» предусматривают наличие двух типов требо-
ваний безопасности – функциональных и доверия. Функциональные
требования относятся к сервисам безопасности, таким как управление
доступом, аудит и т. д. Требования доверия к безопасности относятся
к технологии разработки, тестированию, анализу уязвимостей, по-
ставке, сопровождению, эксплуатационной документации и т. д.
Описание обоих типов требований выполнено в едином стиле:
они организованы в иерархию «класс – семейство – компонент – эле-
мент». Термин «класс» используется для наиболее общей группиров-
ки требований безопасности, а элемент – самый нижний, неделимый
уровень требований безопасности. В стандарте выделены 11 классов
функциональных требований:
- аудит безопасности;
- связь (передача данных);
- криптографическая поддержка (криптографическая защита);
- защита данных пользователя;
- идентификация и аутентификация;
- управление безопасностью;
- приватность (конфиденциальность);
- защита функций безопасности объекта;
- использование ресурсов;
- доступ к объекту оценки;
- доверенный маршрут/канал.
33
Основные структуры, определяемые «Общими критериями» –
это профиль защиты и задание по безопасности. Профиль защиты –
это независимая от реализации совокупность требований безопасно-
сти для некоторой категории ОО, отвечающая специфическим запро-
сам потребителя. Профиль состоит из компонентов или пакетов
функциональных требований и одного из уровней гарантированности.
Структура профиля защиты представлена на рис. 1.2.
Профиль определяет «модель» системы безопасности или от-
дельного ее модуля. Количество профилей потенциально не ограни-
чено, они разрабатываются для разных областей применения (напри-
мер, профиль «Специализированные средства защиты от несанкцио-
нированного доступа к конфиденциальной информации»).
Профиль защиты служит основой для создания задания по безо-
пасности, которое можно рассматривать как технический проект для
разработки ОО. Задание по безопасности может включать требования
одного или нескольких профилей защиты. Оно описывает также уро-
вень функциональных возможностей средств и механизмов защиты,
реализованных в ОО, и приводит обоснование степени их адекватно-
сти.
По результатам проводимых оценок, создаются каталоги серти-
фицированных профилей защиты и продуктов (операционных систем,
средств защиты информации и т. д.), которые затем используются при
оценке других объектов.
34
Рис. 1.2. Структура профиля защиты
Введение ПЗ Идентификация ПЗ
Аннотация ПЗ
Описание ОО
Среда безопасности
ОО
Предположения безопасности
Угрозы
Политика безопасности
организации
Замечания по применению
Обоснование
Логическое обоснование целей
безопасности
Логическое обоснование требований
безопасности
ПРОФИЛЬ ЗАЩИТЫ
Требования
безопасности для
среды ИТ
Требования безопас-
ности ИТ
Функциональные
требования
безопасности ОО
Требования
доверия к
безопасности ОО
Требования
безопасности
для ОО
Цели безопасности Цели безопасности для ОО
Цели безопасности для среды
35
2. ОСНОВЫ КРИПТОГРАФИИ
2.1. ОСНОВНЫЕ ПОНЯТИЯ. КЛАССИФИКАЦИЯ ШИФРОВ
Исторически криптография (в переводе с греческого – «тайно-
пись») зародилась как способ скрытой передачи сообщений без со-
крытия самого факта их передачи [6]. Для этой цели сообщение, на-
писанное с использованием какого-либо общепринятого языка, пре-
образовывалось под управлением дополнительной информации, на-
зываемой ключом. Результат преобразования, называемый крипто-
граммой, содержит исходную информацию в полном объеме, однако
последовательность знаков в нем внешне представляется случайной и
не позволяет восстановить исходную информацию без знания ключа.
Процедура преобразования называется шифрованием, обратного пре-
образования – расшифровыванием.
Сейчас криптографией принято называть науку о математиче-
ских методах обеспечения конфиденциальности и аутентичности (це-
лостности и подлинности) информации. Задачей исследования мето-
дов преодоления криптографической защиты занимается криптоана-
лиз. Для обозначения совокупности криптографии и криптоанализа
используется термин «криптология».
Несмотря на то, что шифры применялись еще до нашей эры, как
научное направление современная криптография относительно моло-
да. Одной из важнейших работ в данной области является статья Кло-
да Шеннона (Claude Shannon) «Теория связи в секретных системах»,
опубликованная в открытой печати в 1949 году. На рис. 2.1 изображе-
на предложенная Шенноном схема секретной системы [7].
На стороне отправителя имеются два источника информации –
источник сообщений и источник ключей. Источник ключей выбирает
из множества всех возможных ключей один ключ K, который будет
36
использоваться в этот раз. Ключ передается отправителю и получате-
лю сообщения таким образом, что его невозможно перехватить.
Рис. 2.1. Схема секретной системы
Отображение FK, примененное шифровальщиком к сообщению
M дает криптограмму C:
С  FKM . (2.1)
В связи с тем, что получатель должен иметь возможность вос-
становить сообщение M из криптограммы C при известном ключе K,
отображение FK должно иметь единственное обратное отображение
FK
-1, такое что:
M FK C
1  . (2.2)
Секретная система (или в современной терминологии – шифр)
определяется как семейство однозначно обратимых отображений
множества возможных сообщений во множество криптограмм. Выбор
ключа K определяет, какой именно элемент – FK – будет использо-
ваться. Предполагается, что противнику известна используемая сис-
тема, т. е. семейство отображений {Fi|i=1..N} и вероятности выбора
различных ключей. Однако он не знает, какой именно ключ выбран, и
Источник
сообщений
Шифровальщик:
FK
Шифровальщик:
FK
-1
Шифровальщик
противника
M C M
Источник
ключей
К
37
остальные возможные ключи столь же важны для него, как и истин-
ный.
Процесс расшифровывания сообщения для легального получа-
теля информации состоит в применении криптографического отобра-
жения, обратного по отношению к отображению, использованному
при шифровании.
Процесс расшифровки для противника представляет собой по-
пытку определить сообщение (или конкретный ключ), имея в распо-
ряжении только криптограмму и априорные вероятности различных
ключей и сообщений.
Существуют шифры, для которых любой объем перехваченной
информации недостаточен для того, чтобы найти шифрующее ото-
бражение. Шифры такого типа называются безусловно стойкими.
Иными словами, безусловно стойкими являются такие шифры, для
которых криптоаналитик (даже если он обладает бесконечными вы-
числительными ресурсами) не может улучшить оценку исходного со-
общения М на основе знания криптограммы С по сравнению с оцен-
кой при неизвестной криптограмме.
Шифры другого типа характеризуются тем, что при определен-
ном объеме перехваченных данных определить ключ (или расшифро-
вать сообщение без знания ключа) становится теоретически возмож-
но. Минимальный объем криптограммы, для которого существует
единственное решение криптоаналитической задачи, называется ин-
тервалом единственности. Однако, для криптоаналитика, обладаю-
щего ограниченными вычислительными ресурсами, вероятность най-
ти это решение за время, в течение которого информация представля-
ет ценность, чрезвычайно мала. Шифры такого типа называются ус-
ловно стойкими. Их стойкость основана на высокой вычислительной
сложности «взлома» шифра. Большинство применяемых сейчас шиф-
ров относятся к этому типу.
Доказано, что безусловно стойкие шифры существуют. Но для
их построения необходимо использовать равновероятный случайный
38
ключ, имеющий длину, равную длине сообщения. При соблюдении
этого условия сама процедура преобразования может быть достаточно
простой.
Рассмотрим следующий пример. Пусть нужно передать сообще-
ние M, представленное в двоичной кодировке. Вероятность того, что
очередной символ сообщения будет 1, равна q, 0 – (1 - q). Крипто-
грамма получается путем побитного сложения по модулю 2 (т. е. сло-
жения без переноса старшего разряда) сообщения с бесконечным,
случайным, равномерно распределенным ключом K:
С  M K . (2.3)
Подобное преобразование также называют гаммированием, а
ключ K – ключевой гаммой. Найдем вероятность того, что очередной
символ криптограммы будет равен 1. Это произойдет, если в исход-
ном сообщении соответствующий символ равен 0, а в ключе – 1, или в
сообщении – 1, в ключе – 0. Эти пары событий взаимоисключающие,
так что следует применить формулу сложения вероятностей:
p(C 1)  (1 q)0,5  q0,5  0,5 . (2.4)
Таким образом, вероятность появления в криптограмме единицы
не зависит от статистических свойств исходного сообщения. И анали-
зируя криптограмму, нарушитель не сможет получить дополнитель-
ной информации об исходном сообщении. Надо отметить, что подоб-
ными свойствами обладает только случайный бесконечный равно-
мерно распределенный ключ. Если вероятность появления в ключе
единицы отлична от 0,5, то q в формуле (2.4) не удастся исключить из
результата.
Рассмотрим, какими же свойствами должен обладать хороший
шифр. Во-первых, шифрование и расшифровывание должно осущест-
вляться достаточно быстро в тех условиях, в которых применяется
шифр (с использованием ЭВМ, при шифровании вручную и т. п.). Во-
вторых, шифр должен надежно защищать сообщение, т. е. быть стой-
ким к раскрытию.
39
Криптостойкость – стойкость шифра к раскрытию методами
криптоанализа. Она определяется вычислительной сложностью алго-
ритмов, применяемых для атаки на шифр. Вычислительная сложность
измеряется временной и емкостной сложностями [8].
Для определения сложности алгоритма с конкретной задачей
связывается число, называемое размером задачи, которое характери-
зует количество входных данных. Например, для задачи умножения
чисел размером может быть длина наибольшего из сомножителей.
Временная сложность (или просто сложность) – это время, за-
трачиваемое алгоритмом для решения задачи, рассматриваемое как
функция от размера задачи. Нередко сложность измеряют количест-
вом некоторых элементарных операций. Емкостная сложность –
объем памяти, необходимой для хранения полученных в ходе работы
данных, как функция от размера задачи.
Очень важное требование к стойкому шифру было сформулиро-
вано в XIX веке голландским криптографом Огюстом Керкгоффсом
(Auguste Kerckhoffs). В соответствии с ним, при оценке надежности
шифрования необходимо предполагать, что противник знает все об
используемой системе шифрования, кроме применяемых ключей.
Данное правило отражает важный принцип организации защиты ин-
формации: защищенность системы не должна зависеть от секретности
долговременных элементов (т. е. таких элементов, которые невоз-
можно было бы быстро изменить в случае утечки секретной инфор-
мации).
Существует несколько обобщенных постановок задачи криптоа-
нализа. Все они формулируются в предположении, что криптоанали-
тику известны применяемый алгоритм шифрования и полученные
криптограммы. Могут рассматриваться:
- атака при наличии только известной криптограммы;
- атака при наличии известного фрагмента открытого текста. В
этом случае, криптоаналитик имеет доступ к криптограммам, а также
к соответствующим некоторым из них исходным сообщениям. Зада-
40
ча – определить использующийся при шифровании ключ или рас-
шифровать все остальные сообщения. Разновидность данного класса
атак – атака с возможностью выбора открытого текста (когда крип-
тоаналитик может навязать текст для шифрования и получить соот-
ветствующую ему криптограмму);
- атаки, использующие особенности реализации аппаратных
шифраторов. В частности, может анализироваться тепловое и элек-
тромагнитное излучение от устройств, распространение ошибок после
однократного воздействия на аппаратуру (по цепи электропитания
или иным образом) и т. д.;
- атака методом полного перебора множества возможных клю-
чей. Данная атака также называется «атака методом грубой силы»
(англ. «brut force»).
2.1.1. Виды шифров
Рассмотрим классификации шифров по разным признакам. По
типу преобразований шифры можно разделить на следующие группы:
- шифры замены (подстановки);
- шифры перестановки;
- шифры гаммирования;
- шифры на основе аналитических преобразований.
При этом надо учитывать, что некоторые современные шифры
совместно используют преобразования различных типов.
Шифры замены (подстановки): преобразование заключается в
том, что символы шифруемого текста заменяются символами того
или иного алфавита (алфавита криптограммы) в соответствии с зара-
нее обусловленной схемой замены.
Подстановки разделяются на одноалфавитные и многоалфа-
витные. В первом случае, определенному символу алфавита исходно-
го сообщения всегда ставится в соответствие один и тот же символ
алфавита криптограммы. Один из наиболее известных шифров данно-
го класса – шифр Цезаря. В нем каждая буква алфавита заменялась на
41
следующую через одну после нее. В случае русского алфавита, «а»
меняется на «в», «б» на «г» и т. д. Алфавит «замыкался», поэтому «я»
надо было заменять на «б». В качестве ключа в данном случае высту-
пает число, на которое надо «сдвигать» символ алфавита, в нашем
примере – 2. К достоинству таких шифров относится простота преоб-
разования. Но они легко взламываются путем сравнения частоты по-
явления различных символов в естественном языке и криптограмме.
При использовании многоалфавитных подстановок, учитывают-
ся дополнительные параметры (например, положение преобразуемого
символа в тексте) и в зависимости от них символ исходного алфавита
может заменяться на один из нескольких символов алфавита шиф-
ртекста. Например, нечетные символы сообщения заменяются по од-
ному правилу, четные – по другому.
Шифры перестановок: шифрование заключается в том, что
символы исходного текста переставляются по определенному прави-
лу в пределах блока этого текста. При достаточной длине блока и
сложном, неповторяющемся порядке перестановки, можно достичь
приемлемой стойкости шифра.
Шифрование гаммированием заключается в том, что символы
шифруемого текста складываются с символами некоторой случайной
последовательности, называемой гаммой шифра или ключевой гам-
мой. Стойкость шифрования определяется длиной (периодом) непо-
вторяющейся части гаммы шифра, а также сложностью предугадыва-
ния следующих элементов гаммы по предыдущим.
Шифрование аналитическими преобразованиями подразумевает
использование аналитического правила (формулы) по которому пре-
образуется текст.
По типу использования ключей шифры делятся на:
- симметричные, использующие для шифрования и расшифро-
вывания информации один и тот же ключ;
42
- асимметричные, использующие для шифрования и расшифро-
вывания два различных ключа. Данный тип шифров будет подробно
рассматриваться в разделе 2.4.
По размеру преобразуемого блока шифры делятся на блочные и
потоковые.
Блочные шифры осуществляют преобразование информации
блоками фиксированной длины. Если длина шифруемого сообщения
некратна размеру блока, то его добавляют до нужной длины последо-
вательностью специального вида. Например, это может быть после-
довательность 100…0. После расшифровки, последний блок просмат-
ривают справа налево и отбрасывают «хвост» до первой единицы
включительно. Чтобы подобное дополнение было применимо во всех
случаях, если сообщение кратно длине блока, в его конец надо доба-
вить целый блок указанного вида.
Потоковые шифры предназначены для преобразования сообще-
ния поэлементно (элементом может быть бит, символ и т. п.). Приме-
ром такого вида шифров являются шифры гаммирования.
2.2. СИММЕТРИЧНЫЕ ШИФРЫ
2.2.1. Схема Фейстеля
Современные блочные шифры часто строятся на базе много-
кратного повторения некоторого набора операций преобразования,
называемых раундом шифрования.
В каждом раунде используется некоторая часть ключа, называе-
мая раундовым ключом. Порядок генерации и использования раундо-
вых ключей называется расписанием использования ключа шифрова-
ния.
В общем виде подобное итеративное преобразование может
быть описано следующей формулой:
Bi  E(Bi1,Ki ) , (2.5)
43
где E – раундовая функция шифрования, Bi – выходной блок, Bi1 –
входной блок для i -го раунда, Ki – ключ, используемый на i -м раун-
де; i 1N , где N – число раундов. Преобразование E должно быть
обратимо. Пусть D – раундовая функция дешифрования. Тогда раунд
обратного преобразования описывает формула:
Bi  D(Bi1,KNi1) . (2.6)
Здесь надо обратить внимание на расписание использования
ключей в случае прямого и обратного преобразования. Так при шиф-
ровании, в первом раунде будет использоваться первый раундовый
ключ, а в первом раунде при расшифровывании – последний.
Для разработки итерационных блочных шифров широко исполь-
зуется схема, предложенная в начале 1970-х годов Хорстом Фейсте-
лем (Horst Feistel). Данная схема, также называемая сетью Фейстеля,
приведена на рис. 2.2. Ее достоинство заключается в том, что она по-
зволяет использовать любые (в том числе необратимые) функции F
для реализации обратимых шифрующих преобразований.
Рис. 2.2. Прямое преобразование по схеме Фейстеля
Входной блок сообщения разбивается на два равных по длине
полублока: левый – L и правый – R.
Li-1 Ri-1
Li Ri
+ F(Ri-1,Ki)
Ki
44
Прямое преобразование осуществляется в соответствии со сле-
дующими соотношениями:
Li  Ri1,
Ri  Li1F(Ri1,Ki ) , (2.7)
где  – операция побитного сложения по модулю 2 (в табл.2.1 приве-
дено ее определение). Тогда исходный блок данных – этоL0 | R0 , а
LN | RN – это выходной блок данных.
Таблица 2.1
Операция сложения по модулю 2
X Y XY
0 0 0
0 1 1
1 0 1
1 1 0
Рис. 2.3. Обратное преобразование по схеме Фейстеля
Как видно из таблицы 2.1, для всех возможных значений опе-
рандов выполняется соотношение: (XY) Y=X. Именно это свой-
ство и позволяет при преобразовании использовать в числе прочих
необратимые функции F и, несмотря на это, иметь возможность про-
Li-1 Ri-1
Li Ri
F(Li-1,KN-i+1) +
KN-i+1
45
вести обратное преобразование. Обратное преобразование по схеме
Фейстеля представлено на рис. 2.3 и описывается формулами:
Ri  Li1,
Li  Ri1F(Li1,KNi1) . (2.8)
2.2.2. Шифр DES
Алгоритм шифрования DES (от англ. «Data Encryption
Standard») был опубликован в 1977 году и предназначался для защиты
важной, но несекретной информации в государственных и коммерче-
ских организациях США. Реализованные в нем идеи были во многом
позаимствованы в более ранней разработке корпорации IBM – шифре
«Люцифер» (а как раз в IBM работал Хорст Фейстель, автор рассмот-
ренной в предыдущем параграфе схемы). Но для своего времени
«Люцифер» был слишком сложным и его реализации отличались
низким быстродействием.
Шифр DES является блочным – преобразования в нем проводят-
ся блоками по 64 бита. Ключ также 64-битный, но значащими явля-
ются только 56 бит – каждый 8-й разряд использовался для контроля
четности (шифр разрабатывался тогда, когда аппаратура была не
слишком надежной и подобные проверки были необходимы). Обоб-
щенная схема алгоритма представлена на рис. 2.4.
Конечная перестановка – IP-1 – является обратной по отноше-
нию к начальной – IP. Задающие их таблицы жестко определены
стандартом (таблицы можно узнать из официального описания стан-
дарта, также они приводятся, например в [9]).
Раунды шифрования стоятся в соответствии с рассмотренной
ранее схемой Фейстеля (рис.2.2). Шифрование производится в 16 ра-
ундов. Схема раундовой функции F представлена на рис. 2.5.
46
Рис. 2.4. Обобщенная схема шифра DES
Рис. 2.5. Схема раундовой функции шифра DES
Ri-1 (32 бита)
Расширение E
48 бит
+
Ki (48 бит)
S1 S2 S3 S4 S5 S6 S7 S8
32 бита
Перестановка P
F(Ri-1,Ki)
16 раун-
дов
ключ
Исходный текст
Перестановка IP
Шифрование
Перестановка IP-1
Криптограмма
47
Сначала 32-битный правый полублок преобразуемого текста
расширяется до 48 бит с помощью функции расширения E. Эта функ-
ция производит дублирование и перестановку некоторых элементов
блока. В таблице 2.2 показано, как эта функция работает. После рас-
ширения в первых позициях полученного 48-битного блока будут
стоять 32-й, 1-й и т. д. биты входного блока.
Таблица 2.2
Функция E – расширение блока
32 1 2 3 4 5
4 5 6 7 8 9
8 9 10 11 12 13
12 13 14 15 16 17
16 17 18 19 20 21
20 21 22 23 24 25
24 25 26 27 28 29
28 29 30 31 32 1
После расширения, полученный 48-разрядный блок складывает-
ся побитно по модулю 2 с раундовым ключом Ki, схема генерации ко-
торого будет рассмотрена несколько ниже.
Далее производится подстановка по таблицам S1, …, S8, в ре-
зультате которой каждому 6-разрядному входному значению ставится
в соответствие 4-разрядное выходное. Таким образом, получив на
входе 48 бит, на выходе – снова имеем 32. Si представляет собой таб-
лицу с 16-ю столбцами и 4-мя строками, содержащую 4-битные эле-
менты. Таблицы подстановки, также как и перестановки, четко опре-
делены стандартом.
Пусть на вход подстановки подается 6-разрядный блок
B=b1b2…b6. Тогда совокупность старшего и младшего разрядов b1b6
будет указывать номер строки, а четырехбитное значение b2b3b4b5 –
номер столбца. Из ячейки на пересечении найденных строки и столб-
ца будет браться выходное значение подстановки. Полученный со-
единением выходных значений подстановок S1, …, S8 32-битный блок
48
подвергается перестановке P, порядок которой также строго опреде-
лен в стандарте.
Рассмотрим теперь порядок формирования раундовых ключей
на основе секретного. В общем виде алгоритм представлен на
рис. 2.6.
Рис. 2.6. Вычисление раундовых ключей
Как было ранее отмечено, секретный ключ шифра DES имеет
длину 64 бита, но каждый 8-й предназначается для контроля четно-
сти, поэтому эффективная длина ключа – 56 бит. Функция PC1 (со-
кращение «PC» от англ. «Permuted Choice» – выбор с перестановкой)
осуществляет перестановку элементов исходного блока, отбрасывая
Ключ K (64 бита)
Функция PC1
D0 (28 бит)
Сдвиг влево
C1 (28 бит)
C0 (28 бит)
Сдвиг влево
D1 (28 бит)
Сдвиг влево
C16 (28 бит)
Сдвиг влево
D16 (28 бит)
Функция
PC2
K1
(48 бит)
Функция
PC2
K16
(48 бит)
… … …
49
8-й, 16-й и т. д. биты. После перестановки полученный блок делится
на полублоки C0 и D0 длиной 28 бит каждый.
В зависимости от номера шага, полублоки Ci и Di независимо
друг от друга преобразуются путем циклического сдвига влево на од-
ну или две позиции (сдвиг на одну позицию производится на 1, 2, 9 и
16-м шагах, в остальных случаях – сдвиг на две позиции). Функция
PC2 преобразует блок Ci|Di, переставляя элементы и отбирая 48 бит,
которые и формируют раундовый ключ шифрования Ki (i=1…16).
Для того, чтобы иметь возможность использовать шифр DES
для решения различных криптографических задач, определены 4 ре-
жима его работы:
- электронная кодовая книга (англ. «Electronic Code Book» –
ECB);
- сцепление блоков шифра (англ. «Cipher Block Chaining» –
CBC);
- обратная связь по шифртексту (англ. «Cipher FeedBack» –
CFB);
- обратная связь по выходу (англ. «Output FeedBack» – OFB).
При использовании режима ECB, защищаемое сообщение раз-
бивают на 64-битные блоки Mi. Каждый такой блок шифруют незави-
симо от других, с использованием одного и того же ключа шифрова-
ния (рис. 2.7). При расшифровывании криптограммы Ci также преоб-
разуют независимо.
Достоинством данного режима является простота его реализа-
ции. Главный недостаток режима ECB заключается в том, что если в
исходном сообщении есть повторяющиеся блоки, то и значения соот-
ветствующих блоков криптограммы будет совпадать. А это даст
криптоаналитику противника дополнительную информацию о содер-
жании сообщения. Поэтому режим ECB рекомендуют использовать
для защиты небольших объемов данных (например, криптографиче-
ских ключей), где вероятность появления совпадающих блоков сооб-
щения невелика.
50
Рис. 2.7. Шифрование (а) и расшифровывание (б) в режиме ECB
Указанного выше недостатка лишен режим CBC. Исходное со-
общение, как и в предыдущем случае, разбивается на блоки Mi по 64
бита. Первый блок складывается побитно по модулю 2 с 64-битным
блоком, называемым инициализирующим вектором – IV, который из-
вестен обеим сторонам взаимодействия, периодически ими меняется
и держится в секрете от других. Блок исходного сообщения M2 моди-
фицируется с использованием блока криптограммы C1 и т. д. Анало-
гичные действия производятся при расшифровывании. Схема преоб-
разования представлена на рис. 2.8.
Рис. 2.8. Шифрование (а) и расшифровывание (б) в режиме CBC
IV M1
С1
DES
шифр.
IV C1
M1
DES
расшифр.
+
…
…
+
а б
M1
С1
DES
шифр.
M2
С2
DES
шифр.
C1
M1
DES
расшифр.
C2
M2
DES
расшифр.
а б
51
Режим CBC используется для шифрования больших сообщений.
Как легко заметить, последний блок криптограммы зависит от ини-
циализирующего вектора, каждого бита открытого текста и значения
секретного ключа. Поэтому его можно использовать для контроля це-
лостности и аутентификации сообщений, задавая ему фиксированное
значение и проверяя его после расшифровки.
Режим CFB используется в тех случаях, когда длина преобра-
зуемого блока отличается от 64 бит. Пусть необходимо зашифровать
сообщение, считываемое последовательно блоками по r бит, где
1 ≤ r ≤ 64. Для построения преобразования используется сдвиговый
регистр I, куда на 1-м шаге преобразования помещается инициализи-
рующий вектор IV. Схема преобразования представлена на рис. 2.9.
Преобразуемое сообщение M разбито на блоки по r бит, обозна-
чаемые на рисунке Mj. Блок криптограммы Cj будет равен Mj сложен-
ному побитно по модулю 2 с r старшими битами зашифрованного на
j-м шаге блока. Шифруемое значение Ij получается путем сдвига пре-
дыдущего блока Ij-1 влево на r позиций и записи блока криптограммы
Сj-1 в младшие позиции.
При расшифровывании сдвиговый регистр также инициализиру-
ется значением IV. Для того, чтобы получить ту же последователь-
ность вспомогательных значений Oj, что и при шифровании, здесь
также используется DES шифрование (а не расшифровывание, как
например, при обратном преобразовании в режиме CBC).
Режим OFB также позволяет шифровать блоки, меньшие по
длине, чем 64 бита. Его схема представлена на рис. 2.10. Аналогично
режиму CFB сдвиговый регистр сначала содержит значение инициа-
лизирующего вектора. Есть два варианта модификации его значения.
На рисунке представлен вариант с полной заменой на j-м шаге со-
держимого сдвигового регистра вспомогательным значением Oj-1.
Второй вариант построения схемы предполагает, как и в случае CFB,
сдвиг Ij-1 влево на r разрядов и запись в младшие разряды сдвигового
регистра старших r разрядов Oj-1.
52
Рис. 2.9. Шифрование (а) и расшифровывание (б) в режиме CFB
Рис. 2.10. Шифрование (а) и расшифровывание (б) в режиме
OFB
DES шифр.
I j(I1=IV)
Oj
Mj
r бит
64 бита
+
Cj
Oj-1
DES шифр.
Oj
Cj + Mj
Oj-1
I j(I1=IV)
64 бита
64 бита
64 бита
r бит
а б
I j(I1=IV)
DES шифр.
Oj
Mj
r бит
64 бита
+
64 бита
Cj
Cj-1
64 бита
64 бита
Cj Mj
сдвиг r разрядов
сдвиг r разрядов
а б
DES шифр.
I j(I1=IV)
Oj
r бит
+
Cj-1
53
При использовании режима OFB важно для каждого сеанса
шифрования данных использовать новое начальное состояние сдвиго-
вого регистра (его можно передавать, в том числе, и открытым тек-
стом). Связано это с тем, в режимах OFB и CFB генерируется псевдо-
случайная последовательность чисел, которая накладывается на блоки
открытого текста. В случае использования режима OFB, если дважды
используется один и тот же инициализирующий вектор и ключ шиф-
рования, то и генерируемые последовательности будут совпадать.
Некоторое время шифр DES считался достаточно безопасным.
Но по мере развития вычислительной техники, короткий 56-битный
ключ привел к тому, что атака путем полного перебора ключевого
множества стала относительно легко реализуемой. Чтобы увеличить
стойкость алгоритма и в то же время сохранить существующие нара-
ботки (в виде программных и аппаратных реализаций алгоритма), бы-
ло использовано многократное шифрование.
Сначала было предложено использовать повторное шифрование
на разных ключах. Обозначим шифрование на ключе k как Ek, а рас-
шифровывание как Dk. Тогда предлагаемая схема прямого преобразо-
вания описывалась как С=Ek2(Ek1(M)), обратного – M=Dk1(Dk2(C)). Од-
нако впоследствии было доказано, что из-за того, что два раза исполь-
зуется одно и то же преобразование, против подобной схемы может
быть успешно применена атака «встреча посередине». Ее суть заклю-
чается в том, что если хранить в памяти большой объем предвычис-
лений (расчет криптограммы для всех возможных значений ключа),
то можно взломать приведенную выше схему двукратного шифрова-
ния за 2n+1 попыток (вместо 22n как было бы при удвоении длины
ключа).
Более надежной оказалась схема, включающая шифрование,
расшифровывание и повторное шифрование на различных ключах.
Данный шифр получил название Triple DES. Варианты схемы его по-
строения приведены на рис. 2.11.
54
Рис. 2.11. Шифр Triple DES
Использование в шифре Triple DES различных ключей и преоб-
разований (шифрование и расшифровывание) позволяет противосто-
ять атаке «встреча посередине». В первом случае, выбор ключей про-
изводится так, как показано в верхней части рисунка: сначала произ-
водится шифрование на ключе K1, далее – расшифровывание на клю-
че K2, после – шифрование на ключе K1. Суммарная длина ключа –
112 бит. Более надежной считается схема с использованием в третьем
преобразовании еще одного ключа – K3 (изображена в нижней части
рисунка). Тогда суммарный ключ будет длиной 168 бит.
За счет более высокой надежности в настоящее время шифр
Triple DES используется чаще, чем шифр DES.
2.2.3. Шифр ГОСТ 28147-89
Данный алгоритм симметричного шифрования был разработан в
СССР и в качестве стандарта утвержден в 1989 году. Он считается
достаточно стойким и широко используется в России теми предпри-
ятиями и организациями, которым, в силу особенностей сферы их
деятельности, необходимо применять сертифицированные средства
криптографической защиты данных (это государственные и военные
структуры, организации банковской сферы и т. д.).
Этот шифр преобразует сообщение 64-битными блоками, пре-
образование осуществляется в соответствии со схемой Фейстеля в 32
M E D E С
K1
K1
K2 K1
K2 K3
55
раунда, размер ключа – 256 бит. Алгоритм предусматривает 4 режима
работы:
- шифрование данных в режиме простой замены (аналог режима
ECB для шифра DES);
- шифрование данных в режиме гаммирования (аналог режима
OFB для шифра DES);
- шифрование данных в режиме гаммирования с обратной свя-
зью;
- выработка имитовставки.
Ниже будет рассмотрен режим простой замены, являющийся
основой для построения других режимов. Схема раунда шифрования
приведена на рис. 2.12.
Рис. 2.12. Схема раунда алгоритма ГОСТ 28147-89
Li-1 Ri-1
Li Ri
S7
S6
S5
S4
S3
S2
S1
S0
+
Kj
+ <<<11
56
Преобразование производится в следующем порядке. Правый
полублок Ri-1 складывается по модулю 232 (сложение 32-разрядных
двоичных значений без переноса старшего разряда) с раундовым
ключом Kj. Далее выполняется подстановка, задаваемая таблицами
S0, …, S7, и полученное значение преобразуется с помощью цикличе-
ского сдвига влево на 11 позиций. После этого выполняется побитное
сложение по модулю 2 с левым полублоком Li-1 и перестановка полу-
блоков.
Расписание использования раундовых ключей формируется
следующим образом. 256-битный секретный ключ K представляется в
виде сцепления 8-ми 32-битных подключей K=K7|K6|K5|K4|K3|K2|K1|K0.
На первом раунде берется 0-й подключ, на втором – 1-й и т. д., на 9-м
раунде опять используется 0-й подключ, на 24-м – 7-й, а вот на 25-м
раунде преобразования вновь используется 7-й и далее ключи исполь-
зуются в обратном порядке. Иными словами, номер раундового ключа
j зависит от номера раунда i следующим образом:
j  (i 1)mod8 для 1 i  24,
j  (32 i)mod 8 для 25  i  32 . (2.9)
Подстановка проводится после разбиения входного значения на
4-битные подблоки. После того как правый полублок R был сложен с
раундовым подключем, он разбивается на 8 частей
R=R7|R6|R5|R4|R3|R2|R1|R0. Таблица подстановок Si представляет собой
вектор с 16-ю 4-битовыми элементами. Из нее берется элемент, номер
которого совпадает со значением Ri, пришедшим на вход подстанов-
ки. Надо отметить, что значения таблиц подстановки не определены
стандартом, как это сделано, например, в шифре DES. В то же время,
стойкость алгоритма существенно зависит от их правильного выбора.
Считается, что конкретные значения этих таблиц должны хра-
ниться в секрете и это своеобразные ключевые элементы, которые яв-
ляются общими для всей организации или подразделения и редко из-
меняются.
57
По сравнению с шифром DES у ГОСТ 28147-89 есть следующие
достоинства:
- существенно более длинный ключ (256 бит против 56 у шифра
DES), атака на который путем полного перебора ключевого множест-
ва на данный момент представляется невыполнимой;
- простое расписание использования ключа, что упрощает реа-
лизацию алгоритма и повышает скорость вычислений.
2.2.4. Шифр Blowfish
Шифр Blowfish был разработан известным американским крип-
тографом Брюсом Шнейером (Bruce Schneier) в 1993 году. Алгоритм
ориентирован на программную реализацию на 32-разрядных микро-
процессорах. Его отличают высокая скорость и криптостойкость.
Также в качестве отличительной особенности можно назвать возмож-
ность использовать ключ переменной длины. Шифр блочный, раз-
мер входного блока равен 64 битам. Преобразование блока выполня-
ется в 16 раундов (есть версия с 111-ю раундами). Ключ переменной
длины, максимально 448 бит.
До начала шифрования или расшифровывания данных произво-
дится расширение ключа. В результате, на базе секретного ключа по-
лучают расширенный, который представляет собой массив из 18 ра-
ундовых ключей K1, …, K18 (размерность Ki  32 бита) и матрицу под-
становок Q c 4-мя строками, 256-ю столбцами и 32-битными элемен-
тами.
(4)
255
(4)
0
(3)
255
(3)
0
(2)
255
(2)
0
(1)
255
(1)
0
Q Q
Q Q
Q Q
Q Q
Q




 . (2.10)
Данная матрица используется для задания нелинейной функции
шифрующего преобразования F(X), где X – 32-битный аргумент. X
58
представляется в виде сцепления 4-х 8-битных слов
X  X3 | X2 | X1 | X0 , а сама функция задается формулой (+ здесь обо-
значает сложение по модулю 232,  - сложение по модулю 2):
(1) (2) (3) (4)
3 2 1 0
( ) (( ) ) X X X X F X  Q Q Q Q . (2.11)
Рис. 2.13. Шифр Blowfish
Схема шифрующего преобразования приведена на рис.2.13.
Расширение секретного ключа KS производится следующим образом.
1) Начальный массив раундовых ключей Ki и элементов Q ини-
циализируется фиксированными значениями. Например, в шестна-
дцатеричном представлении K1=243F6A88 и т. д.
F
+
Входной блок (сообщение)
Выходной блок (криптограмма)
K1
+
K16
… …
+
F +
K + + 18 K17
59
2) K1 суммируется по модулю 2 с первыми 32-мя битами секрет-
ного ключа KS, K2 – со следующими 32-мя битами и т. д. Когда ключ
KS заканчивается, его начинают использовать сначала. Суммируются
только Ki (без Q).
3) 64-битный блок нулей 0=(0…0) зашифровывают с помощью
Blowfish на ключах, полученных на шагах 1) и 2): C0=Blowfish(0).
4) Раундовые подключи K1 и K2 заменяют полученным на шаге
3) значением C0.
5) C0 шифруют на модифицированных ключах C1= Blowfish(C0).
6) Раундовые ключи K3 и K4 заменяют значением C1.
7) Процесс продолжается, пока не будут получены сначала все
пары раундовых ключей (9 пар), а затем все пары элементов матрицы
Q (512 пар).
Таким образом, расширение ключа требует шифрования 521
блока данных. Эта процедура дополнительно осложняет атаку путем
перебора ключевого множества, т. к. нарушитель будет вынужден
проводить процедуру расширения для каждого возможного ключа.
2.3. УПРАВЛЕНИЕ КРИПТОГРАФИЧЕСКИМИ КЛЮЧАМИ
ДЛЯ СИММЕТРИЧНЫХ ШИФРОВ
Под ключевой информацией понимают совокупность всех клю-
чей, действующих в системе. Если не обеспечено достаточно надеж-
ное и безопасное управление ключевой информацией, то эффект от
применения криптографической защиты данных может быть сведен к
нулю: завладев ключами нарушитель сможет получить доступ и к за-
щищаемой информации. Процесс управления ключами включает в
себя реализацию трех основных функций:
- генерация ключей;
- хранение ключей;
- распределение ключей.
60
Генерация ключей должна производиться таким образом, чтобы
предугадать значение ключа (даже зная, как он будет генерироваться)
было практически невозможно. В идеальном случае, вероятность вы-
бора конкретного ключа из множества допустимых равна 1/N, где N –
мощность ключевого множества (число его элементов).
Для получения ключей используют аппаратные и программные
средства генерации случайных значений. Для систем с высокими тре-
бованиями к уровню безопасности более предпочтительными счита-
ются аппаратные датчики, основанные на случайных физических
процессах. В то же время, из-за дешевизны и возможности неограни-
ченного тиражирования наиболее распространенными являются про-
граммные реализации. Но надо учитывать, что получаемая в этом
случае последовательность будет псевдослучайной – если программ-
ный генератор повторно запустить с такими же начальными значе-
ниями, он выдаст ту же последовательность.
В программных генераторах ключей нередко используют алго-
ритмы шифрования и ключи, специально резервируемые для задач
генерации. В качестве начальных значений могут браться, например,
значения таймера вычислительной системы.
Рекомендуется регулярно проводить замену ключей, используе-
мых в системе. В некоторых случаях вместо замены допустимо ис-
пользовать процедуру модификации. Модификация ключа – генера-
ция нового ключа из предыдущего значения с помощью односторон-
ней функции (т. е. такой функции для которой обратное преобразова-
ние вычислить практически невозможно, более подробно – см. раздел
2.5). Но в этом случае надо учитывать, что новый ключ безопасен в
той же мере, что и прежний, т. к. противник может повторить всю це-
почку модификаций.
При организации хранения ключей симметричного шифрования
необходимо обеспечить такие условия работы, чтобы секретные клю-
чи никогда были записаны в явном виде на носителе, к которому мо-
жет получить доступ нарушитель. Например, это требование можно
61
выполнить, создавая иерархии ключей. Трехуровневая иерархия под-
разумевает деление ключей на:
- главный ключ;
- ключ шифрования ключей;
- ключ шифрования данных (сеансовый ключ).
Сеансовые ключи – нижний уровень иерархии – используются
для шифрования данных и аутентификации сообщений. Для защиты
этих ключей при передаче или хранении используются ключи шифро-
вания ключей, которые никогда не должны использоваться как сеан-
совые. На верхнем уровне иерархии располагается главный ключ (или
мастер-ключ). Его применяют для защиты ключей второго уровня.
Для защиты главного ключа в системах, использующих только сим-
метричные шифры, приходится применять не криптографические
средства, а например, средства физической защиты данных (ключ за-
писывается на съемный носитель, который после окончания работы
изымается из системы и хранится в сейфе, и т. п.). В относительно
небольших информационных системах может использоваться двух-
уровневая иерархия ключей (главный и сеансовые ключи).
При распределении ключей необходимо выполнить следующие
требования:
- обеспечить оперативность и точность распределения ключей;
- обеспечить секретность распределения ключей.
Распределение ключей может производиться:
- с использованием одного или нескольких центров распределе-
ния ключей (централизованное распределение);
- прямым обменом сеансовыми ключами между пользователями
сети (децентрализованное распределение ключей).
Децентрализованное распределение ключей симметричного
шифрования требует наличия у каждого пользователя большого ко-
личества ключей (для связи с каждым из абонентов системы), кото-
рые необходимо сначала безопасно распределить, а потом обеспечи-
вать их секретность в процессе хранения.
62
Централизованное распределение ключей симметричного шиф-
рования подразумевает, что у каждого пользователя есть только один
основной ключ для взаимодействия с центром распределения ключей.
Для обмена данными с другим абонентом, пользователь обращается к
серверу ключей, который назначает этому пользователю и соответст-
вующему абоненту сеансовый симметричный ключ. Одной из самых
известных систем централизованного распределения ключей является
Kerberos.
2.3.1. Протокол Kerberos
Протокол Kerberos был разработан в Массачусетском техноло-
гическом институте в середине 1980-х годов и сейчас является факти-
ческим стандартом системы централизованной аутентификации и
распределения ключей симметричного шифрования. Поддерживается
операционными системами семейства Unix, Windows (начиная с
Windows’2000), есть реализации для Mac OS.
Протокол Kerberos обеспечивает распределение ключей сим-
метричного шифрования и проверку подлинности пользователей, ра-
ботающих в незащищенной сети. Реализация Kerberos – это про-
граммная система, построенная по архитектуре «клиент-сервер».
Клиентская часть устанавливается на все компьютеры защищаемой
сети, кроме тех, на которые устанавливаются компоненты сервера
Kerberos. В роли клиентов Kerberos могут, в частности, выступать и
сетевые серверы (файловые серверы, серверы печати и т. д.).
Серверная часть Kerberos называется центром распределения
ключей (англ. «Key Distribution Center», сокр. KDC) и состоит из двух
компонент:
- сервер аутентификации (англ. «Authentication Server», сокр.
AS);
- сервер выдачи разрешений (англ. «Ticket Granting Server»,
сокр. TGS).
63
Каждому субъекту сети сервер Kerberos назначает разделяемый
с ним ключ симметричного шифрования и поддерживает базу данных
субъектов и их секретных ключей. Схема функционирования прото-
кола Kerberos представлена на рис. 2.14.
Рис. 2.14. Протокол Kerberos
Пусть клиент C собирается начать взаимодействие с сервером
SS (от англ. «Service Server» – сервер, предоставляющий сетевые сер-
висы). В несколько упрощенном виде, протокол предполагает сле-
дующие шаги [10,11].
1). C->AS: {c}.
Клиент C посылает серверу аутентификации AS свой идентифи-
катор c (идентификатор передается открытым текстом).
2). AS->C: {{TGT}KAS_TGS, KC_TGS}KC,
где KC – основной ключ C;
KC_TGS – ключ, выдаваемый C для доступа к серверу выдачи разреше-
ний TGS;
{TGT} –– билет на доступ к серверу выдачи разрешений (англ. «Ticket
Granting Ticket»); {TGT}={c,tgs,t1,p1, KC_TGS}, где tgs – идентификатор
сервера выдачи разрешений, t1 – отметка времени, p1 – период дейст-
Kerberos-сервер
(KDC)
Сервер
аутентиф.
AS
Сервер
выдачи
разрешений
TGS
клиент
C
1 2
3
4
Сервер
SS
5
6
Выполняется 1
раз в момент
начала сеанса
работы
64
вия билета. Запись {…}KX здесь и далее означает, что содержимое фи-
гурных скобок зашифровано на ключе KX.
На этом шаге сервер аутентификации AS, проверив, что клиент
C имеется в его базе, возвращает ему билет для доступа к серверу вы-
дачи разрешений и ключ для взаимодействия с сервером выдачи раз-
решений. Вся посылка зашифрована на ключе клиента C. Таким обра-
зом, даже если на первом шаге взаимодействия идентификатор с по-
слал не клиент С, а нарушитель X, то полученную от AS посылку X
расшифровать не сможет.
Получить доступ к содержимому билета TGT не может не толь-
ко нарушитель, но и клиент C, так как билет зашифрован на ключе,
который распределили между собой сервер аутентификации и сервер
выдачи разрешений.
3). C->TGS: {TGT}KAS_TGS, {Aut1} KC_TGS, {ID},
где {Aut1} – аутентификационный блок – Aut1 = {с,t2}, t2 – метка вре-
мени; ID – идентификатор запрашиваемого сервиса (в частности, это
может быть идентификатор сервера SS).
Клиент C на этот раз обращается к серверу выдачи разрешений
ТGS. Он пересылает полученный от AS билет, зашифрованный на
ключе KAS_TGS, и аутентификационный блок, содержащий идентифи-
катор c и метку времени, показывающую, когда была сформирована
посылка.
Сервер выдачи разрешений расшифровывает билет TGT и полу-
чает из него информацию о том, кому был выдан билет, когда и на ка-
кой срок, ключ шифрования, сгенерированный сервером AS для
взаимодействия между клиентом C и сервером TGS. С помощью этого
ключа расшифровывается аутентификационный блок. Если метка в
блоке совпадает с меткой в билете, это доказывает, что посылку сге-
нерировал на самом деле С (ведь только он знал ключ KC_TGS и мог
правильно зашифровать свой идентификатор). Далее делается про-
верка времени действия билета и времени оправления посылки 3). Ес-
65
ли проверка проходит и действующая в системе политика позволяет
клиенту С обращаться к клиенту SS, тогда выполняется шаг 4).
4). TGS->C: {{TGS}KTGS_SS,KC_SS}KC_TGS,
где KC_SS – ключ для взаимодействия C и SS, {TGS} – от англ. «Ticket
Granting Service» – билет для доступа к SS (обратите внимание, что
такой же аббревиатурой в описании протокола обозначается и сервер
выдачи разрешений). {TGS} ={с,ss,t3,p2, KC_SS }.
Сейчас сервер выдачи разрешений TGS посылает клиенту C
ключ шифрования и билет, необходимые для доступа к серверу SS.
Структура билета такая же, как на шаге 2): идентификатор того, кому
выдали билет; идентификатор того, для кого выдали билет; отметка
времени; период действия; ключ шифрования.
5). C->SS: {TGS}KTGS_SS, {Aut2} KC_SS ,
где Aut2={c,t4}.
Клиент C посылает билет, полученный от сервера выдачи раз-
решений, и свой аутентификационный блок серверу SS, с которым
хочет установить сеанс защищенного взаимодействия. Предполагает-
ся, что SS уже зарегистрировался в системе и распределил с сервером
TGS ключ шифрования KTGS_SS. Имея этот ключ, он может расшифро-
вать билет, получить ключ шифрования KC_SS и проверить подлин-
ность отправителя сообщения.
6). SS->C: {t4+1}KC_SS
Смысл последнего шага заключается в том, что теперь уже SS
должен доказать C свою подлинность. Он может сделать это, показав,
что правильно расшифровал предыдущее сообщение. Вот поэтому, SS
берет отметку времени из аутентификационного блока C, изменяет ее
заранее определенным образом (увеличивает на 1), шифрует на ключе
KC_SS и возвращает C.
Если все шаги выполнены правильно и все проверки прошли
успешно, то стороны взаимодействия C и SS, во-первых, удостовери-
лись в подлинности друг друга, а во-вторых, получили ключ шифро-
вания для защиты сеанса связи – ключ KC_SS.
66
Нужно отметить, что в процессе сеанса работы клиент проходит
шаги 1) и 2) только один раз. Когда нужно получить билет на доступ к
другому серверу (назовем его SS1), клиент С обращается к серверу
выдачи разрешений TGS с уже имеющимся у него билетом, т. е. про-
токол выполняется начиная с шага 3).
При использовании протокола Kerberos компьютерная сеть ло-
гически делится на области действия серверов Kerberos. Kerberos-
область – это участок сети, пользователи и серверы которого зареги-
стрированы в базе данных одного сервера Kerberos (или в одной базе,
разделяемой несколькими серверами). Одна область может охваты-
вать сегмент локальной сети, всю локальную сеть или объединять не-
сколько связанных локальных сетей. Схема взаимодействия между
Kerberos-областями представлена на рис. 2.15.
Для взаимодействия между областями, должна быть осуществ-
лена взаимная регистрация серверов Kerberos, в процессе которой
сервер выдачи разрешений одной области регистрируется в качестве
клиента в другой области (т. е. заносится в базу сервера аутентифика-
ции и разделяет с ним ключ).
После установки взаимных соглашений, клиент из области 1
(пусть это будет K11) может установить сеанс взаимодействия с кли-
ентом из области 2 (например, К21). Для этого K11 должен получить у
своего сервера выдачи разрешений билет на доступ к Kerberos-
серверу, с клиентом которого он хочет установить взаимодействие (на
рисунке это сервер KDC2). Полученный билет содержит отметку о
том, в какой области зарегистрирован владелец билета. Билет шифру-
ется на ключе, разделенном между серверами KDC1 и KDC2. При ус-
пешной расшифровке билета, удаленный Kerberos-сервер может быть
уверен, что билет выдан клиенту Kerberos-области, с которой уста-
новлены доверительные отношения. Далее протокол работает как
обычно.
67
Рис. 2.15. Взаимодействие между Kerberos-областями
Кроме рассмотренных, Kerberos предоставляет еще ряд допол-
нительных возможностей. Например, указанный в структуре билета
параметр p (период времени) задается парой значений «время начала
действия» – «время окончания действия», что позволяет получать би-
леты отложенного действия.
Имеется тип билета «с правом передачи», что позволяет, напри-
мер, серверу выполнять действия от имени обратившегося к нему
клиента.
2.4. АСИММЕТРИЧНЫЕ ШИФРЫ
2.4.1 Основные понятия
Несмотря на достижения в области симметричной криптогра-
фии, к середине 1970-х годов стала остро осознаваться проблема не-
применимости данных методов для решения целого ряда задач.
Во-первых, при использовании симметричных шифров необхо-
димо отдельно решать часто нетривиальную задачу распределения
ключей. Несмотря на использование иерархий ключей и центров рас-
пределения, в какой-то начальный момент ключ (или мастер-ключ)
Сервер
аутентиф.
Сервер
выдачи
разрешений
KDC1 Клиент
K11
Сервер
выдачи
разрешений
Сервер
аутентиф.
Клиент
KDC2
Клиент
K21
Область
действия
KDC1
Область дейст-
вия KDC2
Клиент
KDC1
KDC2
68
должен быть передан по безопасному каналу. Но такого канала может
просто не быть, или он может быть достаточно дорогостоящим.
Во-вторых, при использовании методов симметричного шифро-
вания подразумевается взаимное доверие сторон, участвующих во
взаимодействии. Если это не так, совместное использование одного и
того же секретного ключа может быть нежелательно.
Третья проблема связана с необходимостью проведения аутен-
тификации информации и защиты от угроз, связанных с отказом от-
правителя (получателя) от факта отправки (получения) сообщений.
Перечисленные проблемы являются весьма существенными, и
работа над их решением привела к появлению асимметричной крип-
тографии, также называемой криптографией с открытым ключом.
Рассмотрим ряд определений.
Односторонней (однонаправленной) функцией называется такая
функция F: XY, для которой выполняются следующие условия:
1) для всякого xX легко вычислить значение функции y = F(x),
где yY;
2) для произвольного yY невозможно (чрезвычайно сложно)
найти значение xX, такое что x = F -1(y) (т. е. найти значение функ-
ции обратной F).
Односторонней функцией с секретом k, называется такая функ-
ция Fk: XY, для которой выполняются следующие условия:
1) для всякого xX легко вычислить значение функции y = Fk(x),
где yY, даже в том случае, если значение k неизвестно;
2) не существует легкого (эффективного) алгоритма вычисления
обратной функции Fk
-1(y) без знания секрета k;
3) при известном k вычисление Fk
-1(y) для yY не представляет
существенной сложности.
В частности, односторонняя функция с секретом может быть
использована для шифрования информации. Пусть M – исходное со-
общение. Получатель выбирает одностороннюю функцию с секре-
том, и тогда любой, кто знает эту функцию, может зашифровать со-
69
общение для данного получателя, вычислив значение криптограммы
C = Fk(M). Расшифровать данную криптограмму может только закон-
ный получатель, которому известен секрет k.
Первой публикацией в области криптографии с открытым клю-
чом принято считать статью Уитфилда Диффи (Whitfield Diffie) и
Мартина Хеллмана (Martin Hellman) «Новые направления в крипто-
графии», вышедшую в свет в 1976 году.
В отличие от симметричных, в асимметричных алгоритмах
ключи используются парами – открытый ключ (англ. «public key») и
секретный или закрытый (англ. «private key»). Схема шифрования бу-
дет выглядеть следующим образом.
Получатель B генерирует пару ключей – открытый KB_pub и сек-
ретный KB_pr. Процедура генерация ключа должна быть такой, чтобы
выполнялись следующие условия:
1) ключевую пару можно было бы легко сгенерировать;
2) сообщение, зашифрованное на открытом ключе, может быть
расшифровано только с использованием секретного ключа;
3) зная только открытый ключ, невозможно рассчитать значение
секретного.
После генерации ключей, абонент B передает открытый ключ
отправителю A, а секретный ключ надежно защищает и хранит у себя
(рис. 2.16). Пересылка открытого ключа может осуществляться по
незащищенному каналу связи. Отправитель A, зная сообщение M и
открытый ключ, может рассчитать криптограмму C = E(M, KB_pub) и
передать ее получателю B. Получатель, зная секретный ключ, может
расшифровать криптограмму M = D(C, KB_pr).
Нарушитель, даже в том случае, если он смог перехватить крип-
тограмму и открытый ключ, не может расшифровать криптограмму.
Если использовать определение односторонней функции с сек-
ретом, то алгоритм шифрования и открытый ключ задают прямое
преобразование Fk, алгоритм расшифровывания задает обратное пре-
образование, а секретный ключ получателя играет роль «секрета» k.
70
Рис. 2.16. Асимметричное шифрование
Рассмотрим теперь вопрос аутентификации сообщений.
Электронная цифровая подпись (ЭЦП)1 – это реквизит элек-
тронного документа, предназначенный для защиты данного элек-
тронного документа от подделки, полученный в результате крипто-
графического преобразования информации с использованием закры-
того ключа электронной цифровой подписи и позволяющий иденти-
фицировать владельца сертификата ключа подписи, а также устано-
вить отсутствие искажения информации в электронном документе, а
также обеспечивает неотказуемость подписавшегося.
Функции ЭЦП аналогичны обычной рукописной подписи:
- удостоверить, что подписанный текст исходит от лица, поста-
вившего подпись;
- не дать лицу, подписавшему документ, возможности отказать-
ся от обязательств, связанных с подписанным текстом;
- гарантировать целостность подписанного текста.
1 Определение в соответствии федеральным законом Российской Федера-
ции «Об электронной цифровой подписи».
Сообщение
M
ОТПРАВИТЕЛЬ A ПОЛУЧАТЕЛЬ B
Шифр.
C = E(M,KB_pub)
Сообщение
M
Криптограмма
C Расшифр.
M = D(C,KB_pr)
Незащищенный
(небезопасный)
канал
Генератор
ключей
Секретный
ключ KB_pr
Открытый
ключ KB_pub
71
Важное отличие ЭЦП заключается в том, что электронный до-
кумент вместе с подписью может быть скопирован неограниченное
число раз, при этом копия будет неотличима от оригинала.
Обобщенная схема системы ЭЦП представлена на рисунке 2.17.
Рис.2.17. Электронная цифровая подпись
В ходе преобразований здесь используется пара ключей отпра-
вителя сообщения. Тот факт, что при вычислении ЭЦП применяется
секретный ключ отправителя, позволяет доказать происхождение и
подлинность сообщения. Получатель, имея открытый ключ отправи-
теля, проверяет ЭЦП, и если подпись корректна, то он может считать,
что сообщение подлинное.
2.4.2. Распределение ключей по схеме Диффи-Хеллмана
Как уже отмечалось выше, основы асимметричной криптогра-
фии были заложены американскими исследователями У.Диффи и
М.Хеллманом. Ими был предложен алгоритм, позволяющий двум
Сообщение
M
ОТПРАВИТЕЛЬ A ПОЛУЧАТЕЛЬ B
Генерация ЭЦП
S = F(M,KA_pr)
Сообщение
M
Подписанное
сообщение M,S
Проверка ЭЦП
M = F -1(S,KA_pub)
Незащищенный
(небезопасный)
канал
Генератор
ключей Открытый
ключ KA_pub
Секретный
ключ KA_pr
72
абонентам, обмениваясь сообщениями по небезопасному каналу свя-
зи, распределить между собой секретный ключ шифрования.
Для того, чтобы лучше разобраться с особенностями данного ал-
горитма, рассмотрим несколько определений из теории чисел. Два
целых числа n и n’ называются сравнимыми по модулю m, если при
делении на m они дают одинаковые остатки: n  n’ (mod m), m – мо-
дуль сравнения. Таким образом, можно разбить множество целых чи-
сел Z на классы чисел, сравнимых между собой по модулю m и назы-
ваемых классами вычетов по модулю m. Каждый класс вычетов имеет
вид:
{r}m {r mk | kZ}. (2.12)
Множество всех классов вычетов по модулю m обозначается как
Zm или Z/mZ. Каждым двум классам {k}m и {l}m независимо от выбора
их представителей, можно сопоставить класс, являющийся их суммой
и произведением, таким образом, однозначно определяются операции
сложения и умножения. Множество {Zm , , } является коммутатив-
ным кольцом с единицей, а если число m – простое, то конечным по-
лем.
Мультипликативная группа {Zm , } при m=1,2,4,pk,2pk (где kN,
p – нечетное простое число) является циклической [12], т. е. сущест-
вует образующий элемент aZm, такой что степени a в определенном
порядке дают все значения от 0 до m-1. Элемент a также называется
первообразным корнем по модулю m.
В алгоритме Диффи-Хеллмана в качестве односторонней функ-
ции используется возведение в степень по модулю простого числа:
y a p x  mod . (2.13)
Здесь p – большое простое число (сейчас считается безопасным
использовать модуль порядка 21024 или более), a – первообразный ко-
рень по модулю p. Задача нахождения обратного значения, т. е. вы-
числения x по известному y, называется задачей дискретного лога-
рифмирования и является вычислительно сложной. Иными словами,
73
при достаточно больших значениях модуля, показателя и основания
степени функцию (2.13) можно считать необратимой.
Пусть p – простое число, p>2, и известно разложение p-1 на про-
стые множители: 

 
k
j
j
j p q
1
1

. Число a является первообразным кор-
нем по модулю p тогда и только тогда, когда выполняются следую-
щие условия [12]:
НОД(a, p) 1; 1(mod )
( 1) /
a p p q j


, j 1,...,k , (2.14)
где НОД(x,y) – наибольший общий делитель чисел x и y.
Рассмотрим теперь алгоритм Диффи-Хеллмана по шагам. Пусть
абоненты сети Алиса и Боб предварительно согласовали значения a и
p из (2.13). При этом требуется, чтобы разложение числа (р-1) содер-
жало большой простой множитель, например, (p-1)=2t, где t – про-
стое.
1). Алиса выбирает секретный ключ XA и вычисляет соответст-
вующий ему открытый ключ Y aXA p
A  mod .
2). Боб в свою очередь определяет XB и рассчитывает
Y aXB p
B  mod .
3). Абоненты обмениваются открытыми ключами YA и YB.
4). Абоненты вычисляют общий секретный ключ. Алиса пользу-
ется следующим соотношением: K Y XA p
AB  ( B ) mod . Боб использует
формулу: K Y XB p
BA  ( A) mod . Покажем, что KAB=KBA, воспользовав-
шись свойством ассоциативности операции умножения в конечном
поле:
BA
X X X X X
KAB YB p a p a p K  ( ) A mod  ( B ) A mod  ( A ) B mod  . (2.15)
Таким образом, стороны смогли распределить общий секретный
ключ KAB. Нарушитель, который может перехватить передаваемые от-
крытые ключи YA и YB, должен попытаться по ним вычислить общий
секретный ключ без знания секретных ключей абонентов. На данный
момент не найдено существенно лучшего пути решения данной зада-
74
чи, чем дискретное логарифмирование, что и обеспечивает крипто-
графическую стойкость алгоритма.
2.4.3. Криптографическая система RSA
Алгоритм RSA был предложен в 1977 году и стал первым пол-
ноценным алгоритмом асимметричного шифрования и электронной
цифровой подписи. Алгоритм назван по первым буквам фамилий ав-
торов – Рональд Райвест (Ronald Rivest), Ади Шамир (Adi Shamir) и
Леонард Адлеман (Leonard Adleman). Стойкость алгоритма основы-
вается на вычислительной сложности задачи факторизации (разложе-
ния на множители) больших чисел и задачи дискретного логарифми-
рования.
Криптосистема основана на теореме Эйлера, которая гласит, что
для любых взаимно простых чисел M и n (M<n) выполняется соотно-
шение:
1(mod ) ( ) M n n   , (2.16)
где (n) - функция Эйлера. Эта функция равна количеству натураль-
ных чисел меньших n, которые взаимно просты с n. По определению,
(1) 1. Также доказано, что для любых двух натуральных взаимно
простых чисел a и b выполняется равенство (a b) (a) (b) .
Алгоритм строится следующим образом. Пусть M – блок сооб-
щения, 0≤M<n. Он шифруется в соответствии с формулой:
C M (mod n) e  . (2.17)
В этом случае e – открытый ключ получателя. Тогда соответст-
вующий ему секретный ключ d должен быть таким, что
M C (mod n) (M ) (mod n) M (mod n) d e d ed    . (2.18)
Как уже отмечалось, теорема Эйлера утверждает, что
1(mod ) ( ) M n n   или, что то же самое, (mod ) ( ) 1 M M n k n    , где k –
натуральный множитель. Сопоставив данное выражение c выражени-
ем (2.18) получаем, что e и d должны быть связаны соотношением:
75
ed  k (n) 1  ed 1(mod(n)) . (2.19)
Теперь предположим, что n  p  q , где p и q – простые числа,
причем pq. Нетрудно показать, что для простого числа p1 функция
Эйлера будет равна ( p)  p 1. Тогда, учитывая, что p и q – простые
и не равны друг другу (а значит, они и взаимно простые), будет спра-
ведливо равенство:
( pq) ( p) (q)  ( p 1)  (q 1) . (2.20)
Рассмотрим теперь алгоритм RSA «по шагам». Первым этапом
является генерация ключей.
1) Выбираются два больших простых числа p и q, pq.
2) Вычисляется модуль n: n = pq. Обратите внимание, что для
криптосистемы RSA модуль n является частью открытого ключа и
должен меняться при смене ключевой пары.
3) Случайным образом выбирается число d, такое что
1 d  ( p 1)  (q 1) и НОД(d, (p-1)(q-1))=1.
4) Вычисляется значение e такое что:
1 e  ( p 1)  (q 1)
ed 1mod(( p 1)(q 1))
Доказано, что для случая, когда НОД(d, (p-1)(q-1))=1 такое e
существует и единственно.
В результате выполнения данных вычислений имеем открытый
ключ, представленный парой чисел (n, e) и секретный ключ d.
Шифрование производится следующим образом.
Отправителю известен открытый ключ получателя – (n,e). Пусть
M – секретное сообщение, которое надо зашифровать M<n. Крипто-
грамма вычисляется по формуле:
C M n e mod . (2.21).
Криптограмма C передается получателю. Владелец секретного
ключа d может расшифровать сообщение по формуле (2.22).
M C n d  mod . (2.22)
76
Рассмотрим теперь схему построения электронной цифровой
подписи. Сообщение M подписывается с использованием секретного
ключа d (но для генерации подписи используется уже ключевая пара
отправителя):
S M n d  mod . (2.23)
Отправитель передает получателю подписанное сообщение, т. е.
пару значений (M,S). Проверка ЭЦП по открытому ключу (n,e) произ-
водится так:
M S n e ' mod . (2.24)
Совпадение значений M и M' служит доказательством того, что
сообщение получено от владельца соответствующего секретного
ключа и не было изменено в процессе передачи.
Как видно, сами преобразования относительно просты. Основ-
ную сложность при реализации алгоритма RSA представляет этап ге-
нерации ключей. В частности, простые числа p и q выбираются таки-
ми, что:
- одно из них должно быть меньше другого на несколько поряд-
ков;
- (p-1) и (q-1) должны иметь как можно меньший НОД;
- хотя бы одно из чисел (p-1), (q-1) должно иметь в разложении
большой простой множитель (например, (p-1) = 2t, где t – простое).
Точное определение, является ли большое число простым или
нет, во многих случаях является вычислительно сложной задачей. По-
этому, как правило, используются «псевдопростые» тесты, которые
позволяют с достаточно большой вероятностью отбросить числа не
являющиеся простыми. Один из таких тестов основан на малой тео-
реме Ферма, которая гласит, что если p – простое число и 1 x<p, то
x p p 1mod 1   . Проверив «кандидата» в простые числа с несколькими
x, выбираемыми в соответствии со специальными требованиями,
можно с большой вероятностью выяснить, является ли он простым.
Нахождение наибольшего общего делителя и определение зна-
чения e на шаге 4) алгоритма генерации ключей производится в соот-
77
ветствии с алгоритмом Евклида и обобщенным алгоритмом Евклида
[7,9,12].
2.4.4. Криптографическая система Эль-Гамаля
В 1984 году американским исследователем египетского проис-
хождения Тахером Эль-Гамалем (Taher Elgamal) были опубликованы
алгоритмы шифрования с открытым ключом и ЭЦП, получившие его
имя. Криптографическая система Эль-Гамаля использует ту же мате-
матическую основу, что и рассмотренная ранее схема распределения
ключей Диффи-Хеллмана: в качестве односторонней функции в этой
криптосистеме используется возведение в степень по модулю боль-
шого простого числа.
Алгоритм шифрования строится следующим образом.
Выбирается большое простое число р такое, что разложение
числа (р-1) содержит большой простой множитель, а также число а
такое, что 1 < а < (p-1) и a – первообразный корень по модулю p.
Получатель сообщения генерирует ключевую пару: случайным
образом выбирает секретный ключ x (0 < x < р) и вычисляет откры-
тый ключ y a p x  mod .
Для шифрования сообщения М (0 ≤ М < р), отправитель должен
выполнить следующие действия.
1. Выбрать случайное число k такое, что 1 < k < p-1,
НОД(k,р-1)=1.
2. Вычислить вспомогательное значение r y p k  mod .
3. Рассчитать значение криптограммы, состоящее из двух час-
тей: c a p k 1  mod , с2  rM mod p .
Надо отметить, что в [10] приводится вариация данного алго-
ритма, где вторая часть криптограммы рассчитывается как
с  r M '
2 , где  – побитное сложение по модулю 2.
78
Рассмотрим процесс расшифровки. Для того, чтобы по c2 опре-
делить M, получателю потребуется рассчитать значение r. С учетом
того, что ему известен секретный ключ x и значение c1 это становится
возможным: c a r p x k x 1  ( )  mod . Тогда M c r c c p x ( ) mod 1
2 1
1
2
    .
Или для варианта со сложением по модулю 2: M c c p x 1 mod
'
 2  .
При использовании шифра Эль-Гамаля требуется, чтобы выби-
раемое в процессе шифрования число k, каждый раз менялось. В про-
тивном случае, если сообщения М и М' предназначены одному полу-
чателю, и нарушитель смог узнать одно из них, то ему не составит
труда рассчитать и второе. Пусть, например, нарушитель знает сооб-
щение M, соответствующие ему криптограммы c1 и c2, и криптограм-
мы c1' и с2'. Из-за того, что k и ключи не менялись, будут совпадать r и
r', c1 и с1'. М' нарушитель может рассчитать как:
M c r mod p 1
2
  ; M' c 'r c 'Mc mod p 1
2 2
1
2
    . (2.25).
Рассмотрим теперь предложенный Эль-Гамалем алгоритм
электронной цифровой подписи. Надо отметить, что он получил ши-
рокое распространение и на его базе был разработан американский
стандарт ЭЦП DSA (англ. «Digital Signature Algorithm»).
Как и при шифровании, стороны согласуют параметры a и p.
После этого, отправитель выбирает секретный ключ x и рассчитывает
открытый ключ y a p x  mod .
Подписываемое сообщение M должно удовлетворять условию
0  M < p. Подписью абонента служит пара чисел r и s (0  r < p,
0  s < p), которые удовлетворяют соотношению:
a y r p M r s  mod (2.26).
Получатель, знающий сообщение и открытый ключ, может про-
верить выполнение этого равенства. Но только владелец секретного
ключа x может правильно рассчитать значения r и s. Для этого он вы-
полняет следующие действия.
1. Выбирает случайное число k: 1 < k < p-1, НОД(k,р-1)=1.
79
2. Вычисляет r a p k  mod .
3. Вычисляет s из уравнения M  xr  ksmod( p 1) . Это уравне-
ние получено, основываясь на доказанном в теории числе утвержде-
нии: если p – простое, a – целое, 1<a<p (в этом случае, a и p будут и
взаимно просты), то a a p x y  mod равносильно x  y mod( p 1) для
любых целых неотрицательных x, y. Таким образом,
( ) mod( 1) 1     s M xr k p . При выполнении условия НОД(k,р-1)=1, s
существует и единственно.
Отправитель передает сообщение с подписью (M,r,s) получате-
лю, который, пользуясь соотношением (2.26), может проверить ЭЦП.
При применении алгоритма ЭЦП Эль-Гамаля, также как и в
случае шифрования, недопустимо использовать одно и то же значение
k для подписи двух разных сообщений.
2.4.5. Совместное использование симметричных и асимметричных
шифров
Основным достоинством криптографических алгоритмов с от-
крытым ключом является возможность решения таких задач, как рас-
пределение ключа по небезопасному каналу, аутентификации сооб-
щения и отправителя, и т. д. В то же время, асимметричные шифры
работают существенно более медленно, чем симметричные. Это свя-
зано с необходимостью производить операции над сверхбольшими
числами. Поэтому симметричные и асимметричные алгоритмы часто
используют вместе – для распределения ключей и ЭЦП используют
криптографию с открытым ключом, данные шифруют с помощью
симметричных алгоритмов.
При анализе системы, в которой совместно используются не-
сколько алгоритмов, принято оценивать сложность ее взлома по
сложности взлома самого слабого звена. В литературе [9] приводится
примерное соответствие длин ключей для алгоритма симметричного
шифрования (атака производится путем перебора ключевого множе-
80
ства) и алгоритма RSA, обеспечивающих сопоставимую стойкость.
Например, 64-битному ключу симметричного шифрования примерно
соответствует 512-битный ключ RSA, а 128-битному – ключ RSA
длиной более 2300 бит.
2.5. ХЭШ-ФУНКЦИИ
В рассмотренных в разделе 2.4 алгоритмах формирования ЭЦП
длина подписи получается равной или даже большей, чем длина са-
мого сообщения. Очевидно, что удостоверять подобным образом
большой документ неудобно. Поэтому подписывается, как правило,
не само сообщение, а его «дайджест» – значение фиксированной дли-
ны, зависящее от подписываемого сообщения. Для формирования
дайджеста используется хэш-функция (от англ. «hash function») – од-
носторонняя функция, преобразующая строку произвольной длины в
строку фиксированной длины. В криптографии используются хэш-
функции 2 классов:
- хэш-функции без ключа;
- хэш-функции с ключом.
2.5.1. Хэш-функции без ключа
Хэш-функции без ключа делятся на слабые и сильные. Слабой
хэш-функцией называется односторонняя функция H(x), удовлетво-
ряющая следующим условиям:
1) аргумент может быть строкой бит произвольной длины;
2) значение функции H(x) должно быть строкой бит фиксиро-
ванной длины;
3) значение H(x) легко вычислить;
4) для любого фиксированного аргумента x вычислительно не-
возможно найти другой x’x, такой что H(x’)=H(x).
81
Пара значений x’x: H(x’)=H(x) называется коллизией хэш-
функции.
Сильной хэш-функцией называется односторонняя функция H(x),
удовлетворяющая условиям 1) – 3) и последнему условию в следую-
щей формулировке:
4’) вычислительно невозможно любую пару значений x’x, та-
ких что H(x’)=H(x).
Любая сильная хэш-функция соответствует и требованиям для
слабой, обратное в общем случае неверно. Для иллюстрации различия
в сложности поиска коллизий слабой и сильной хэш-функции рас-
смотрим атаку с использованием «парадокса дней рождения»1. За-
фиксируем значение аргумента x, и будем перебирать случайным об-
разом x’x в поисках ситуации, когда H(x’)=H(x). Если предположить,
что значения хэш-функции равномерно распределены, а число воз-
можных значений H(x) равно N, то потребуется в среднем перебор
N / 2 вариантов. Если же мы захотим найти какую-либо коллизию во-
обще, то задача оказывается проще: с вероятностью 0,63 для опреде-
ления нужной пары значений потребуется опробовать N вариантов.
Чтобы минимизировать стоимость создания криптографических
хэш-функций, разработчики часто используют один из существую-
щих алгоритмов шифрования. Пусть E(m,k) обозначает шифрование
сообщения m на ключе k, а v0 – стартовый вектор. Представим хэши-
руемое сообщение M в виде последовательности блоков m1, …, mt и
будем их использовать в качестве раундовых ключей. Тогда H(m) вы-
числяется следующим образом:
1 Парадокс дней рождения – известный пример из теории вероятности –
утверждение, что если дана группа из 23 или более человек, то вероятность
того, что хотя бы у двух из них дни рождения (число и месяц) совпадут,
превышает 1/2. Данное утверждение кажется противоречащим здравому
смыслу, так как вероятность одному родиться в определенный день года
довольно мала, а вероятность того, что двое родились в конкретный день –
еще меньше.
82
h0 = v0,
h i = E(h i-1,mi), i = 1t , (2.27)
H(m) = h t.
Однако в варианте с использованием в качестве E(m,k) алгорит-
ма DES, хэш-функция оказалась недостаточно стойкой из-за подвер-
женности атаке, основанной на «парадоксе дней рождения». И было
предложено улучшить эту схему, например, следующим образом:
h 0 = v0,
h i = E(h i-1,mi) h i-1, i=1t, (2.28)
H(m) = h t.
Существует и ряд специально разработанных алгоритмов хе-
ширования, один из которых – SHA-1.
2.5.2. Алгоритм SHA-1
Алгоритм SHA (Secure Hash Algorithm) разработан в США как
часть стандарта SHS (Secure Hash Standard), опубликованного в 1993
году. Но в нем были обнаружены уязвимости, которые привели к не-
обходимости модифицировать алгоритм. Через два года была опубли-
кована новая версия – SHA-1, получившая на сегодняшний день ши-
рокое распространение.
Получая на входе сообщение произвольной длины менее 264 бит,
SHA-1 формирует 160-битное выходное сообщение (дайджест). Вна-
чале преобразуемое сообщение M дополняется до длины, кратной 512
битам. Заполнитель формируется следующим образом: в конец пре-
образуемого сообщения добавляется 1, потом – столько нулей, сколь-
ко необходимо для получения сообщения, которое на 64 бита короче,
чем кратное 512, после чего добавляют 64-битное представление дли-
ны исходного сообщения. Например, если сообщение длиной 800 бит,
то 801-й бит =1, потом добавляем нули до 960 бит, после чего – в ос-
тавшихся 64-разрядах записывается число «800», в итоге хэшируем
1024-битное сообщение. Общая схема преобразования представлена
83
на рис. 2.18. Перед началом преобразований инициализируется пять
32-битных переменных:
A=0x67452301;
B=0xEFCDAB89;
C=0x98BADCFE;
D=0x10325476;
E=0xC3D2E1F0.
Эти значения присваиваются также переменным a0, b0, c0, d0, e0.
Преобразование производится над блоком сообщения размером 512
бит в 80 раундов. В процессе преобразования используются следую-
щие нелинейные функции ft:
ft(X,Y,Z)=(XY)((X)Z) для t=0…19;
ft(X,Y,Z)=XYZ для t=20…39 и t=60…79;
ft(X,Y,Z)=(XY)(XZ)(YZ) для t=40…59.
Рис. 2.18 Схема раунда алгоритма SHA-1
В процессе преобразования используются четыре константы:
Kt=0x5A827999 для t=0…19;
Kt=0x6ED9EBA1 для t=20…39;
Kt=0x8F1BBCDC для t=40…59;
Kt=0xCA62C1D6 для t=60…79.
et
dt
ct
bt
at
et+1
dt+1
ct+1
bt+1
at+1
ft
<<<30
<<<5
Wt Kt
+ + + +
84
Блок исходного сообщения M представляется в виде 16-ти
32-разрядных подблоков M0, …, M15, которые используются для фор-
мирования значений Wt:
Wt=Mt для t=0…15;
Wt=(Wt-3  Wt-8  Wt-14  Wt-16)<<<1 для t=16…79.
Обозначение «<<< X» – циклический сдвиг влево на X разрядов,
«+» – сложение по модулю 232.
После преобразования очередного 512-битного блока, получен-
ные значения a,b,c,d,e складываются со значениями A,B,C,D,E соот-
ветственно, и начинается обработка следующего блока (или получен-
ное значение в виде сцепления a,b,c,d,e подается на выход, если обра-
ботанный блок был последним).
Таким образом, на выходе получаем 160-битный дайджест ис-
ходного сообщения.
2.5.3. Хэш-функции с ключом
Хэш-функцией с ключом называется односторонняя функция
H(k,x) со следующими свойствами:
- аргумент x функции H(k,x) может быть строкой бит произволь-
ной длины;
- значение функции должно быть строкой бит фиксированной
длины;
- при любых данных k и x легко вычислить H(k,x);
- для любого x должно быть практически невозможно вычислить
H(k,x), не зная k;
- должно быть практически невозможно определить k, даже при
большом числе известных пар {x, H(k,x)} или вычислить по этой ин-
формации H(k,x’) для x’x.
Часто такие функции также называются кодами аутентифика-
ции сообщений (англ. «Message Authentication Code», сокр. MAC). В
отечественной литературе используется также термин имитозащит-
ная вставка (или просто имитовставка).
85
Хэш-функцию с ключом можно построить на базе криптографи-
ческой хэш-функции без ключа или алгоритма шифрования.
Пусть H(x) – хэш-функция без ключа. Можно внедрить ключ в
процесс хэширования, и получить хэш-функцию с ключом H(k,x).
Ниже представлены возможные варианты построения:
H(k,x) = H(k|x),
H(k,x) = H(x|k), (2.28)
H(k,x) = H(k1|x|k2), где k=k1|k2.
Символ | в (2.28) обозначает конкатенацию, объединение строк
аргументов.
Другой пример – построение хэш-функции с помощью шифра
DES. Входной текст m разбивается на блоки m1,,mt по 64 бита, ко-
торые преобразуются следующим образом (k – ключ шифрования):
c0=0,
ci=DESk(mici-1), i=1,,t,
H(k,m)= ct.
2.6. ИНФРАСТРУКТУРА ОТКРЫТЫХ КЛЮЧЕЙ. ЦИФРОВЫЕ
СЕРТИФИКАТЫ
Использование методов асимметричной криптографии сделало
возможным безопасный обмен криптографическими ключами между
отправителем и получателем, которые никогда друг друга не встре-
чали и, возможно, находятся за многие километры друг от друга.
Но возникает другая проблема – как убедиться в том, что
имеющийся у Вас открытый ключ другого абонента на самом деле
принадлежит ему. Иными словами, возникает проблема аутентифика-
ции ключа. Без этого, на криптографический протокол может быть
осуществлена атака типа «человек посередине» (англ. «man in the
middle»).
Идею данной атаки поясняет следующий пример. Абонент A
(Алиса) хочет послать абоненту B (Боб) зашифрованное сообщение и
86
берет его отрытый ключ из общедоступного справочника. Но, на са-
мом деле, ранее нарушитель E (Ева) подменил в справочнике откры-
тый ключ Боба своим открытым ключом. Теперь Ева может расшиф-
ровать те сообщения, которые Алиса формирует для Боба, ознако-
миться с их содержимым, возможно, зашифровать их на настоящем
ключе Боба и переслать ему (рис. 2.19).
Рис. 2.19. Атака типа «man in the middle»
Избежать подобной атаки можно, подтвердив подлинность ис-
пользуемого ключа. Но Алиса и Боб лично никогда не встречались, и
передать, например, дискету с ключом из рук в руки не могут. Поэто-
му, решение задачи подтверждения подлинности берет на себя третья
доверенная сторона – некий арбитр, которому доверяют оба абонента.
Заверяется ключ с помощью цифрового сертификата.
На самом деле, подобный способ применяется и вне компью-
терных систем. Когда для подтверждения подлинности человека ис-
пользуется паспорт, то в роли третьей доверенной стороны выступает
государство (от имени которого действовали в выдавшем паспорт от-
деле милиции).
Но вернемся к цифровым сертификатам. Для подтверждения
подлинности открытых ключей создается инфраструктура открытых
ключей (англ. «Public Key Infrastructure», сокр. PKI). PKI представляет
собой набор средств, мер и правил, предназначенных для управления
ключами, политикой безопасности и обменом защищенными сообще-
ниями. Структура PKI представлена на рис. 2.20.
Алиса посылает Бобу кон-
фиденциальное письмо, за-
шифровав его на подменен-
ном Евой ключе
Алиса Ева
Ознакомившись с содержимым
письма, Ева пересылает письмо
Бобу, зашифровав его на уже
подлинном ключе Боба
Боб
87
Для простоты последующего изложения, будем представлять
сеть в виде совокупности удостоверяющих центров (другое назва-
ние – центр сертификации, сокр. ЦС, от англ. «Certification Authority»,
сокр. – CA) и пользователей. Центр сертификации – абонент, которо-
му доверено право удостоверять своей подписью сертификаты, свя-
зывающие открытые ключи абонентов с их идентификационной ин-
формацией. Сами центры сертификации тоже получают сертификаты
своих ключей у центров более высокого уровня.
Рис. 2.20. Структура PKI
Таким образом, центры сертификации и пользователи форми-
руют древовидную иерархическую структуру (рис. 2.21). В вершине
этого дерева находится корневой центр сертификации, на рисунке –
CA_1. Его особенность заключается в том, что он использует само-
подписанный сертификат, т. е. сам заверяет свой ключ.
Рис. 2.21. Иерархия центров сертификации и клиентов
CA_1 = ROOT
CA_2 CA_3
CA_4
Cl_1
Cl_2
Cl_3 Cl_4
Центр Пользователь
регистрации
Каталог
сертификатов
Центр
сертификации
Агенты PKI
88
В приведенном примере, CA_1 заверяет электронной подписью
сертификаты подчиненных центров сертификации CA_2 и CA_3, а те,
в свою очередь, подписывают сертификаты пользователей и центров
более низкого уровня.
Перейдем к рассмотрению самих сертификатов. Наибольшее
распространение получили цифровые сертификаты, формат которых
определен стандартом X.509. На данный момент, принята третья вер-
сия стандарта. Формат сертификата изображен на рис. 2.22 [11].
Номер версии содержит числовое значение, соответствующее
номеру версии (для сертификата версии 1 равен 0 и т. д.). В первой
версии X.509 не было уникальных номеров («ID Изготовителя», «ID
Субъекта») и полей расширения. Во второй версии добавились ука-
занные идентификаторы, в третьей – расширения.
Серийный номер – уникальный номер, присваиваемый каждому
сертификату.
Алгоритм подписи – идентификатор алгоритма, используемого
при подписании сертификата. Должен совпадать с полем Алгоритм
ЭЦП.
Изготовитель - имя центра сертификации, выдавшего серти-
фикат. Записывается в формате Relative Distinguished Name - RDN
(варианты перевода названия – «относительное отдельное имя», «от-
носительное характерное имя»). Данный формат используется в
службах каталога, в частности, в протоколе LDAP. При записи Relative
Distinguished Name используются специальные ключевые слова:
CN (англ. «Common Name») – общее имя; OU (англ. «Organization
Unit») – организационная единица; DC (англ. «Domain Component») –
составная часть доменного имени.
Например, в сертификате Microsoft Windows Hardware Compatibility,
который находится в хранилище сертификатов Windows’XP
значение данного поля следующее:
CN = Microsoft Root Authority,
OU = Microsoft Corporation,
89
OU = Copyright (c) 1997 Microsoft Corp.
Как видно, указывается имя центра сертификации, компания, которой
он принадлежит и т. д.
Рис. 2.22. Сертификат формата X.509 v.3
Тело сертификата
Алгоритм ЭЦП
<Algorithm ID>
ЭЦП
<Bit String>
Номер версии
<integer>
Серийный номер
<integer>
Алгоритм подписи
<Algorithm ID>
Изготовитель
<Relative Distinguished
Name>
Субъект
<Relative Distinguished
Name>
Период действия Действителен с
<Time>
Действителен по
<Time>
Открытый ключ Алгоритм
< Algorithm ID>
Ключ
<Bit String>
ID Изготовителя
<Bit String>
ID Субъекта
<Bit String>
Расширение
Критичность
<Boolean>
Значение
<Octet String>
Идентификатор
<Object ID>
90
Субъект – имя владельца сертификата, представленное в том же
формате RDN. Для указанного в предыдущем примере сертификата
значения данного поля:
CN = Microsoft Windows Hardware Compatibility,
OU = Microsoft Corporation,
OU = Microsoft Windows Hardware Compatibility Intermediate CA,
OU = Copyright (c) 1997 Microsoft Corp.
Период действия – описывает временной интервал, в течение
которого центр сертификации гарантирует отслеживание статуса сер-
тификата (сообщит абонентам сети о факте досрочного отзыва серти-
фиката и т. д.). Период задается датами начала и окончания действия.
Открытый ключ – составное поле, содержащее идентификатор
алгоритма, для которого предназначается данный открытый ключ, и
собственно сам открытый ключ в виде набора битов.
ID Изготовителя и ID Субъекта содержат уникальные иденти-
фикаторы центра сертификации и пользователя (на случай совпаде-
ния имен различных CA или пользователей).
Расширения – дополнительный атрибут, связанный с субъектом,
изготовителем или открытым ключом, и предназначенный для управ-
ления процессами сертификации. Более подробно он описан ниже.
Алгоритм электронной цифровой подписи (ЭЦП) – идентифика-
тор алгоритма, используемый для подписи сертификата. Должен сов-
падать со значением поля Алгоритм подписи.
ЭЦП – само значение электронно-цифровой подписи для данно-
го сертификата.
Расширения могут определять следующие дополнительные па-
раметры:
- идентификатор пары открытый/секретный ключ центра серти-
фикации (изготовителя), если центр имеет несколько различных клю-
чей для подписи сертификатов;
- идентификатор конкретного ключа пользователя (субъекта),
если пользователь имеет несколько сертификатов;
91
- назначение ключа, например, ключ для шифрования данных,
проверки ЭЦП данных, для проверки ЭЦП сертификатов и т. д.;
- уточнение периода использования – можно сократить время
действия сертификата, указанное в поле Период действия (период, в
течение которого статус сертификата отслеживается, станет больше,
чем разрешенное время использования сертификата);
- политики использования сертификата;
- выбор соответствия политик использования сертификата для
центра сертификации и пользователя, если имеются различные вари-
анты;
- альтернативное имя пользователя и центра сертификации;
- указания, является ли пользователь сам центром сертификации
и насколько глубоко разрешается разворачивать сертификационный
путь.
Предположим, что ключевые пары сгенерированы, открытые
ключи заверены сертификатами и размещены в каталоге, реализован-
ном с помощью web-сервера, ftp-сервера, службы каталога или другой
технологии. Теперь, если абонент A желает проверить подпись або-
нента B под полученным сообщением (или зашифровать для B сооб-
щение с помощью его открытого ключа), он выполняет следующие
действия [8]:
1) запрашивает в сетевом справочнике сертификат CB открытого
ключа подписи (шифрования) абонента B;
2) проверяет достоверность сертификата CB (см. ниже);
3) в случае успеха проверяет подпись под сообщением (зашиф-
ровывает сообщение) с помощью открытого ключа, извлеченного из
CB.
Процедура проверки достоверности сертификата CB состоит в
следующем:
1) проверяется срок действия сертификата CB, если он закончил-
ся, сертификат считается недостоверным;
92
2) из CB извлекается имя ЦС, подписавшего этот сертификат,
обозначим его D;
3) если D=B, то сертификат самоподписанный, он считается
достоверным только, если D=ROOT (хотя, возможно, в некоторых се-
тях право выдавать самоподписанные сертификаты имеет не один
ROOT, это – политика сети);
4) если же DB, то из справочника запрашивается сертификат
CD открытого ключа подписи абонента D, проверяется на достовер-
ность сертификат CD;
5) в случае отрицательного ответа принимается решение о не-
достоверности сертификата CB, иначе из CD извлекается открытый
ключ KD;
6) с помощью KD проверяется подпись под сертификатом CB, по
результатам проверки этой подписи судят о достоверности CB.
Если ключи шифрования досрочно вышли из обращения (при-
чины могут быть различны – пользователь увольняется из компании,
секретный ключ скомпрометирован и т. д.), центр сертификации из-
вещает об этом остальных пользователей сети путем выпуска списка
отозванных сертификатов (англ. «Certificate Revocation List», сокр.
CRL). Структура CRL представлена на рис. 2.23. Поля списка содер-
жат следующую информацию.
Номер версии определяет номер версии формата CRL. Текущая
используемая версия – вторая.
Алгоритм подписи – идентификатор алгоритма, с помощью ко-
торого подписан CRL. Должен совпадать по значению с полем Алго-
ритм ЭЦП.
Изготовитель – имя центра сертификации в формате RDN.
Выпущен – дата выпуска CRL.
Следующий – дата, до которой будет выпущен следующий CRL.
Расширения – описывают центр сертификации, точку для поиска
CRL данного центра, номер данного списка и т. д.
93
Рис. 2.23. Структура списка отозванных сертификатов
Отозванный сертификат – таких полей будет столько, сколько
сертификатов отзывается – содержит номер отзываемого сертифика-
та, дату, с которой сертификат отозван, описание причины отзыва.
Алгоритм ЭЦП – идентификатор алгоритма ЭЦП, используемо-
го для подписи списка.
ЭЦП – сама электронная цифровая подпись.
Проблемы с CRL заключаются в том, что может возникнуть си-
туация, когда ключ уже отозван, но CRL еще не выпущен, т. е. поль-
зователи не могут получить информацию о компрометации ключа.
Кроме того, распространение CRL идет по запросу клиента и наруши-
тель может препятствовать их получению.
Другая проблема PKI – самоподписанные сертификаты. Серти-
фикат корневого ЦС должен раздаваться всем абонентам сети в нача-
ле работы и сохраняться в защищенном от подделки хранилище. Ина-
Отозванный сертификат
Сер. номер
<integer>
Дата отзыва
<Time>
Расширения
Тело списка
Версия
<integer>
Подпись
<Algorithm ID>
Изготовитель
<RDN>
Выпущен
<Time>
Следующий
<Time>
Расширения
Алгоритм ЭЦП
<Algorithm ID>
ЭЦП
<Bit string>
94
че нарушитель может попробовать навязать свой сертификат в каче-
стве сертификата корневого центра.
Мы рассмотрели случай реализации иерархической модели PKI,
при которой центры сертификации организованы в древовидную
структуру с корневым центром сертификации на верху иерархии. На
практике также встречаются другие варианты организации:
- одиночный центр сертификации, который выдает себе само-
подписанный сертификат – данная модель часто реализуется в не-
больших организациях, но она имеет отмеченный выше недостаток,
связанный с самоподписанными сертификатами;
- одноранговая модель, при которой независимые центры серти-
фикации взаимно сертифицируют друг друга.
Надо отметить, что сфера применения цифровых сертификатов
сейчас достаточно широка. В частности, они используются для рас-
пределения открытых ключей в протоколах защиты электронной поч-
ты S/MIME или PGP, с помощью цифровых сертификатов проверяет-
ся подлинность участников соединения по протоколу SSL и т. д.
95
3. ЗАЩИТА ИНФОРМАЦИИ В IP-СЕТЯХ
На сегодняшний день стек сетевых протоколов TCP/IP является
наиболее широко используемым как в глобальных, так и в локальных
компьютерных сетях. Именно поэтому методы и средства защиты пе-
редаваемых данных в IP-сетях представляют особый интерес.
В этой главе будут рассмотрены криптографические протоколы,
позволяющие защищать электронную почту, передаваемые данные на
транспортном и сетевом уровне. Кроме того, учитывая большую роль
межсетевых экранов в решении задач обеспечения сетевой безопасно-
сти, в последнем разделе будет рассмотрен этот класс средств защи-
ты.
3.1. ПРОТОКОЛ ЗАЩИТЫ ЭЛЕКТРОННОЙ ПОЧТЫ S/MIME
Протокол Secure Multipurpose Internet Mail Extensions (S/MIME)
предназначен для защиты данных, передаваемых в формате MIME, в
основном – электронной почты. Он был предложен в 1995 году ком-
панией RSA Data Security Inc. Дальнейшие работы над протоколом
велись рабочей группой организации Internet Engineering Task Force
(IETF), разрабатывающей стандарты сети Интернет. На данный мо-
мент, последней является версия 3.1 этого протокола, описываемая в
документах RFC 3850, 3851, 3852. Протокол S/MIME предоставляет
следующие криптографические услуги безопасности (криптографиче-
ские сервисы):
- проверка целостности сообщения;
- установление подлинности отправителя (аутентификация);
- обеспечение секретности передаваемых данных (шифрование).
Нужно отметить, что сам по себе формат MIME описывает по-
рядок форматирования писем, содержащих различные типы данных
(обычный текст, текст в формате html, видео и графические файлы
96
различный типов и т. д.). При использовании S/MIME добавляются
новые типы (например, application/pkcs7-mime и application/pkcs7-
signature). Это позволяет указать на то, что данные в этом разделе яв-
ляются зашифрованными, подписанными и т. д. Протокол позволяет
обычным почтовым клиентам защищать исходящую почту и интер-
претировать криптографические сервисы, добавленные во входящую
почту (расшифровывать сообщения, проверять их целостность и т. д.).
Стандарт определяет использование симметричных криптоалго-
ритмов для шифрования содержимого почтовых сообщений и алго-
ритма с открытым ключом для защиты передаваемого вместе с пись-
мом ключа симметричного шифрования.
Протокол S/MIME позволяет использовать различные криптоал-
горитмы, причем их список может расширяться. Изначально, из сим-
метричных шифров могли использоваться RC2, DES или TripleDES.
Для формирования дайджестов – алгоритмы MD5 и SHA1, причем
версия 3 стандарта рекомендует использовать именно последний ал-
горитм (из-за того, что он формирует более длинный дайджест и счи-
тается более надежным). Защита симметричного ключа шифрования и
ЭЦП в версии 2 осуществляется с помощью алгоритма RSA с ключом
от 512 до 1024 бит. Версия 3 добавляет возможность использовать
другие алгоритмы, например алгоритм Диффи-Хеллмана с ключом
длиной до 2048 бит. Распределение и аутентификация открытых клю-
чей производится с помощью цифровых сертификатов формата X.509.
Таким образом, чтобы защищать переписку с помощью этого прото-
кола, оба абонента должны сгенерировать ключевые пары и удосто-
верить открытые ключи с помощью сертификатов. На рис. 3.1 приве-
ден фрагмент письма, содержащий открытый текст «This is a clearsigned
message.» и подпись к нему.
S/MIME поддерживается многими почтовыми клиентами: Microsoft
Outlook, Mozilla, The Bat! и т. д. Более широкое применение
протокола сдерживается необходимостью наличия сертификатов у
абонентов и плохой совместимостью с системами Web-почты.
97
Рис. 3.1. Фрагмент электронного письма с подписью
Альтернативой S/MIME является PGP (англ. «Pretty Good Privacy
») – компьютерная программа созданная Филиппом Циммерманном
(Philip Zimmermann) в 1991 году. Данная программа положила основу
работе над стандартом OpenPGP, последняя версия которого описана
в RFC 4880. По функциональности S/MIME и PGP во многом сходны.
3.2. ПРОТОКОЛЫ SSL И TLS
Протокол Secure Sockets Layer (SSL) был разработан корпораци-
ей Netscape Communications для обеспечения аутентификации, цело-
стности и секретности трафика на сеансовом уровне модели OSI (с
точки зрения четырехуровневой модели стека протоколов TCP/IP – на
прикладном уровне). В январе 1999 года на смену SSL v3.0 пришел
протокол TLS v1.0 (Transport Layer Security) последняя версия TLS
v.1.2 описывается в RFC 5246. С точки зрения выполняемых дейст-
вий, различия между этими протоколами SSL и TLS весьма невелики,
в то же время, они несовместимы друг с другом [11].
98
SSL обеспечивает защищенное соединение, которое могут ис-
пользовать протоколы более высокого уровня – HTTP, FTP, SMTP и
т. д. Наиболее широко он используется для защиты данных переда-
ваемых по HTTP (режим HTTPS). Для этого должны использоваться
SSL-совместимые web-сервер и браузер.
Протокол предусматривает два этапа взаимодействия клиента и
сервера:
1) установление SSL-сессии (процедура «рукопожатия», от англ.
«handshake») на этом этапе может производиться аутентификация
сторон соединения, распределение ключей сессии, определяются на-
страиваемые параметры соединения;
2) защищенное взаимодействие.
Протоколом SSL используются следующие криптоалгоритмы:
- асимметричные алгоритмы RSA и Диффи-Хеллмана;
- алгоритмы вычисления хэш-функций MD5 и SHA1;
- алгоритмы симметричного шифрования RC2,RC4, DES, TripleDES,
IDEA.
В протоколе SSL v 3.0 и TLS перечень поддерживаемых алго-
ритмов является расширяемым. Для подтверждения подлинности от-
крытых ключей используются цифровые сертификаты формата X.509.
Протокол SSL позволяет проводить следующие варианты аутен-
тификации сторон взаимодействия:
- аутентификация сервера без аутентификации клиента (одно-
сторонняя аутентификация) – это наиболее часто используемый ре-
жим, позволяющий установить подлинность сервера, но не проводя-
щий проверки клиента (ведь подобная проверка требует и от клиента
наличия сертификата);
- взаимная аутентификация сторон (проверяется подлинность
как клиента, так и сервера);
- отказ от аутентификации – полная анонимность; в данном слу-
чае SSL обеспечивает шифрование канала и проверку целостности, но
99
не может защитить от атаки путем подмены участников взаимодейст-
вия.
Рассмотрим более подробно процедуру рукопожатия в режиме
аутентификации сервера без аутентификации клиента. Она включает
следующие шаги [13].
1. Клиент посылает серверу запрос на установление защищенно-
го соединения, в котором передает, в частности, следующие парамет-
ры:
- дату и текущее время;
- сгенерированную клиентом случайную последовательность
(RAND_CL);
- перечень поддерживаемых клиентом алгоритмов шифрования,
хеширования и сжатия (если сжатие используется).
2. Сервер обрабатывает запрос от клиента и передает ему согла-
сованный набор параметров:
- идентификатор SSL-сессии;
- идентификаторы криптографических алгоритмов, из числа
предложенных клиентом, которые будут использоваться в данной
сессии (если по какой-либо причине предложенные алгоритмы или их
параметры не удовлетворяют требованиям сервера, сессия закрывает-
ся);
- цифровой сертификат сервера формата X.509;
- случайную последовательность (RAND_SERV).
3. Клиент проверяет полученный сертификат и соответствие ро-
ли ключа его назначению, описанному в сертификате. При отрица-
тельном результате проверки сессия закрывается, а при положитель-
ном – клиент выполняет следующие действия:
- генерирует случайную 48-байтную последовательность, назы-
ваемую Pre_MasterSecret, предназначенную для расчета общего сек-
ретного ключа;
100
- шифрует значение Pre_MasterSecret с использованием откры-
того ключа сервера, взятого из сертификата, и посылает криптограм-
му серверу;
- с помощью согласованной с сервером хэш-функции формирует
общий секретный ключ (MasterSecret), используя в качестве парамет-
ров последовательность Pre_MasterSecret, посланную ранее серверу
случайную последовательность RAND_CL и полученную от него слу-
чайную последовательность RAND_SERV;
- используя значение MasterSecret, вычисляет криптографиче-
ские параметры SSL-сессии: формирует общие с сервером сеансовые
секретные ключи для симметричного шифрования и вычисления хэш-
функций;
- переходит в режим защищенного взаимодействия.
4. Сервер, используя свой секретный ключ, расшифровывает по-
лученное значение Pre_MasterSecret и выполняет те же операции, что
и клиент:
- с помощью согласованной с клиентом хэш-функции формиру-
ет общий секретный мастер-ключ (MasterSecret), используя в качестве
параметров значение Pre_MasterSecret, а также посланную клиенту
случайную последовательность RAND_SERV и полученную от него
случайную последовательность RAND_CL;
- используя значение MasterSecret, вычисляет криптографиче-
ские параметры SSL-сессии: формирует общие с клиентом сеансовые
секретные ключи для симметричного шифрования и вычисления хэш-
функций;
- переходит в режим защищенного взаимодействия.
Так как при формировании параметров SSL-сессии и клиент, и
сервер пользовались одними и теми же исходными данными (согла-
сованными алгоритмами, общей секретной последовательностью
Pre_MasterSecret и случайными последовательностями RAND_CL и
RAND_SERV), то очевидно, что в результате описанных выше дейст-
вий они выработали одинаковые сеансовые секретные ключи. Для
101
проверки идентичности параметров SSL-сессии клиент и сервер по-
сылают друг другу тестовые сообщения, содержание которых извест-
но каждой из сторон:
- клиент формирует сообщение из собственных посылок в адрес
сервера на шаге 1 и посылок, полученных от сервера на шаге 2, внося
элемент случайности в виде последовательности MasterSecret, уни-
кальной для данной сессии; формирует код для проверки целостности
сообщения (MAC), шифрует сообщение на общем сеансовом секрет-
ном ключе и отправляет серверу;
- сервер, в свою очередь, формирует сообщение из собственных
посылок в адрес клиента на шаге 2, посылок, полученных от клиента
на шаге 1, и последовательности MasterSecret; формирует код для
проверки целостности сообщения (MAC), шифрует сообщение на об-
щем сеансовом секретном ключе и отправляет клиенту;
- в случае успешной расшифровки и проверки каждой из сторон
целостности полученных тестовых сообщений, SSL-сессия считается
установленной, и стороны переходят в штатный режим защищенного
взаимодействия.
Необязательная вторая фаза рукопожатия позволяет аутентифи-
цировать клиента. Она заключается в том, что сервер шлет запрос
клиенту, клиент аутентифицирует себя, возвращая подписанное со-
общение (запрос сервера) и свой цифровой сертификат.
В процессе защищенного взаимодействия с установленными
криптографическими параметрами SSL-сессии выполняются сле-
дующие действия:
- каждая сторона при передаче сообщения формирует имитов-
ставку (MAC) для последующей проверки целостности сообщения и
затем зашифровывает исходное сообщение вместе с MAC по сеансо-
вому секретному ключу;
- каждая сторона при приеме сообщения расшифровывает его и
проверяет на целостность (вычисляется текущее значение МАС и
сверяется со значением, полученным вместе с сообщением); в случае
102
обнаружения нарушения целостности сообщения, SSL-сессия закры-
вается.
Протоколы SSL и TLS получили широкое распространение,
прежде всего благодаря их использованию для защиты трафика, пере-
даваемого по протоколу HTTP в сети Интернет. В тоже время, пре-
доставляемые SSL услуги не являются прозрачными для приложений,
т. е. сетевые приложения, которые хотят воспользоваться возможно-
стями SSL должны включать в себя реализацию протокола (или под-
ключать ее в виде каких-то внешних модулей).
3.3. ПРОТОКОЛЫ IPSEC И РАСПРЕДЕЛЕНИЕ КЛЮЧЕЙ
Протокол IPSec или, если точнее, набор протоколов, разработан
организацией IETF как базовый протокол обеспечения безопасности
на уровне IP-соединения. Он является дополнением к использующе-
муся сейчас протоколу IP ver.4 и составной частью IP ver.6. Возмож-
ности, предоставляемые протоколами IPSec:
- контроль доступа;
- контроль целостности данных;
- аутентификация данных;
- защита от повторений;
- обеспечение конфиденциальности.
Основная задача IPSec – создание между двумя компьютерами,
связанными через общедоступную (небезопасную) IP-сеть, безопас-
ного туннеля (рис. 3.2), по которому передаются конфиденциальные
или чувствительные к несанкционированному изменению данные.
Подобный туннель создается с использованием криптографических
методов защиты информации. Протокол работает на сетевом уровне
модели OSI и, соответственно, он «прозрачен» для приложений.
Иными словами, на работу приложений (таких как web-сервер, брау-
зер, СУБД и т. д.) не влияет, используется ли защита передаваемых
данных с помощью IPSec или нет.
103
Рис. 3.2. Туннель безопасности
Архитектура IPSec является открытой, что позволяет использо-
вать для защиты передаваемых данных новые криптографические ал-
горитмы, например, соответствующие национальным стандартам. Для
этого необходимо, чтобы взаимодействующие стороны поддерживали
эти алгоритмы, и они были бы стандартным образом зарегистрирова-
ны в описании параметров соединения.
Процесс защищенной передачи данных регулируется правилами
безопасности, принятыми в системе. Параметры создаваемого тунне-
ля описывает информационная структура, называемая контекст защи-
ты или ассоциация безопасности (от англ. «Security Association», сокр.
SA). Как уже отмечалось выше, IPSec является набором протоколов, и
состав контекста защиты может различаться. В зависимости от кон-
кретного протокола в него входит:
- IP-адрес получателя;
- указание на протоколы безопасности, используемые при пере-
даче данных;
- ключи, необходимые для шифрования и формирования ими-
товставки (если это требуется);
- указание на метод форматирования, определяющий, каким об-
разом создаются заголовки;
Хост
A
Хост
B
Защищенные
данные
104
- индекс параметров защиты (от англ. «Security Parameter Index»,
сокр. SPI) – идентификатор, позволяющий найти нужный SA.
Обычно, контекст защиты является однонаправленным, а для
передачи данных по туннелю в обе стороны задействуются два SA.
Каждый хост имеет свою базу контекстов защиты, из которой выби-
рается нужный элемент либо на основании значения SPI, либо по IP-
адресу получателя.
Два протокола, входящие в состав IPSec это:
1) протокол аутентифицирующего заголовка – AH (от англ. «Authentication
Header»), обеспечивающий проверку целостности и аутен-
тификацию передаваемых данных; последняя версия протокола опи-
сана в документе RFC 4302 (предыдущие – RFC 1826, 2402);
2) протокол инкапсулирующей защиты данных – ESP (от англ.
«Encapsulating Security Payload»), обеспечивающий конфиденциаль-
ность и, опционально, проверку целостности и аутентификацию; опи-
сан в RFC 4303 (предыдущие версии – RFC 1827, 2406).
Оба эти протокола имеют два режима работы – транспортный и
туннельный, последний определен в качестве основного. Туннельный
режим используется, если хотя бы один из соединяющихся узлов яв-
ляется шлюзом безопасности. В этом случае создается новый IP-
заголовок, а исходный IP-пакет полностью инкапсулируется в новый.
Транспортный режим ориентирован на соединение хост-хост.
При использовании ESP в транспортном режиме защищаются только
данные IP-пакета, заголовок не затрагивается. При использовании AH
защита распространяется на данные и часть полей заголовка. Более
подробно режимы работы описаны ниже.
3.3.1. Протокол AH
В IP ver.4 аутентифицирующий заголовок располагается после
IP-заголовка. Представим исходный IP-пакет как совокупность IP-
заголовка, заголовка протокола следующего уровня (как правило, это
105
TCP или UDP, на рис. 3.3 он обозначен как ULP – от англ. «Upper-
Level Protocol») и данных.
Рис. 3.3. а) исходный IP-пакет
б) IP-пакет при использовании AH в транспортном режиме
в) IP-пакет при использовании AH в туннельном режиме
На рисунке 3.3. представлен исходный пакет и варианты его из-
менения при использовании протокола AH в разных режимах. В
транспортном режиме заголовок исходного IP-пакета остается на сво-
ем месте, но в нем модифицируются некоторые поля. Например, ме-
няется поле Next Header, указывающее на то, заголовок какого прото-
кола следует за IP-заголовком. В туннельном режиме создается новый
IP-заголовок, после которого идет заголовок AH, а за ним – полно-
стью исходный IP-пакет.
Аутентификация производится путем создания имитовставки
(MAC) для чего используется хэш-функция и секретный ключ. Во
всех реализациях AH обязательно должно поддерживаться использо-
вание алгоритмов HMAC-MD5-96 (используется по умолчанию) и
HMAC-SHA-1-96, представляющих собой хэш-функции с ключом,
основанные на хэш-функциях MD5 и SHA-1, соответственно. Но мо-
гут использоваться и другие, «факультативные» алгоритмы хэширо-
вания. Полученное значение, называемое в описании протокола ICV
(от англ. «Integrity Check Value» – значение контроля целостности)
помещается в поле Authentication Data (рис. 3.4). Это поле перемен-
а)
б)
в)
IP header
IP header
New IP header
ULP Data
AH ULP
AH IP header ULP
Data
Data
106
ной длины, так как разные алгоритмы хеширования формируют раз-
ные по длине дайджесты.
При использовании AH в транспортном режиме, ICV рассчиты-
вается для ULP, данных и неизменяемых полей IP-заголовка. Изме-
няемые поля, такие как поле TTL, указывающее на время жизни паке-
та и изменяемое при прохождении маршрутизаторов, при расчете
значения хэш-функции принимаются равными 0. В туннельном ре-
жиме аутентифицируется весь исходный IP-пакет и неизменяемые
поля нового заголовка. Рассмотрим формат заголовка AH (рис. 3.4).
Первые 8 бит заголовка (поле Next Header) содержат номер, со-
ответствующий протоколу следующего уровня. Номер для каждого
протокола назначает организация IANA (Internet Assigned Numbers
Authority). Например, номер TCP – 6, ESP – 50, AH – 51 и т. д.
Поле Payload Len указывает длину заголовка AH в 32-битных
словах. Далее 16 бит зарезервировано.
Рис. 3.4. Структура заголовка протокола AH
Поле SPI содержит значение индекса параметров защиты, по ко-
торому получатель сможет найти нужный контекст защиты (SA).
Поле Sequence Number было введено в RFC 2402. Значение
счетчика, содержащееся в этом поле, может использоваться для защи-
ты от атак путем повторных посылок перехваченных пакетов. Если
функция защиты от повторов активирована (а это указывается в SA),
отправитель последовательно наращивает значение поля для каждого
пакета, передаваемого в рамках данной ассоциации (соединения, ис-
пользующего единый SA).
Поле Authentication Data, как уже указывалось ранее, хранит
значение ICV.
Next Header Payload Len Зарезервировано
Security Parameters Index (SPI)
0 8 16 31
Sequence Number (SN)
Authentication Data (переменная длина)
107
3.3.2. Протокол ESP
Если AH обеспечивает защиту от угроз целостности передавае-
мых данных, то ESP также может обеспечивать и конфиденциаль-
ность.
Так же как и AH, ESP может работать в транспортном и тун-
нельном режимах. На рис. 3.5 изображены варианты его использова-
ния (штриховкой выделены фрагменты пакета, которые защищаются
с помощью шифрования). Для ESP определен следующий перечень
обязательных алгоритмов, которые должны поддерживаться во всех
реализациях:
- для формирования имитовставки HMAC-MD5-96 (использует-
ся по умолчанию) и HMAC-SHA-1-96;
- для шифрования – DES (в режиме CBC; используется по умол-
чанию) и NULL (отсутствие шифрования).
Кроме того, зарегистрированы и могут быть реализованы еще
ряд алгоритмов шифрования – Triple DES, CAST-128, RC5, IDEA,
Blowfish, ARCFour (общедоступная версия RC4) [13].
Рис. 3.5. а) исходный IP-пакет,
б) ESP в транспортном режиме,
в) ESP в туннельном режиме
Рассмотрим формат заголовка ESP (рис. 3.6). Он начинается с
двух 32-разрядных значений – SPI и SN. Роль их такая же, как в про-
токоле AH – SPI идентифицирует контекст защиты, использующийся
для создания данного туннеля; SN – позволяет защититься от повто-
ров пакетов. SN и SPI не шифруются. Следующим идет поле, содер-
жащее зашифрованные данные. После них - поле заполнителя, кото-
а) IP header
new IP header
IP header
ULP Data
ESP ULP Data ESP trailer ESP auth
ESP IP header ULP Data ESP trailer ESP auth
б)
в)
108
рый нужен для того, чтобы выровнять длину шифруемых полей до
значения кратного размеру блока алгоритма шифрования.
После заполнителя идут поля, содержащие значение длины за-
полнителя и указание на протокол более высокого уровня. Четыре пе-
речисленных поля (данные, заполнитель, длина, следующий прото-
кол) защищаются шифрованием.
Рис. 3.6. Структура заголовка ESP
Если ESP используется и для аутентификации данных, то за-
вершает пакет поле переменной длины, содержащее ICV. В отличие
от AH, в ESP при расчете значения имитовставки, поля IP-заголовка
(нового – для туннельного режима, модифицированного старого – для
транспортного) не учитываются.
При совместном использовании протоколов AH и ESP, после
IP-заголовка идет AH, после него – ESP. В этом случае, ESP решает
задачи обеспечения конфиденциальности, AH – обеспечения целост-
ности и аутентификации источника соединения.
Рассмотрим ряд дополнительных вопросов, связанных с исполь-
зованием IPSec. Начнем с того, откуда берется информация о пара-
метрах соединения – контекстах защиты или SA. Создание базы SA
может производиться различными путями. В частности, она может
создаваться администратором безопасности вручную, или формиро-
Security Parameters Index (SPI)
0 8 16 31
Sequence Number (SN)
Зашифрованные данные (переменная длина)
Заполнитель (0-255 байт)
Next Header
Authentication Data (переменная длина)
Длина заполн.
109
ваться с использованием специальных протоколов – SKIP, ISAKMP
(Internet Security Association and Key Management Protocol) и IKE (Internet
Key Exchange).
3.3.3. Протокол SKIP
Протокол SKIP (Simple Key management for Internet Protocol)
был разработан корпорацией SUN Microsystems в 1994 году. Он соз-
давался как IP-совместимый протокол, обеспечивающий управление
ключами и криптозащиту передаваемых данных на сетевом уровне
модели OSI [13]. По нумерации IANA этому протоколу присвоен но-
мер 57.
Первоначально SKIP выглядел следующим образом. Устанавли-
вающие защищенное взаимодействие абоненты должны иметь аутен-
тифицированные открытые ключи. По алгоритму Диффи-Хеллмана
они вычисляют общий секретный ключ Kij. Он используется для за-
щиты ключевой информации.
Отправитель генерирует временный ключ Kp, используемый для
шифрования данных одного пакета или небольшой их группы. На нем
зашифровывается исходный IP-пакет и инкапсулируется в SKIP-пакет
(рис. 3.7). Шифрование данных на временном ключе, а не на общем
секретном ключе Kij, повышает надежность, так как в этом случае на-
рушителю труднее набрать нужный для реализации атаки на Kij объем
шифрованных данных.
Рис. 3.7. Пакет до а) и после б) применения протокола SKIP.
IP-заголовок Данные
Кp зашифр. на Kij; имитовст. Исходный пакет, зашифр. на Kp
SKIP-заголовок
Новый IP- заголовок
а)
б)
110
Ключ Kp зашифровывается на ключе Kij и криптограмма поме-
щается в SKIP-заголовок, там же резервируется место под имитов-
ставку.
Формируется новый IP-заголовок и с помощью хэш-функции с
ключом для всего пакета рассчитывается значение имитовставки, ко-
торое помещается в SKIP-заголовок.
Впоследствии, протокол SKIP был усовершенствован. В частно-
сти, были внесены изменения, позволяющие использовать SKIP со-
вместно с ESP. Тогда SKIP отвечает за передачу ключевой информа-
ции и описание параметров соединения, а ESP решает задачи крипто-
графической защиты данных. Рассмотрим теперь эту версию [14].
Итак, стороны распределили общий секретный ключ Kij и от-
правитель сгенерировал временный ключ Kp. На его основе с помо-
щью хэш-функции H будут выработаны ключ для шифрования пакета
E_Kp и ключ для аутентификации A_Kp. В отличие от первоначально-
го варианта, при передаче ключ Kp шифруется не на Kij, а на модифи-
цированном при помощи счетчика n и хеш-фукнции ключе Kijn. Рас-
чет производится в соответствии с формулой 3.1.
E_Kp=H(Kp|Crypt Alg|02h)|H(Kp|Crypt Alg|00h),
A_Kp= H(Kp|MAC Alg|03h)|H(Kp|MAC Alg|01h), (3.1)
Kijn= H(K’ij|n|01h)|H(K’ij|n|00h),
где K’ij – младшие 256 бит Kij, Crypt Alg и MAC Alg – значения соот-
ветствующих полей заголовка SKIP (рис. 3.8).
Рис. 3.8. Формат заголовка SKIP
Source N Ver Rsvd SID Dest NSID Next Header
Counter n
Kij Alg Crypt Alg MAC Alg Comp Alg
Kp зашифрованный на Kijn (перем.длина)
Source MKID (если Source NSID<>0)
Dest MKID (если Dest NSID<>0)
0 8 16 31
111
Рассмотрим поля заголовка (рис. 3.8). Ver – номер версии прото-
кола. Следующие за ним 4 бита зарезервированы (Rsvd). Далее –
идентификаторы пространств имен источника и получателя Source NSID
и Dest NSID. Если они равны 0, то в полях Source MKID и Dest MKID
ставятся IP-адреса источника и получателя соответственно. После
поля Dest NSID идет поле Next Header, содержащее номер протокола,
следующего за SKIP. Далее идет 32-разрядное поле счетчика Counter
n. Как отмечается в описаниях, правила для работы со счетчиком n
отнесены на усмотрение разработчика, но для обеспечения совмести-
мости версий предлагается считать, что n – время в часах, отсчитан-
ное от 00:00 01.01.95. Как правило, если значение счетчика n при-
шедшего пакета отличается более чем на 1 от текущего, то пакет от-
брасывается.
Далее в заголовке идут байтовые идентификаторы алгоритмов:
шифрования ключа Kp – Kij Alg, шифрования данных в пакете –
Crypt Alg, аутентификации данных – MAC Alg, сжатия (если исполь-
зуется) – Comp Alg. После идентификаторов в SKIP-заголовок поме-
щается ключ Kp, зашифрованный на ключе Kijn (размер этого поля за-
висит от используемых алгоритмов шифрования ключа и данных).
Далее идут идентификаторы отправителя и получателя в выбранном
пространстве имен – Source MKID и Dest MKID. Наличие нескольких
идентификаторов позволяет более гибко настраивать использование
протоколов безопасности. Например, если на одном компьютере ра-
ботают различные приложения, можно описать политику, указываю-
щую какие алгоритмы и ключи использовать для защиты данных ка-
ждого из них.
В случае совместного использования протоколов SKIP и ESP,
заголовок SKIP размещается после IP-заголовка перед заголовком
ESP (рис. 3.9).
Рис. 3.9. Совместное использование SKIP и ESP
IP-заголовок SKIP-заголовок ESP
112
В этом случае, протокол ESP использует параметры соединения,
определяемые протоколом SKIP, а указывает на это значение SPI в за-
головке ESP: SKIP_SPI=1.
3.3.4. Протоколы ISAKMP и IKE
Протокол ISAKMP (Internet Security Association Key Management
Protocol – протокол управления ключами и контекстами безопасности
в Internet) был разработан IETF для решения задач согласования па-
раметров и управления ключами при формировании защищенного ка-
нала. ISAKMP описывает общую схему взаимодействия, но не содер-
жит конкретных криптоалгоритмов распределения ключей. Поэтому
он используется совместно с протоколом OAKLEY, основанном на
алгоритме Диффи-Хеллмана [13]. Протокол IKE (англ. «Internet Key
Exchange» – обмен ключами в Internet) определяет совместное ис-
пользование протоколов ISAKMP с OAKLEY и SKEMI (англ. «Secure
Key Exchange Mechanism for Internet» – безопасный механизм обмена
ключами в Интернет) для решения данной задачи. Сравнивая прото-
колы SKIP и IKE, надо отметить, что последний более сложен в реа-
лизации, но считается более надежным и гибким.
Протокол ISAKMP определяет две фазы согласования парамет-
ров взаимодействия:
- согласование глобальных параметров защищенного канала (в
терминах IPSec такие параметры называются управляющим контек-
стом);
- согласование параметров каждого защищенного соединения
(они образуют контекст защиты – SA).
С точки зрения модели стека TCP/IP, протокол ISAKMP являет-
ся протоколом прикладного уровня. В случае его использования со-
вместно с IPSec, спецификация устанавливает использование в каче-
стве протокола нижнего уровня UDP с номером порта 500.
113
Протокол ISAKMP определяет следующую последовательность
действий по формированию управляющего контекста (стороны взаи-
модействия, например, это могут быть два шлюза безопасности, на-
зываются «Инициатор» и «Партнер»):
1) «Инициатор»  «Партнер»: заявка на контекст, включаю-
щая предлагаемые алгоритмы и их параметры;
2) «Партнер»  «Инициатор»: принимаемые алгоритмы и па-
раметры (из списка, полученного на шаге 1; для каждой функции за-
щиты – генерация и распределение ключей, шифрование, аутентифи-
кация – используется один алгоритм и его параметры);
3) «Инициатор»  «Партнер»: ключевой материал и одноразо-
вый номер инициатора;
4) «Партнер»  «Инициатор»: ключевой материал и одноразо-
вый номер партнера;
5) «Инициатор»  «Партнер»: подписанное инициатором за-
шифрованное сообщение, содержащее его идентификатор;
6) «Партнер»  «Инициатор»: подписанное партнером зашиф-
рованное сообщение, содержащее его идентификатор.
Если используется протокол OAKLEY, на шаге 3 и 4 стороны
отправляют друг другу свои открытые ключи вместе со случайными
числами, служащими для защиты от повтора. Для обеспечения кон-
троля подлинности открытых ключей могут быть использованы сер-
тификаты X.509. В соответствии со схемой Диффи-Хеллмана, рассчи-
тывается общий секретный ключ. На его основе вырабатываются зна-
чения:
SKEYID_d – ключевой материал, используемый для генерации
временных ключей для защищенных соединений;
SKEYID_a – сеансовые ключи, используемые для аутентифика-
ции сторон и согласовываемых параметров;
SKEYID_e – сеансовые ключи, используемые для шифрования
согласовываемых параметров.
114
Пятый и шестой шаги служат для обмена идентификационной
информацией, защищенной и заверенной на ключах SKEYID_e и
SKEYID_a.
Такой порядок взаимодействия реализуется при использовании
основного или базового режима (англ. «Main Mode»). Он более мед-
ленный, но и более безопасный. Существует также «агрессивный»
режим (англ. «Aggressive Mode») при котором, для увеличения скоро-
сти взаимодействия ряд параметров передается в открытом виде и
уменьшено число шагов взаимодействия (с 6 до 3 за счет того, что на
первом и втором шаге сразу передается больше параметров) [11].
Сообщение ISAKMP состоит из заголовка и следующих за ним
полей данных. Формат заголовка приведен на рис. 3.10.
Рис. 3.10. Заголовок ISAKMP
Исходя из значения текущего времени, стороны формируют
идентификаторы (cookie), которые включают в заголовок пакета (на
шаге 1 присутствует только идентификатор стороны-инициатора со-
единения, на последующих – идентификаторы обеих сторон). При-
сутствие этих идентификаторов позволяет защититься от атак путем
повторных посылок перехваченных сообщений.
Поле «Следующие данные» содержит идентификатор, указы-
вающий на тип содержимого области данных. Например, 1 – контекст
Начальная cookie
Ответная cookie
Следующ. данные Версия Тип обмена Флаги
Идентификатор сообщения
Длина
0 16 31
115
защиты (SA), 2 – предложение (используется при согласовании пара-
метров); 6 – сертификат, 7 – запрос сертификата и т. д.
Тип обмена – указывает на тип информационного обмена (ре-
жим, в котором работает протокол). Например, 0 – нет обмена, 1 – ба-
зовый, 4 – агрессивный и т. д.
Флаги позволяют указать дополнительные настройки. Напри-
мер, один из флагов указывает, на то, что все данные, идущие за заго-
ловком, зашифрованы.
Идентификатор сообщения – уникальный идентификатор со-
общения.
Длина – длина сообщения (заголовка и данных).
Итак, описанная фаза протокола позволяет сформировать общий
защищенный канал и согласовать его параметры.
После создания общего защищенного канала, параметры каждо-
го защищенного соединения, создаваемого в рамках этого канала, со-
гласуются на основе сформированных глобальных параметров канала
и образуют контекст защиты. Каждое защищенное соединение явля-
ется однонаправленным и в нем может использоваться один из двух
протоколов – ESP или AH (кроме того, на базе общего защищенного
канала могут быть созданы защищенные соединения, использующие
отличный от IPSec протокол). Если предполагается организовать за-
щищаемое ESP двустороннее взаимодействие, понадобятся два со-
единения (и два SA), если использовать и протокол AH, и ESP, то
нужны четыре SA.
В состав согласуемых параметров, образующих SA, входят [13]:
- номер протокола криптозащиты (AH, ESP, другой);
- номера алгоритмов криптозащиты и их параметры;
- режим протокола (транспортный или туннельный);
- сеансовые ключи (действующие для текущего соединения);
- срок существования защищенного соединения (может зада-
ваться временем или объемом переданного трафика; например, срок
116
существования канала - 6 часов, соединения в рамках этого канала – 1
час);
- максимальный размер пакетов;
- дополнительные параметры (параметры счетчика и т. д.) для
защиты от повтора, задержки, удаления пакетов сообщения.
Пользователями защищенных соединений, как правило, являют-
ся прикладные процессы. И между двумя узлами сети может сущест-
вовать произвольное число соединений, сформированных в рамках
одного защищенного канала.
Защищенное соединение, соответствующее спецификациям
протокола IPSec, идентифицируется целевым IP-адресом, используе-
мым протоколом криптозащиты (ESP или AH) и индексом SPI.
Для выработки параметров «Инициатор» и «Партнер» обмени-
ваются следующими сообщениями.
1) «Инициатор»  «Партнер» (защищенное сообщение):
- заявка на создание защищенного соединения (предлагаемые
алгоритмы и их параметры);
- одноразовый номер инициатора.
2) «Партнер»  «Инициатор» (защищенное сообщение):
- принимаемые алгоритмы и параметры;
- одноразовый номер партнера.
3) «Инициатор»  «Партнер» (защищенное сообщение):
- одноразовый номер инициатора;
- одноразовый номер партнера.
Для защиты передаваемых сообщений используются ключи, вы-
работанные при формировании защищенного канала: SKEYID_a – для
аутентификации, SKEYID_e – для шифрования. Для аутентификации
используется хэш-функция, в качестве аргументов которой выступа-
ют аутентифицируемое сообщение и ключ SKEYID_a.
Временные ключи защищенного соединения генерируются пу-
тем применения хэш-функции к значению SKEYID_d с дополнитель-
117
ными параметрами, в число которых входят одноразовые идентифи-
каторы инициатора и партнера.
Принимающая сторона соединения задает для формируемого SA
номер SPI, по которому он будет идентифицироваться.
3.3.5. Протоколы IPSec и трансляция сетевых адресов
При подключении сетей организаций к Интернет, часто исполь-
зуется механизм трансляции сетевых адресов – NAT (от англ. «Network
Address Translation»). Это позволяет уменьшить число зарегист-
рированных IP-адресов, используемых в данной сети. Внутри сети
используются незарегистрированные «частные» адреса (как правило,
из диапазонов, специально выделенных для этой цели, например, ад-
реса вида 192.168.x.y для сетей класса C). Если пакет из такой сети
передается в Интернет, то маршрутизатор, внешнему интерфейсу ко-
торого назначен по крайней мере один зарегистрированный ip-адрес,
модифицирует ip-заголовки сетевых пакетов, подставляя вместо част-
ных адресов зарегистрированный адрес. Порядок, по которому произ-
водится подстановка, описывается в специальной таблице. При полу-
чении ответа, в соответствии с таблицей делается обратная замена, и
пакет переправляется во внутреннюю сеть.
Рассмотрим пример использования NAT рис. 3.11. В данном
случае, во внутренней сети используются частные адреса 192.168.0.x.
С компьютера, с адресом 192.168.0.2 обращаются во внешнюю сеть к
компьютеру с адресом 195.242.2.2. Пусть это будет подключение к
web-серверу (протокол HTTP, который использует TCP порт 80).
При прохождении пакета через маршрутизатор, выполняющий
трансляцию адресов, ip-адрес отправителя (192.168.0.2) будет заменен
на адрес внешнего интерфейса маршрутизатора (195.201.82.146), а в
таблицу трансляции адресов будет добавлена запись, аналогичная
приведенной в таблице 3.1.
Получив представление о механизме работы NAT, разберемся,
какие сложности могут возникнуть, в случае использования IPSec.
118
Рис. 3.11. Пример использования механизма NAT
Таблица 3.1.
Таблица трансляции адресов
Протокол Внутренний ло-
кальный ip-адрес :
порт
Внутренний зареги-
стрированный ip-
адрес: порт.
Внешний
ip-адрес: порт
TCP 192.168.0.2: 2001 195.201.82.146: 2161 195.242.2.2 : 80
Предположим, с хоста с адресом 192.168.0.2 пытаются устано-
вить защищенное соединение с внешним хостом 195.242.2.2, исполь-
зуя протокол аутентифицирующего заголовка (AH). При прохожде-
нии маршрутизатора, ip-адрес отправителя меняется, как было описа-
но выше. Протокол AH определяет, что значение имитовставки рас-
считывается, включая неизменяемые поля IP-заголовка, в частности –
адрес отправителя. Сторона-получатель, обнаружит неверное (из-за
трансляции адресов) значение имитовставки и отбросит пакет.
Таким образом, механизм NAT и протокол AH несовместимы. В
то же время, протокол ESP, который не контролирует целостность ip-
заголовка, может использоваться совместно с трансляцией адресов.
Локальная сеть
внутренний
хост
Маршру-
тизатор
(+NAT)
Internet
192.168.0.2
192.168.0.1
195.201.82.146
119
Кроме того, RFC 2709 определяет расширение NAT - IPC-NAT
(англ. «IPSec policy Controlled NAT» – NAT управляемый правилами
IPSec). Оно позволяет решить указанную проблему путем создания
IP-IP туннеля, одной из конечных точек которого является узел NAT.
В этом случае, вместо модификации IP-адреса отправителя в заголов-
ке исходного пакета, NAT-устройство помещает без изменений весь
исходный пакет (который аутентифицирован AH), в новый IP-пакет, в
заголовке которого в качестве адреса отправителя ставится адрес
NAT-устройства. На стороне получателя из полученного пакета изы-
мают исходный пакет и далее обрабатывают его как обычно.
Отдельно необходимо решать вопрос с распределением ключей.
Если для этой цели используется протокол IKE (а он использует
транспортный протокол UDP, порт 500), потребуется специально ор-
ганизовать пересылку соответствующих данных во внутреннюю сеть.
В том, случае, если задействовать UDP-порт 500 не представляется
возможным, можно использовать описываемый в документах
RFC 3947, 3948 механизм NAT-T (от англ. «NAT traversal»), опреде-
ляющий инкапсуляцию IKE и IPSec трафика в пакеты UDP. При этом
задействуется порт 4500.
3.4. МЕЖСЕТЕВЫЕ ЭКРАНЫ
Межсетевой экран (МЭ) – это средство защиты информации,
осуществляющее анализ и фильтрацию проходящих через него сете-
вых пакетов. В зависимости от установленных правил, МЭ пропуска-
ет или уничтожает пакеты, разрешая или запрещая таким образом се-
тевые соединения. МЭ является классическим средством защиты пе-
риметра компьютерной сети: он устанавливается на границе между
внутренней (защищаемой) и внешней (потенциально опасной) сетями
и контролирует соединения между узлами этих сетей. Но бывают и
другие схемы подключения, которые будут рассмотрены ниже.
120
Английский термин, используемый для обозначения МЭ –
«firewall». Поэтому в литературе межсетевые экраны иногда также
называют файервол или брандмауэр (немецкий термин, аналог firewall).
Как уже было отмечено, фильтрация производится на основании
правил. Наиболее безопасным при формировании правил для МЭ
считается подход «запрещено все, что явно не разрешено». В этом
случае, сетевой пакет проверяется на соответствие разрешающим
правилам, а если таковых не найдется – отбрасывается. Но в некото-
рых случаях применяется и обратный принцип: «разрешено все, что
явно не запрещено». Тогда проверка производится на соответствие
запрещающим правилам и, если таких не будет найдено, пакет будет
пропущен.
Фильтрацию можно производить на разных уровнях эталонной
модели сетевого взаимодействия OSI. По этому признаку МЭ делятся
на следующие классы [13]:
- экранирующий маршрутизатор;
- экранирующий транспорт (шлюз сеансового уровня);
- экранирующий шлюз (шлюз прикладного уровня).
Экранирующий маршрутизатор (или пакетный фильтр) функ-
ционирует на сетевом уровне модели OSI, но для выполнения прове-
рок может использовать информацию и из заголовков протоколов
транспортного уровня. Соответственно, фильтрация может произво-
диться по ip-адресам отправителя и получателя, а также по ТСР и
UDP портам. Такие МЭ отличает высокая производительность и от-
носительная простота – функциональностью пакетных фильтров об-
ладают сейчас даже наиболее простые и недорогие аппаратные мар-
шрутизаторы. В то же время, они не защищают от многих атак, на-
пример, связанных с подменой участников соединений.
Шлюз сеансового уровня работает на сеансовом уровне модели
OSI и также может контролировать информацию сетевого и транс-
портного уровней. Соответственно, в дополнение к перечисленным
121
выше возможностям, подобный МЭ может контролировать процесс
установки соединения и проводить проверку проходящих пакетов на
принадлежность разрешенным соединениям.
Шлюз прикладного уровня может анализировать пакеты на всех
уровнях модели OSI от сетевого до прикладного, что обеспечивает
наиболее высокий уровень защиты. В дополнение к ранее перечис-
ленным, появляются такие возможности, как аутентификация пользо-
вателей, анализ команд протоколов прикладного уровня, проверка пе-
редаваемых данных (на наличие компьютерных вирусов, соответст-
вие политике безопасности) и т. д.
Рассмотрим теперь вопросы, связанные с установкой МЭ. На
рис. 3.12 представлены типовые схемы подключения МЭ. В первом
случае (рис. 3.12 а), МЭ устанавливается после маршрутизатора и за-
щищает всю внутреннюю сеть. Такая схема применяется, если требо-
вания в области защиты от несанкционированного межсетевого дос-
тупа примерно одинаковы для всех узлов внутренней сети. Например,
«разрешать соединения, устанавливаемые из внутренней сети во
внешнюю, и пресекать попытки подключения из внешней сети во
внутреннюю».
В том случае, если требования для разных узлов различны (на-
пример, нужно разместить почтовый сервер, к которому могут под-
ключаться «извне»), подобная схема установки межсетевого экрана
не является достаточно безопасной. Если в нашем примере наруши-
тель, в результате реализации сетевой атаки, получит контроль над
указанным почтовым сервером, через него он может получить доступ
и к другим узлам внутренней сети.
В подобных случаях иногда перед МЭ создается открытый сег-
мент сети предприятия (рис. 3.12 б), а МЭ защищает остальную внут-
реннюю сеть. Недостаток данной схемы заключается в том, что под-
ключения к узлам открытого сегмента МЭ не контролирует.
Более предпочтительным в данном случае является использова-
ние МЭ с тремя сетевыми интерфейсами (рис. 3.12 в).
122
a)
б)
в)
г)
Рис. 3.12. Типовые схемы подключения межсетевых экранов
а) подключение МЭ с двумя сетевыми интерфейсами;
б) подключение МЭ с двумя сетевыми интерфейсами при выделении
открытого сегмента внутренней сети;
в) подключение МЭ с тремя сетевыми интерфейсами;
г) подключение двух МЭ
123
МЭ с тремя сетевыми интерфейсами конфигурируется таким
образом, чтобы правила доступа во внутреннюю сеть были более
строгими, чем в открытый сегмент. В то же время, и те, и другие со-
единения могут контролироваться МЭ. Открытый сегмент в этом слу-
чае иногда называется «демилитаризованной зоной» – DMZ.
Еще более надежной считается схема, в которой для защиты се-
ти с DMZ задействуются два независимо конфигурируемых МЭ
(рис. 3.12 г). В этом случае, MЭ 2 реализует более жесткий набор пра-
вил фильтрации по сравнению с МЭ1. И даже успешная атака на пер-
вый МЭ не сделает внутреннюю сеть беззащитной.
В последнее время стал широко использоваться вариант уста-
новки программного МЭ непосредственно на защищаемый компью-
тер. Иногда такой МЭ называют «персональным». Подобная схема
позволяет защититься от угроз исходящих не только из внешней сети,
но из внутренней. Особенно актуально применение персональных МЭ
при непосредственном подключении компьютера к потенциально
опасной сети. Например, при подключении домашнего компьютера к
Интернет.
Завершая учебное пособие, хочется отметить, что обеспечение
информационной безопасности информационных и управляющих
систем является сейчас очень актуальной задачей. Дополнительные
сведения по данной тематике можно получить из специальной лите-
ратуры, в частности из изданий, перечисленных в библиографическом
списке.
124
БИБЛИОГРАФИЧЕСКИЙ СПИСОК
1. ГОСТ Р 50922-2006. Защита информации. Основные термины
и определения.  М.: Стандартинформ, 2008.  12 с.
2. ГОСТ Р 51275-2006. Защита информации. Объект информати-
зации. Факторы, воздействующие на информацию. Общие положе-
ния.  М.: Стандартинформ, 2007.  11 с.
3. Девянин П.Н., Михальский О.О., Правиков Д.И., Щерба-
ков А.Ю. Теоретические основы компьютерной безопасности: Учеб.
пособие для вузов.  М.: Радио и связь, 2000.  192 с.
4. ГОСТ Р ИСО/МЭК 15408-1-2002. Информационная техноло-
гия. Методы и средства обеспечения безопасности. Критерии оценки
безопасности информационных технологий. Часть 1. Введение и об-
щая модель. – М.: Госстандарт России, 2002.  40 с.
5. Зегжда Д.П., Ивашко А.М. Основы безопасности информаци-
онных систем. – М.: Горячая линия – Телеком, 2000.  452 с.
6. Молдовян Н.А. Проблематика и методы криптографии. 
СПб.: Изд-во СПбГУ, 1998.  212 с.
7. Ященко В.В. и др. Введение в криптографию. / Под общ. ред.
В.В.Ященко. – М.: МЦНМО, «ЧеРо», 1998.  272 с.
8. Грунтович М.М. Основы криптографии с открытыми ключа-
ми. Учебное пособие. – Пенза: Изд-во Пензен. госуд. Ун-та, 2000. 
65 с.
9. Романец Ю.В., Тимофеев П.А., Шаньгин В.Ф. Защита инфор-
мации в компьютерных системах и сетях. - М.: Радио и связь, 1999. 
328 с.
10. Зима В.М., Молдовян А.А., Молдовян Н.А. Компьютерные
сети и защита передаваемой информации. - СПб.: Изд-во СПбГУ,
1998.  328 с.
11. Конеев И.Р., Беляев А.В. Информационная безопасность
предприятия. – СПб.: БХВ-Петербург, 2003.  752 с.
125
12. Василенко О.Н. Теоретико-числовые алгоритмы в крипто-
графии. – М.: МЦНМО, 2003.  328 с.
13. Зима В.М., Молдовян А.А., Молдовян Н.А. Безопасность
глобальных сетевых технологий. – 2-е изд. – СПб.: БХВ-Петербург,
2003.  368 с.
14. Рудаков О.И., Грунтович М.М. Протоколы защиты инфор-
мации в сети: IPSEC и SKIP. Специальная техника средств связи. Се-
рия: Системы, сети и технические средства конфиденциальной связи.
Пенза, ПНИЭИ, вып. № 1, 1999 г. C.79-85.
Нестеров Сергей Александрович
ИНФОРМАЦИОННАЯ БЕЗОПАСНОСТЬ И ЗАЩИТА
ИНФОРМАЦИИ
Учебное пособие
Лицензия ЛР № 020593 от 07.08.97
Налоговая льгота — Общероссийский классификатор продукции
ОК 005-93, т. 2; 95 3005 - учебная литература
Подписано в печать 23.12.2008. Формат 60x84/16 Печать цифровая
Усл. печ. л. 8,0. Уч.-изд. л. 8,0. Тираж 100. Заказ 4620b.
Отпечатано с готового оригинал-макета, предоставленного автором, в
цифровом типографском центре Издательства Политехнического
университета:
195251, Санкт-Петербург, Политехническая ул., 29.
Тел. (812) 540-40-14
Тел./факс: (812) 927-57-76