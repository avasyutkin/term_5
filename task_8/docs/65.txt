Министерство образования и науки Российской Федерации
________________
САНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ
ПОЛИТЕХНИЧЕСКИЙ УНИВЕРСИТЕТ
________________________________________________________
Приоритетный национальный проект «Образование»
Национальный исследовательский университет
Ю.В. ВЕТРОВ С.Б. МАКАРОВ
Криптографические методы защиты
информации в телекоммуникационных системах
Рекомендовано Учебно-методическим объединением по университетскому политехническому образованию в качестве учебного пособия для студентов высших учебных заведений, обучающихся по направлению подготовки магистров Техническая физика
Санкт-Петербург
Издательство политехнического университета
2011
2
УДК 621.391.7:004.056.55(075.8)
ББК 32.811.4я73
В 393
Рецензенты:
М.А Сиверс, д.т.н., проф., зав. каф. «Радиопередающие устройства и средства подвиж-ной связи» Санкт-Петербургского государственного университета им. проф. М.А. Бонч-Бруевича.
А.Ф. Крячко, д.т.н., проф., начальник каф. «Телеметрические системы» Военно-космической академии им. А.Ф. Можайского
Ветров Ю.В. Криптографические методы защиты информации в телеком-муникационных системах: учеб. пособие / Ю.В. Ветров, С.Б. Макаров. — СПб.: Изд-во Политехн. ун-та, 2011. — 174 с.
ISBN
Предлагаемое учебное пособие посвящено изложению криптографическим ме-тодов защиты информации, применяемых в телекоммуникационных системах связи.
В пособии рассматриваются методы шифрования сообщений, в том числе блоч-ные шифры, поточные шифры и др. Даются элементарные сведения о вычислениях в конечных полях. Анализируются классические криптосистемы с секретным ключом и криптографические системы с открытым ключом. Значительное внимание уделено за-щите информации в телекоммуникаицоных системах стандартов GSM, UMTS и CDMA 2000. В учебном пособии приведено описание лабораторной работы «Криптографиче-ские методы защиты информации».
Учебное пособие рекомендовано Учебно-методическим объединением по универ-ситетскому политехническому образованию в качестве учебного пособия для студентов высших учебных заведений, обучающихся по направлению подготовки «Техническая физика». Оно также может быть полезно студентам, обучающимся по направлениям «Радиотехника» и «Инфокоммуникационные технологии и системы связи».
Печатается по решению редакционно-издательского совета Санкт-Петербургского государственного политехнического университета.
© Ю.В. Ветров, С.Б. Макаров, 2011
© Санкт-Петербургский государственный
политехнический университет, 2011
ISBN
3
Оглавление
Предисловие…………………………………………..………………..
Введение……………………………………………..………………....
6
8
1. Методы шифрования сообщений……………………..…............
1.1 Блочные шифры……………………………………………..
1.1.1. Конструкция Фейстеля………………………………...
18
20
20
1.1.2. Композиционные блочные шифры…………………..
23
1.2. Шифр DES (Федеральный стандарт США)………………..
29
1.3. Шифр ГОСТ 28147-89 (Всероссийский стандарт)…………
1.4. Поточные шифры…………………………………………....
1.4.1. Реализация вычислений в полях многочленов с помо-щью регистров с прямыми и обратными связями……………
1.4.2. Регистры с линейными обратными связями…………
1.4.3. Последовательности максимальной длины……………
1.4.4. Оценка качества последовательностей максимальной длины…………………………………………………………………..
1.4.5. CRC код………………………………………………….
1.4.6. Пример реализация поточного шифра ………………..
1.4.7. Синхронный потоковый шифр RC4……………………
Вопросы и задания……………………………………………………
41
45
47
49
51
52
53
55
57
59
2. Элементарные сведения о вычислениях в конечных полях……
2.1. Элементы теории множеств………………………………..
2.2. Решение диофантова уравнения первой степени на осно-вании алгоритма Евклида………………………………………
60
60
65
2.3. Решение сравнения первой степени на основании алго-ритма Евклида…………………………………………………….
2.4. Проверка чисел на простоту……………………………….
2.5. Алгоритм быстрого возведения в степень…………………
2.6. Задача дискретного логарифмирования……………………
2.7. Китайская теорема об остатках……………………………
2.8. Поле Галуа………………………………………………….
2.9. Мультипликативная структура конечных полей…………..
65
66
68
69
69
70
73
4
2.10. Кольца многочленов……………………………………...
2.11. Классы вычетов в полях многочленов…………………….
2.12. Мультипликативная группа в поле многочленов……...
2.13. Китайская теорема об остатках для многочленов………
Вопросы и задания………………………………………………………….
73
76
77
78
81
3. Криптографические системы с открытым ключом……………….
3.1. Криптографическая система без передачи ключей………..
3.2. Алгоритмы шифрования, построенные на основе задачи об укладке ранца……………………………………………………….
3.3. Обмен сообщениями по алгоритму Диффи — Хеллмана…
3.4. Обмен сообщениями по алгоритму Т. Эль-Гамаля……….
3.5. Криптографическая система с открытым ключом RSA…
3.6. Телекоммуникационные протоколы, использующие сеан-совые ключи………………………………………………………
3.6.1. Обмен ключами с помощью симметричного шифро-вания……………………………………………………………
3.6.2. Обмен ключами, используя алгоритмы с открытыми ключами………………………………………………………………...
3.6.3. Передача ключей и сообщений…………………………
3.6.4. Алгоритм открытого распределения ключей Диффи — Хеллмана…………………………………………………..
3.6.5. Алгоритм распределения ключей Диффи — Хеллмана с тремя и более абонентами …………………………………………
3.6.6. Алгоритм распределения ключей Хьюза……………
3.6.7. Протокол обмена зашифрованными ключами ЕКЕ…
82
82
84
88
88
89
93
93
95
96
96
97
98
99
3.7. Удостоверение подлинности………………………………
102
3.7.1. Удостоверение подлинности с помощью однонаправ-ленных функций……………………………………….
3.7.2. Удостоверение подлинности с помощью открытых ключей………………………………………………………………….
3.7.3. Формальный анализ протоколов проверки подлинно-сти и обмена ключами…………………………………………………
103
104
104
5
3.7.4. Протокол аутентификации с нулевым разглашением информации…………………………………………………………….
3.7.5. Протоколы аутентификации с вероятностной систе-мой доказательств……………………………………………...............
3.8. Хеш-функция………………………………………………
3.8.1. Функция хеширования в стандарте DSS………………
3.8.2. Функция хеширования в стандарте ГОСТ Р34.11-94…
3.8.3. Стандарт цифровой подписи ГОСТ Р34.10-94………
3.9. Скрытый канал…………………………………………………….
3.10. Организация скрытого канала на основе подписи Эль-Гамаля……………………………………………………………..
Вопросы и задания………………………………………………………..
4. Защита информации в стандарте GSM…………………………….
4.1. Обеспечение безопасности передачи информации в теле-коммуникационных системах стандарта GSM………………
4.2. Принципы взаимодействия компонентов системы стан-дарта GSМ……………………………………………………….
4.3. Аутентификация……………………………………………
4.4. Алгоритмы аутентификации A3 и генерации ключа A8. Хеш-функция СOMР128………………………………………………
105
107
109
110
113
116
117
118
120
122
123
124
125
127
4.5. Шифрование поточным шифром А5……………………….
Вопросы и задания……………………………………………………….
5. Защита информации в телекоммуникационных системах стан-дартов UMTS и CDMA2000……………………………………
5.1. Механизмы обеспечения безопасности в стандарте UMTS
5.2. Механизмы обеспечения безопасности в стандарте CDMA2000………………………………………………….................
Вопросы и задания………………………………………………………..
6. Лабораторная работа «Криптографические методы защиты ин-формации»………………………………………………………………
Задания к лабораторной работе.............................................................
Библиографический список ....................……………….....……..........
130
131
132
133
144
151
152173174
6
Предисловие
Учебное пособие предназначено для студентов высших учебных заведений, обучающихся по направлениям подготовки «Техническая физика». Цель данного учебного пособия заключается в том, чтобы дать теоретические сведения, необходимые для понимания принципов использования криптографии, применяемой в телекоммуникационных системах передачи информации.
Во введении после краткого исторического экскурса даются оп-ределения основных терминов, используемых в криптографии.
В первом разделе рассматривается классификация криптогра-фических систем, подробно рассматривается структура Фейстеля, лежащая в основе современных композиционных блочных шифров, поточные шифры, используемые в системах мобильной связи.
Во втором разделе рассматриваются математические основы криптографии: вычисления в конечных полях, в частности, в полях многочленов, методы решения диофантовых уравнений, принципы использования китайской теоремы об остатках, как числовом поле, так и в поле многочленов.
В третьем разделе рассматриваются системы с открытым клю-чом, используемые в системах электронной торговли, в банковских системах, функции хеширования и цифровой подписи.
В четвертом разделе рассматриваются механизмы обеспечения безопасности в телекоммуникационной системе передачи данных стандарта GSM. В частности, протоколы аутентификации сети, ау-тентификации пользователя, функции шифрования, алгоритмы ими-тационной защиты информации.
В пятом разделе рассматриваются механизмы обеспечения безопасности в системах мобильной связи третьего поколения UMTS и CDMA2000.
7
В шестом разделе приводится описание лабораторной работы
«Криптографические методы защиты информации», в которой пред-
лагается программа экспериментальных исследований, поддержи-
вающих основные теоретические разделы математических основ
криптографии, методы построения композиционных блочных шиф-
ров, поточных шифров, используемых в телекоммуникационных сис-
темах.
В пособии излагаются основы криптографии с позиции приме-
нения ее основных методов и алгоритмов в телекоммуникационных
системах передачи информации. В пособии нет подробного анализа
основных теоретических положений классической криптографии, но
даются элементарные сведения из общей математической теории по-
строения многочленов, позволяющие понять механизмы обеспечения
безопасности в цифровых мобильных системах связи стандартов
GSM, UMTS и CDMA2000.
Авторы считают, что опыт, полученный ими в процессе много-
летнего ведения соответствующих курсов лекций, лабораторного
практикума, руководства дипломным проектированием помог им в
процессе работы над учебным пособием. Профессиональное удовле-
творение, как считают авторы, они смогут получить, если учебное по-
собие станет кладезем практических знаний в разработке современ-
ных защищенных телекоммуникационных систем передачи данных и
связи.
8
Введение
Проблема тайной передачи сообщений существует столько вре-
мени, сколько существует письменность, более того, первоначально
письменность сама по себе была методом тайной передачи информа-
ции, поскольку была доступна лишь избранным. Для реализации тай-
ной передачи сообщения от одного адресата к другому существует
два направления: во-первых, можно попытаться скрыть сам факт пе-
редачи сообщения, например, методами тайнописи, во-вторых, можно
так преобразовать сообщение, чтобы постороннему лицу была недос-
тупна информация, заключенная в сообщении. Первым направлением
занимается стеганография, вторым ― криптография.
В учебном пособии будут рассматриваться криптографические
методы защиты информации, передаваемой по телекоммуникацион-
ным системам. Для защиты информации используется, прежде всего,
шифрование. При шифровании происходит преобразование данных в
вид, недоступный для чтения без соответствующей информации
(ключа шифрования). Задача состоит в том, чтобы обеспечить конфи-
денциальность, скрыв информацию от лиц, которым она не предна-
значена, даже если они имеют доступ к зашифрованным данным.
Кроме этого, используются криптографические методы контроля це-
лостности переданной информации и криптографические методы ау-
тентификации абонента, позволяющие убедиться, что информация
передана именно данному абоненту.
— Ах, если б знать! — заплакал
Морж. — Проблема так сложна!
Льюис Кэролл. Алиса в Зазеркалье
9
Роль шифров в истории развития человечества огромна. Шифры
решали результаты сражений и приводили к смерти королей и коро-
лев. Характерной является история Марии Стюард [1]. Ей вменяли в
вину организацию заговора с целью убийства королевы Елизаветы I,
чтобы завладеть короной Англии. Нужно было доказать, что Мария
была душой заговора, а посему заслуживает смерти. Однако ее поло-
жение не было безнадежно, поскольку она была осторожна, и вся ее
переписка с заговорщиками была зашифрована. Шифр превратил ее
слова в бессмысленный набор символов. Если содержание писем ос-
тавалось тайным, то письма не могли использоваться как свидетель-
ство против нее. Однако все это было бы так только при условии, что
ее шифр не был раскрыт.
Дешифрирование ― процесс, обратный шифрованию, т. е. пре-
образование шифрованных данных в открытый вид.
Хотя криптография и стеганография являются независимыми, но
для обеспечения максимальной секретности, чтобы и зашифровать, и
скрыть сообщение, можно пользоваться обеими. Впервые криптогра-
фический метод защиты информации и стеганография в телекомму-
никационных системах стал применяться, по-видимому, во Второй
мировой войне. Метод назывался микроточкой, с помощью которого
фотографическим способом сжималась страница текста в точку диа-
метром менее одного миллиметра. Эта микроточка прикреплялась по-
верх обычной точки в конце предложения в совершенно безобидном
письме. Обнаружить первую микроточку удалось, получив предупре-
ждение о том, где следует искать крошечный блик на поверхности
письма, указывающий, что в этом месте прикреплен кусочек глянце-
вой фотопленки. В последствие оказалось возможным прочитать со-
держимое большинства перехваченных микроточек, за исключением
тех случаев, когда были предпринято дополнительное шифрование
сообщения перед сжатием.
В криптографии на первом этапе ее развития существовали два
направления, известные как перестановка и замена. При перестанов-
10
ке буквы сообщения просто переставляются, образуя анаграмму. Для
очень короткого сообщения, состоящего, например, из одного слова,
такой способ весьма ненадежен, поскольку существует крайне огра-
ниченное число возможных способов перестановки горстки букв. Од-
нако по мере увеличения количества букв число возможных переста-
новок стремительно растет, и восстановить исходное сообщение ста-
новится невозможным, если не известен точный способ шифрования.
Для обеспечения эффективности способ перестановки букв должен
быть заранее оговорен отправителем сообщения и его получателем,
но он должен храниться в секрете от противника. Один из способов
перестановки букв был реализован в самом первом из известных
шифровальных устройств ― спартанской скитале. Упоминание об
этом устройстве восходит к пятому веку до н. э. Скитала (или сцита-
ла) представляла собой деревянный цилиндр (или конус), вокруг ко-
торого наматывалась полоска кожи или пергамента.
Рис. 1. Скитала
Отправитель писал сообщение по всей длине скиталы, а затем
разматывал полоску, на которой после этого оставался бессмыслен-
ный набор букв. Сообщение оказывалось зашифрованным. Сообще-
ние можно будет прочесть, только если намотать эту полоску вокруг
другой скиталы такого же диаметра. Вестник брал кожаную полоску
и обычно прятал сообщение, используя полоску как пояс, буквами
внутрь, то есть кроме зашифровывания применял также и стегано-
графию. Чтобы получить исходное сообщение, адресат просто нама-
тывал полоску кожи вокруг скиталы того же диаметра, что и скита-
ла, которой пользовался отправитель. В 404 году до н. э. к спартан-
скому полководцу Лисандру привели вестника, окровавленного и
11
еле держащегося на ногах, одного из пяти оставшихся в живых по-сле, крайне опасного путешествия из Персии. Вестник передал свой пояс Лисандру, который намотал его вокруг своей скиталы и прочи-тал, что Фарнабаз собирается напасть на него. Благодаря скитале Лисандр успел подготовиться к нападению и отбил его.
Альтернативой перестановке является замена. Одно из первых описаний шифрования с помощью замены дается в «Кама-сутре», тексте, написанном в четвертом веке н. э. священником-брамином Ватсьяной и основанном на манускриптах, относящихся к четверто-му веку до н. э. Согласно «Кама-сутре», женщины должны овладеть 64 искусствами, такими, как приготовление пищи и напитков, ис-кусство одевания, массаж, приготовление ароматов. В этот список также входят менее очевидные искусства: колдовство, игра в шахма-ты, переплетное дело и плотницкое дело. Под номером 45 в списке стоит искусство тайнописи, предназначенное для того, чтобы по-мочь женщинам скрыть подробности своих любовных связей. Один из рекомендуемых способов заключается в том, чтобы расположить попарно буквы алфавита случайным образом, а затем заменять каж-дую букву в исходном сообщении ее парной. Если применить этот принцип к латинскому алфавиту, то мы можем расположить буквы попарно следующим образом:
Рис. 2. Шифр замены
Тогда вместо текста meet at midnight (встретимся в полночь) отправи-тель напишет CUUZ VZ CGXSGIBZ. Такой вид тайнописи называется шифром замены, поскольку каждая буква в исходном тексте заменя-ется другой буквой, так что этот шифр диаметрально противоположен шифру перестановки. При перестановке каждая буква остается сама
12
собой, но меняет свое местоположение, в то время как при замене ка-ждая буква меняется на другую букву, но остается на своем месте.
Первое документально подтвержденное использование шифра замены в военных целях появилось в «Галльских войнах» Юлия Це-заря. Каждая букву в послании заменяется буквой, стоящей в алфави-те на три позиции дальше. Наиболее часто пользуются терминами ал-фавит открытого текста, то есть алфавит, используемый для созда-ния исходного, незашифрованного сообщения, и шифралфавит, бук-вы которого подставляются вместо букв алфавита открытого текста. Если алфавит открытого текста расположить над шифралфавитом, то станет ясно, что шифралфавит сдвинут на три позиции, и поэтому та-кой вид замены часто называется шифром сдвига Цезаря или просто шифром Цезаря. Хотя Светоний упоминает только о шифре Цезаря со сдвигом на три позиции, ясно, что, осуществляя сдвиг на 1..25 пози-ций, можно создать для латинского алфавита 25 различных шифров. Если же мы не будем ограничиваться сдвигом алфавита, а будем рас-сматривать шифралфавит как любую возможную перестановку букв алфавита открытого текста, то мы сможем создать гораздо большее количество различных шифров.
При этом шифр Цезаря является частным случаем моноалфа-витной подстановки, а ключевая матрица является матрицей сдвига. Шифр Цезаря достаточно легкий. Если известен открытый текст и соответствующий ему зашифрованный текст, то ключ вычисляется непосредственно как разность номеров соответствующих букв от-крытого текста и зашифрованного текста. Если известны только за-шифрованные тексты, то ключ вычисляется с помощью частотного анализа. Частотный анализ основан на том, что буквы алфавита появ-ляются с различной частотой. Сравнивая частоту появления букв за-шифрованного текста и частоту появления букв исходного алфавита, можно вычислить матрицу подстановки.
Изобретение многоалфавитной замены сделало процедуру шифрования устойчивой к вскрытию. Примером многоалфавитной
13
замены является шифр Блеза Виженера, дипломата 16 века, который развивал и совершенствовал криптографические системы. Этот шифр основан на таблице Виженера, представленной на рис. 3.
Ключ
Исходный алфавит
абвгдежзиклмнопрстуфхцчшщыъэюя_
а
абвгдежзиклмнопрстуфхцчшщыъэюя_
б
_абвгдежзиклмнопрстуфхцчшщыъэюя
в
я_абвгдежзиклмнопрстуфхцчшщыъэю
г
юя_абвгдежзиклмнопрстуфхцчшщыъэ
..
---------------------------------------------
я
вгдежзиклмнопрстуфхцчшщыъэюя_аб
_
бвгдежзиклмнопрстуфхцчшщыъэюя_а
Рис. 3. Таблица Виженера
В этой таблице первая строка представляет собой исходный ал-фавит, дополненный символом пробела. Левый столбец таблицы представляет собой набор символов ключа. Вторая строка соответст-вует букве «а» ключа и нулевому сдвигу исходного алфавита, по су-ществу, повторяя первую строку таблицы. Третья строка соответст-вует букве «б» ключа и циклическому сдвигу на один символ второй строки таблицы. Четвертая строка соответствует букве «в» ключа и циклическому сдвигу на один символ третьей строки таблицы. По-строение строк продолжается до букв «я» и пробел «_» ключа.
При шифровании сообщения его выписывают в строку, а под каждой буквой открытого текста записывают буквы ключа. Если ключ оказался короче сообщения, то его циклически повторяют. За-шифрованный текст получают, находя символ открытого текста в первой строке таблицы и заменяя его соответствующим символом, находящимся на этом же месте, из строки, соответствующей букве ключа в левом столбце таблицы Виженера. Например, применяя, ключ АГАВА, к сообщению ПРИЕЗЖАЮ ШЕСТОГО, получаем сле-дующее зашифрованное сообщение (рис. 4):
14
ПРИЕЗЖ А Ю _ Ш Е С Т О Г О открытый текст
АГАВАА Г А В А А Г А В А А ключ
ПНИГЗЖ ЮЮ ЮШ Е О Т М ГО зашифрованный текст
Рис. 4. Зашифрованное с помощью таблицы Виженера сообщение
В компьютере операция шифрования соответствует сложению ASCII символов сообщения и ключа по некоторому модулю. Для шифрования и дешифрирования требуется ключ. Процесс передачи шифрованной информации иллюстрируется рис. 5.
Рис. 5. Процесс передачи информации
Простейшей и, в то же время, наиболее надежной из всех сис-тем шифрования является так называемая схема однократного ис-пользования. Принцип работы такой системы заключается в следую-щем. Формируется m-разрядная случайная двоичная последователь-ность, которая является ключом шифра, известного отправителю и получателю сообщения. Отправитель производит побитовое сложе-ние по модулю 2 символов ключа и m-разрядной двоичной последо-вательности, соответствующей пересылаемому сообщению:
ci = (pi + ki) mod 2,
где pi, ki, ci ― очередной i-й бит, соответственно, исходного сообще-ния, ключа и шифрованного сообщения. Процесс расшифровывания сводится к повторной генерации ключевой последовательности и на-ложения ее на шифрованные данные:
pi = (ci + ki) mod 2.
15
Если ключ является фрагментом случайной двоичной последо-вательности с равномерным законом распределения, так, что длина ключа равна длине исходного сообщения, и ключ используется толь-ко один раз, то такой шифр является абсолютно стойким [5].
Абсолютная стойкость рассмотренной схемы оплачивается слишком большой ценой: такое устройство весьма дорогое и непрак-тичное. Одним из вариантов подобного устройства является шифро-вальный блокнот.
Методы криптографии используются не только для шифрова-ния. Важной задачей также является установление подлинности со-общения или аутентификация (например, при подписании докумен-тов). Наиболее известной является цифровая подпись, которая связы-вает подписанный документ с владельцем определенного ключа, а цифровая дата связывает документ со временем его создания. Крип-тографические методы защиты информации в телекоммуникацион-ных системах используются в финансовых операциях, таких, как на-пример, электронная торговля. Термин «электронная торговля» под-разумевает банковские операции, управление счетами и совершение покупок, а также некоторые другие действия, осуществляемые с по-мощью сети Интернет (например, заказ авиабилетов, бронирование мест в гостиницах, вызов такси, перевод денег с одного счета на дру-гой и т. д.). Однако передача при расчетах по сети Интернет номера кредитной карточки вызывает необходимость защитить его от пере-хвата. Эта задачу также решается криптографическими средствами путем шифрования номера кредитной карточки (или другой ценной информации) для передачи по открытому телекоммуникационному каналу связи. Кроме того, криптографические методы позволяют за-щитить весь сеанс связи, и тогда вся пересылаемая по открытым ка-налам шифрованная информация будет недоступна для несанкциони-рованного доступа. В этом случае Web-сервер интернет-магазина, получив шифрованную информацию, дешифрирует ее и принимает платеж, а пользователь может не опасаться, что номер кредитной
16
карточки (или другая ценная информация) будет использован не по назначению. Поскольку количество платежей, проводимых по сети интернет и беспроводным телекоммуникационным сетям, возрастает, защита информации от несанкционированного доступа становится одной из главных задач, которые возникают при построении совре-менных сетей передачи данных.
Введем некоторые термины, необходимые для рассмотрения методов использования криптографии в телекоммуникационных сис-темах.
Система криптографическая (криптосистема) ― система обеспечения безопасности системы связи, использующая криптогра-фические средства. В качестве подсистем может включать системы шифрования, аутентификации, имитационной защиты, цифровой подписи.
Система шифрования ― система обеспечения конфиденци-альности, предназначенная для защиты информации от ознакомления с ее содержанием лиц, не имеющих права доступа к ней, путем шиф-рования информации. Математическая модель системы включает способ кодирования исходной и выходной информации, шифр и клю-чевую систему.
Система ключевая ― определяет порядок использования крип-тографической системы и включает системы установки и управления ключами.
Симметричные криптографические системы (симметричное шифрование, симметричные шифры, криптографические систе-мы с секретным ключом) ― способ шифрования, в котором для шифрования и дешифрирования применяется один и тот же секрет-ный криптографический ключ, который никогда не передается по от-крытому каналу связи.
Криптографическая система с открытым ключом (или асимметричное шифрование) ― система при которой используется пара ключей, причем открытый ключ передаѐтся по открытому (т. е.
17
незащищѐнному, доступному для наблюдения) каналу, а криптогра-фическая стойкость обеспечивается наличием закрытого ключа.
Система аутентификации ― криптографическая система, выполняющая функцию идентификации сторон в процессе информа-ционного взаимодействия. Математическая модель системы включа-ет протокол аутентификации.
Система имитационной защиты (обеспечения целостности) информации ― криптографическая система, выполняющая функцию аутентификации содержания сообщения или документа и предназна-ченная для защиты от несанкционированного изменения информации
Система цифровой подписи ― криптографическая система, выполняющая функцию аутентификации источника сообщения или документа.
18
1. Методы шифрования сообщений
Шифрование и дешифрование сообщений происходит на входе
и выходе канала передачи данных (рис. 1.1). Несанкционированный
пользователь анализирует процесс передачи информации по каналу
связи и имеет возможность формировать свои собственные сообще-
ния.
Рис. 1.1. Канал передачи данных
Процедуры шифрования и дешифрирования можно представить
в следующем виде:
( );
( ),
e
d
k
k
c E p
p D c


где p и c соответственно ― открытый и зашифрованный тексты, ke и
kd ― ключи шифрования и дешифрирования;
ke E и
kd D ― функции
шифрования с ключом ke и дешифрирования с ключом kd соответст-
Абонент А
(отправитель)
Несанкционированный
пользователь
Абонент В
(отправитель)
Шифрование
K E
Канал пере-
дачи данных
Дешифрирование
K D
Ни одна вещь не возникает беспричинно,
но все возникает на каком-нибудь основаниии в
силу необходимости.
Демокрит
19
венно, причем для любого открытого текста справедливо соотноше-
ние
( ( )) .
kd ke D E p  p
На рис. 1.2 приведена классификация методов шифрования ин-
формации.
Рис. 1.2. Методы шифрования информации
Различают два типа алгоритмов шифрования: симметричные (с
закрытым или секретным ключом) и асимметричные (с открытым
ключом). В первом случае ключ шифрования совпадает с ключом
дешифрирования. В асимметричных алгоритмах для шифрования и
дешифрирования используются различные ключи, причем знание од-
ного из них не дает практической возможности определить другой.
Самосинхронизирующиеся
Шифрование с секрет-
ным ключом
Методы
шифрования
Шифрование с откры-
тым ключом
Замена
(подстановка)
Блочные
шифры
Поточные
шифры
Комбинированные
шифры
Перестановка (транспо-
зиция)
Синхронные
Композиционные
(шифры-произведения)
20
1.1. Блочные шифры
К блочным шифрам относятся шифр Цезаря, являющийся при-
мером моноалфавитной подстановки, и шифр Виженера, являющийся
примером многоалфавитной подстановки. Как правило, в виду низкой
криптографической стойкости эти шифры в чистом виде не исполь-
зуются. Криптосистема с однократным ключом, обладающая абсо-
лютной криптографической стойкостью, неудобна для практического
применения. Поэтому блочные шифры строятся на основе многократ-
ного применения относительно простых криптографических преобра-
зований, к которым относятся подстановки и перестановки. Приме-
ром такой структуры является конструкция Фейстеля.
1.1.1. Конструкция Фейстеля
Блочные шифры представляют собой семейство обратимых пре-
образований блоков (частей фиксированной длины) исходного текста.
В процессе шифрования информация делится на порции величиной от
одного до сотен бит. Блочные шифры наиболее распространены на
практике. Под N-разрядным блоком будем понимать последователь-
ность из нулей и единиц длины N:
x = (x0, x1, x2, …, xN–1),
где x можно интерпретировать как вектор, двоичное представление
целого числа или как многочлен. Под блочным шифром будем пони-
мать отображение (см. разд. 2)
T : xy , где y = (y0, y1, y2, ... yN–1),
представляющие собой последовательность из нулей и единиц длиной
N.
Хотя блочные шифры можно при таком описании рассматривать
как частный случай шифра подстановок на алфавитах большого объ-
ема L = 2N, однако практически всегда их рассматривают отдельно.
Рассмотрим более подробно методы, заложенные в основу по-
строения композиционных блочных шифров. Конструкция Фейстеля
21
лежит в основе шифров DES, ГОСТ 28147-89, Lucifer, FEAL, Blowfish
и др.
При таком методе шифрования блок pi открытого текста разби-
вается на две равные части ― правую и левую. Представим шифруе-
мый блок данных pi в виде пары полублоков в два раза меньшего раз-
мера pi = (L, R). Очевидно, что при этом длина блока должна быть
четной.
Конструкция Фейстеля представлена на рис. 1.3, где k1, k2, … ―
ключи шифрования, а f ― криптографическая функция.
Рис. 1.3. Конструкция Фейстеля
Для того чтобы конструкция Фейстеля могла быть использована
как для шифрования, так и для дешифрования функция f должна яв-
ляться инволюцией, т. е. f(f(x)) = f(x) для всех x. Например, функция
f(x) = x является инволюцией, функция f(x) = x + c является инволю-
цией, где c произвольная константа, а суммирование осуществляется
по модулю 2.
f
2 k
f
3 k
+
+
+ f
1 k
22
На каждом цикле одна из частей открытого текста подвергается
преобразованию при помощи функции f и вспомогательного ключа ki.
Результат операции суммируется по модулю 2 с другой частью. Затем
левая и правая части меняются местами. Преобразования на каждом
цикле идентичны. Процедура дешифрования (рис. 1.4, б) аналогична
процедуре шифрования (рис. 1.4, а), однако ключи ki выбираются в
обратном порядке.
Рис. 1.4. Процессы шифрования и дешифрования
В результате преобразования блока открытого текста p
рис. 1.4, а, получаем блок шифрованного текста
      1 2 k1 .
kn kn k c E E E E p

  
Исходный текст может быть восстановлен в результате преобра-
зования (рис. 1.4, б):
      1 2 1 k .
k k k n n p E E E E p

  
Таким образом, завершается процесс шифрования и дешифрования
сообщения.
E ( . . ) E ( . . ) E ( . . )
E ( . . ) E ( . . ) E ( . . )
а)
б)
1 k 2 k n k
n k 2 k 1 k
c
c p
p
23
1.1.2. Композиционные блочные шифры
Многократное применение операций подстановки и перестановки позволяет значительно повысить криптографическую стойкость и обеспечить два свойства, которые должны быть присущи стойким шифрам: рассеивание и перемешивание.
Рассеивание предполагает распространение влияния одного сим-вола открытого текста, а также одного символа ключа на значитель-ное количество символов шифрованного текста. Целью перемешива-ния является усложнение зависимости между ключом и шифрован-ным текстом. Наиболее известны шифр DES и шифр ГОСТ 28147-89, построенные на основе конструкции Фейстеля. Рассмотрим подроб-нее основные идеи, лежащие в основе этих двух шифров, которые фактически отличаются лишь численными параметрами.
Композиционный шифр определяется семейством преобразова-ний Fi, где i = 1, 2, ..., r. Преобразование Fi называется раундом шиф-рования, причем каждому преобразованию соответствует свой ключ шифрования ki, который называется раундовым ключом.
На рис. 1.5 более подробно рассмотрена структура раундовой функции шифрования. В блочных криптосистемах раундовые шифры строятся с использованием операций подстановки двоичных кодов небольшой разрядности (схемы, реализующие эту нелинейную опера-цию, называются S-блоками) и перестановки элементов двоичных ко-дов (P-блоки). От свойств кодов, записанных в S-блоках, в первую очередь зависит стойкость всей системы.
Важным достоинством многих составных шифров является их симметричность относительно операций шифрования и дешифриро-вания, которые по этой причине могут быть реализованы на одном устройстве. Переход от одного режима к другому обеспечивается за-меной последовательности раундовых ключей на другие ключи.
24
Рис. 1.5. Структура раундовой функции шифрования
Представим шифруемый блок данных pi в виде пары полублоков
в два раза меньшего размера, как это предусмотрено в конструкции
Фейстеля:
S-блок S-блок S-блок
Блок перестановок P-блок
S-блок S-блок S-блок
Блок перестановок P-блок
S-блок S-блок S-блок
Блок перестановок P-блок
1 k
2 k
r k
25
pi = (L, R)
Выполним шифрование старшего полублока L(Left) с помощью
младшего R(Right), используя некоторую криптографическую функ-
цию fi, зависящую от раундового ключа ki, и обратимую бинарную
операцию, например, операцию ―сложения по модулю 2, над по-
лублоками данных. Для подготовки к следующему аналогичному ра-
унду выполняется перестановка правой и левой частей блока. Таким
образом, раундовая функция шифрования будет иметь следующий
вид (рис. 1.6):
Fi(pi) = Fi(L, R) = (R, Lfi(R)).
Рис. 1.6. Раундовая функция шифрования
Для раундовой функции шифрования можно построить обрат-
ное или дешифрирующее преобразование:
Fi
–1(ci) = Fi
–1(L, R) = (R, L fi(R)).
i c
i k
i p
L R
L R
i f
+
26
Рис. 1.7. Раундовая функция дешифрирования
Композиционный шифр, использующий раундовые функции та-
кого вида, называется композиционным шифром, построенным в со-
ответствии с конструкцией Фейстеля. Если функции fi являются ин-
волюцией, то прямое преобразование и обратное преобразование сов-
падают, а меняется только порядок используемых ключей. На рис. 1.6
и 1.7 рассмотрены раундовые преобразования в режиме простой за-
мены. Из одного блока открытого текста после криптографического
преобразования получается один блок шифрованного текста.
При использовании композиционных блочных шифров приме-
няются различные схемы шифрования, известные под названием ра-
бочих режимов шифрования. Режимы шифрования позволяют реали-
зовать дополнительные, отсутствующие в исходной конструкции
блочного шифра, функции и, тем самым, повысить криптографиче-
скую стойкость.
Композиционные методы шифрования обеспечивают зависи-
мость каждого блока шифрованного текста не только от соответст-
вующего блока открытого текста, но и от его номера. На рис. 1.8 по-
казана схема шифрования в режиме сцепления блоков шифрованного
i p
i c
L R
i k
L R
i f
+
27
текста ― CBC (Ciphertext Block Chaining), а на рис 1.9 ― схема де-
шифрирования. На этих рисунках p1, p2, ..., pm — блоки открытого тек-
ста, с0, с1, …, сm ― блоки шифрованного текста, E1, E2, ..., Em ― блоки
шифрования, D1, D2, …, Dm — блоки дешифрирования.
Рис. 1.8. Схема шифрования в режиме сцепления блоков
шифрованного текста
Рис. 1.9. Схема дешифрирования в режиме сцепления бло-
ков шифрованного текста
Уравнения шифрования и дешифрирования в режиме CBC име-
ют вид
1 c 2 c m c 0 c
1 p 2 p m p
1 D 2 D m D
+ + +
1 c 2 c m c 0 c
1 p 2 p m p
1 E 2 E m E
+ + +
28
ci = Ei (pi + ci–1);
pi = Di (ci) + ci–1; i = 1, 2, ..., m.
Отличительными особенностями режима CBC являются зависи-
мость при шифровании i-го блока шифрованного текста от всех
предшествующих блоков открытого текста и зависимость при де-
шифрировании каждого блока открытого текста только от двух бло-
ков шифрованного текста (ci–1 и ci).
Рис. 1.10. Схема шифрования в режиме «обратная связь по шиф-
рованному тексту»
Рис. 1.11. Схема дешифрирования в режиме «обратная связь по
шифрованному тексту»
1 c 2 c m c 0 c
1 p 2 p m p
1 E 2 E m E
+ + +
0 p 1 p m p
1 c 2 c m c 0 c
1 D 2 D m D
+ + +
29
Кроме рассмотренного выше режима шифрования CBC сущест-вует и множество других режимов шифрования, обеспечивающих по-вышенную криптографическую стойкость телекоммуникационной системы передачи информации. Рассмотрим, например, режим шиф-рования, который называется «режим обратная связь по шифрован-ному тексту» CFB (Ciphertext Feedback) (рис. 1.10 и 1.11).
Уравнения шифрования и дешифрирования имеют вид:
ci = pi + Ei(ci–1);
pi = ci + Di (ci–1); Di = Ei, i = 1, 2, ..., m.
Заметим, что начальное состояние c0 можно рассматривать как некоторое начальное состояние (синхропосылка). Кроме этих двух режимов в криптосистемах с секретным ключом, например, шифрах DES, ГОСТ 28147-89 и др. для сцепления блоков могут использовать-ся и другие схемы шифрования:
• режим обратной связи по выходу — OFB (Output Feedback);
• сцепление блоков открытого текста — PBC (Plaintext Block Chaining);
• обратная связь по открытому тексту — PFB (Plaintext Feedback);
• усиленное сцепление блоков шифрованного текста.
1.2. Шифр DES (Федеральный стандарт США)
Разновидностью шифра Фейстеля является созданный в 1974 г. шифр DES (Data Encryption Standard) и предложенный в качестве стандарта шифрования данных в государственных и частных органи-зациях США. Шифр DES имеет длину блока исходных данных p рав-ную 64 битам и ключ сложения по модулю 2 длиной 56 бит. Ключ, реализующий подстановку, является ключом длительного пользова-ния, который выбирается по специальным критериям.
Схема преобразования представлена на рис. 1.12. На этом ри-сунке: p ― блок открытого текста. В этом блоке предполагается, что открытый текст разбивается на части по 64 бита. Каждые 64 бита подвергаются всем преобразованиям, которые приведены на рис. 1.12.
30
Рис. 1.12. Структура шифра DES
2 1 L  R
16 15 L  R
2 1 1 2 R  L  f (R ,k )
16 15 15 16 R  L  f (R ,k )
IP–1
c
1 k
2 k
p
IP
0 L 0 R
1 0 L  R 1 0 0 1 R  L  f (R ,k )
f
+ f
+
31
Это соответствует режиму шифрования «прямая замена», когда 64 бита обрабатываются независимо друг от друга и после всех пре-образований появляется 64 бита зашифрованного текста. На выходе схемы преобразования находится блок с ― блок шифрованного тек-ста. Кроме этих блоков в схему преобразования входят: IP ― блок начальной перестановки, IP–1― блок конечной перестановки, f ― функция криптографического преобразования, L ― левые полублоки, Ri ― правые полублоки, i = 0, 1, 2, …, 15.
Блок открытого текста (64 бита) подвергается начальной пере-становке, согласно табл. 1.1. В соответствии с этой таблицей 58 бит открытого текста становится первым битом, 50 бит становится вто-рым битом, 42 бит ― третьим, а первый бит открытого текста пере-мещается на 40 позицию и т. д. После блока начальной перестановки полученные, 64 бита разбиваются на две половины по 32 бита, и по-лучаются, соответственно, левый полублок L и правый полублок R.
Таблица 1.1
Блок начальной перестановки
58
50
42
34
26
18
10
2
60
52
44
36
28
20
12
4
62
54
46
38
30
22
14
6
64
56
48
40
32
24
16
8
57
49
41
33
25
17
9
1
59
51
43
35
27
19
11
3
61
53
45
37
29
21
13
5
63
55
47
39
31
23
15
7
Биты, находящиеся в правом полублоке R, подвергаются крип-тографическому преобразованию с помощью функции f(R, k), завися-щей от ключа и складываются по модулю 2 с данными из левого по-лублока. Затем данные в этих полублоках меняются местами. Эта процедура в шифре DES повторяется 16 раз.Таким образом, в общем виде раундовая функция шифрования на i-м шаге представлена на рис. 1.13.
32
Рис. 1.13. Раундовая функция i-го шага шифрования DES
На этом рисунке Li и Ri ― левый и правый полублоки, получен-
ные в результате i-й итерации, ki ― 48-битный ключ, а f ― функция
криптографического преобразования, выполняющая все подстановки,
перестановки и операцию сложения по модулю 2 с ключом. Один
цикл криптографического преобразования можно обобщенно запи-
сать следующим образом:
(Li, Ri) = (Ri–1, L i–1 + f(Ri–1, ki)).
Алгоритм криптографического преобразования функции f более
подробно рассмотрен на рис. 1.14. На этом рисунке S ― блок замен и
P ― блок перестановки, которые соответствуют эквивалентным бло-
кам, представленным на общей структурной схемы раунда шифрова-
ния, приведенной на рис. 1.5.
i k
i 1 L 
i R i L
+ f
i 1 R
33
Рис. 1.14. Раундовая функция шифрования DES с учетом
ключевой информации
На каждом раунде шифрования предыдущий правый полублок
Ri–1 становится новым левым полублоком Li, а с правым полублоком
осуществляются следующие преобразования.
 Правый полублок Ri–1 разбивается на 8 тетрад по 4 бита.
Тетрады по циклическому закону дополняются крайними битами из
соседних тетрад до 6 разрядных слов так, что получается 8 шестираз-
рядных слов, что в данной схеме обозначено как перестановка с рас-
ширением. Формально правило обработки 32 битов в операции пере-
становки с расширением отражено в табл. 1.2. Эта процедура позво-
ляет привести размер правой половины в соответствие с размером 48-
битового ключа.
Перестановка с расширением
+
i 1 L 
i R i L
+
i 1 R
Перестановка со сжатием
Ключ
Сдвиг Сдвиг
Перестановка в P-блоке
Подстановка в S-блоке
Ключ
34
Таблица 1.2
Перестановка с расширением
32
1
2
3
4
5
4
5
6
7
8
9
8
9
10
11
12
13
12
13
14
15
16
17
16
17
18
19
20
21
20
21
22
23
24
25
24
25
26
27
28
29
28
29
30
31
32
1
 Полученное после перестановки с расширением 48-разрядное слово суммируется по модулю 2 с 48 битами ключа, ко-торые выбираются по специальному списку из 56 бит ключевого мас-сива.
 После суммирования с ключом 48 бит разбиваются на 8 блоков из 6 восьмиразрядных символов, которые поступают на вход S-блока четырехразрядной подстановки, содержащего 8 видов под-становок (рис. 1.15.), причем каждый блок поступает на свой блок подстановки. Крайний левый и крайний правый биты каждого из восьми шестиразрядных символов дают сочетание от 00 до 11, кото-рое определяет номер используемой строки в блоке подстановки (табл. 1.3–1.10), а оставшиеся четыре символа определяют номер столбца. В результате подстановки каждый символ полублока заменя-ется соответствующей тетрадой из блока (S-блока) подстановки, где 48-битный вход представляет собой результат перестановки с расши-рением правого полублока. Si — блоки замен, где 32-битный выход представляет собой результат подстановки в блоке замен S. Замена осуществляется по правилам, приведенным в табл. 1.3–1.11, где каж-дому из восьми шестиразрядных символов соответствует свой блок замен: первому символу — блок S1, второму S2, и т. д. В блоке замен шестиразрядный символ заменятся десятичным числом, выбранным из соответствующей таблицы замен из соответствующей строки и столбца. Десятичные числа в таблице замен лежат в интервале от ну-ля до пятнадцати, что соответствует тетраде бит, принимающих зна-чения в интервале от 0000 до 1111. Подстановка с помощью S-блоков
35
является тем элементом DES, который реализует нелинейную опера-цию. Именно эти блоки в большей степени, чем все остальные дейст-вия определяют криптографическая стойкость шифра DES. Другие элементы алгоритма шифрования выполняют линейные операции и относительно легко поддаются анализу.
Рис. 1.15. Структура блока замен
Таблица 1.3
Блок замен S1
14
4
13
1
2
15
11
8
3
10
6
12
5
9
0
7
0
15
7
4
14
2
13
1
10
6
12
11
9
5
3
8
4
1
14
8
13
6
2
11
15
12
9
7
3
10
5
0
15
12
8
2
4
9
1
7
5
11
3
14
10
0
6
13
Таблица 1.4
Блок замен S2
15
1
8
14
6
11
3
4
9
7
2
13
12
0
5
10
3
13
4
7
15
2
8
14
12
0
1
10
6
9
11
5
0
14
7
11
10
4
13
1
5
8
12
6
9
3
2
15
13
8
10
1
3
15
4
2
11
6
7
12
0
5
14
9
Таблица 1.5
Блок замен S3
10
0
9
14
6
3
15
5
1
13
12
7
11
4
2
8
13
7
0
9
3
4
6
10
2
8
5
14
12
11
15
1
13
6
4
9
8
15
3
0
11
1
2
12
5
10
14
7
1
10
13
0
6
9
8
7
4
15
14
3
11
5
2
12
48-битовый вход
32-битовый вход
S1
S2
S3
S4
S5
S6
S7
S8
36
Таблица 1.6
Блок замен S4
7
13
14
3
0
6
9
10
1
2
8
5
11
12
4
15
13
8
11
5
6
15
0
3
4
7
2
12
1
10
14
9
10
6
9
0
12
11
7
13
15
1
3
14
5
2
8
4
3
15
0
6
10
1
13
8
9
4
5
11
12
7
2
14
Таблица 1.7
Блок замен S5
2
12
4
1
7
10
11
6
8
5
3
15
13
0
14
9
14
11
2
12
4
7
13
1
5
0
15
10
3
9
8
6
4
2
1
11
10
13
7
8
15
9
12
5
6
3
0
14
11
8
12
7
1
14
2
13
6
15
0
9
10
4
5
3
Таблица 1.8
Блок замен S6
12
1
10
15
9
2
6
8
0
13
3
4
14
7
5
11
10
15
4
2
7
12
9
5
6
1
13
14
0
11
3
8
9
14
15
5
2
8
12
3
7
0
4
10
1
13
11
6
4
3
2
12
9
5
15
10
11
14
1
7
6
0
8
13
Таблица 1.9
Блок замен S7
4
11
2
14
15
0
8
13
3
12
9
7
5
10
6
1
13
0
11
7
4
9
1
10
14
3
5
12
2
15
8
6
1
4
11
13
12
3
7
14
10
15
6
8
0
5
9
2
6
11
13
8
1
4
10
7
9
5
0
15
14
2
3
12
37
Таблица 1.10
Блок замен S8
13
2
8
4
6
15
11
1
10
9
3
14
5
0
12
7
1
15
13
8
10
3
7
4
12
5
6
11
0
14
9
2
7
11
4
1
9
12
14
2
0
6
10
13
15
3
5
8
2
1
14
7
4
10
8
13
15
12
9
0
3
5
6
11
 Результат подстановки в блоках замен S, состоящий из 32 бит, полученный в предыдущей операции, подвергается перестановке, согласно табл. 1.11.
Таблица 1.11
Блок перестановки Р-блок
16
7
20
21
29
12
28
17
1
15
23
26
5
18
31
10
2
8
24
14
32
27
3
9
19
13
30
6
22
11
4
25
 Полученные в результате перестановки биты в правом по-лублоке суммируются по модулю 2 с битами, находящимися в левом полублоке Li–1. Таким образом, получается правый полублок Ri, и на-чинается новый криптографический раунд. Всего проводится 16 ра-ундов, после чего данные в полублоке R и данные в полублоке L объ-единяются.
 Полученный после 16 раундов шифрования блок текста (64 бита) подвергается заключительной перестановке, согласно табл. 1.12. В соответствии с этой таблицей 40 бит текста становится первым битом, 8 бит становится вторым битом, 48 бит — третьим, а первый бит текста перемещается на 58 позицию и т. д.
38
Таблица 1.12
Блок заключительной перестановки
40
8
48
16
56
24
64
32
39
7
47
15
55
23
63
31
38
6
46
14
54
22
62
30
37
5
45
13
53
21
61
29
36
4
44
12
52
20
60
28
35
3
43
11
51
19
59
27
34
2
42
10
50
18
58
26
33
1
41
9
49
17
57
25
Вернемся к рассмотрению рис. 1.14. Алгоритм, который создает ключ для каждого цикла, является циклическим алгоритмом. Объем ключевого пространства в шифре DES равен 256. Будем называть ключевым массивом последовательность из 56 бит. Эта последова-тельность в каждом раунде циклически сдвигается вправо. Число по-зиций сдвига в каждом раунде определяется массивом m из 16 эле-ментов
m = {0, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1}.
Значение элемента в этом массиве соответствует числу позиций сдви-га на каждом раунде шифрования.
Ключевой массив определяется для каждой итерации в следую-щей последовательности:
 56 бит ключа K разделяются на 2 блока: левый LK1 и пра-вый RK1 по 28 бит каждый;
 производится циклический сдвиг m[1] раз блоков LK1 и RK1 для получения блоков LK2 и RK2, а затем с помощью сдвига m[2] получаются блоки LK2 и RK2 и далее по формуле
LKi+1 = m[i+1] LKi ; RKi+1 = m[i+1] RKi.
Величина сдвига m[i] зависит от номера итерации. Далее производит-ся перестановка со сжатием, согласно табл. 1.13.
39
Таблица 1.13
Блок перестановки со сжатием
14
17
11
24
1
5
3
28
15
6
21
10
23
19
12
4
26
8
16
7
27
20
13
2
41
52
31
37
47
55
30
40
51
45
33
48
44
49
39
56
34
53
46
42
50
36
29
32
Согласно этой таблице из 56 бит выбирается только 48 бит ключе-вого массива, причем 14 бит становится первым, 17 — вторым и т. д. Полученные, в результате 48 бит ключа складываются по модулю 2 в каждом раунде с 48-битовым массивом данных полублока R, получен-ным после блока перестановки с расширением (рис. 1.14).
Рассмотрим в качестве примера ситуацию, когда блок открытого текста состоит из 8 байт (64 бита). Значения цифр в этом блоке pi–1 рав-ны величинам 1, 2, 3, 4, 5, 6, 7, 8. Согласно рассмотренному выше алго-ритму обработки входного буфера открытого текста, цифры в блоке от-крытого текста разбиваются на две равные половины по 32 бита. Тогда левой половине Li–1 соответствуют байты 1, 2, 3, 4, а правой половине Ri–1 байты 5, 6, 7, 8. В алгоритме обработки предполагается, что в каж-дом раунде данные полублоков меняются местами, то новые данные в левом полублоке равны предыдущим данным, находившимся в правом полублоке:
Li = Ri–1 = {5, 6, 7, 8},
а новое значение данных в правом полублоке определяется выражением
Ri = Li–1 + f(Ri–1, ki ).
Вычислим величину Ri, согласно алгоритму обработки, представ-ленному на рис. 1.12.
До перестановки с расширением байтам 5, 6, 7, 8 соответствует строка битов вида
00000101 00000110 00000111 00001000.
После перестановки с расширением по табл. 1.2 имеем массив из 48 битов разбитых на 8 групп по 6 бит каждая:
40
000000 001010 100000 001100 000000 001110 100001 010000.
Предположим, что ключевой массив из 48 бит состоит только из нулей, тогда операция суммирования по модулю 2 блока, полученного после перестановки с расширением с 48 битами ключа, не изменит этот массив. При входе в блок замен крайний левый и крайний правый биты каждого из шестиразрядных символов дают сочетание от 00 до 11, кото-рое определяет номер используемой строки в блоке подстановки, а ос-тавшиеся четыре символа определяют номер столбца. Запишем эти шес-тиразрядные символы в виде пар чисел, где первое число соответствует номеру строки в блоке замены, а четыре средних бита (средняя тетрада) соответствует номеру столбца в таблице замен
(00), (05), (20), (06), (00), (07), (30), (08).
Тогда первой паре чисел (00) после блока замены S1 (табл. 1.3) со-ответствует число 14, а последней паре (08) после блока замены S8 (табл. 1.9) соответствует число 10. Таким образом, после таблицы замен получим следующие 8 десятичных чисел
14, 11, 13, 9, 2, 8, 6, 10.
Записывая их в шестнадцатеричной системе счисления, получим 8 ше-стнадцатеричных чисел
E, B, D, 9, 2, 8, 6, A.
Этим числам соответствует строка из 32 битов.
После блока перестановки, в соответствии с табл. 1.13, полученные биты записываются в шестнадцатеричном виде
DC9B C7C0.
Окончательно, после суммирования с битами, находящимися в ле-вом полублоке, имеем зашифрованный текст, находящийся в правом по-лублоке. Этот текст имеет следующий вид в шестнадцатеричной системе счисления:
DD99 C4C4.
Биты в левом полублоке записываются в виде
05060708.
41
1.3. Шифр ГОСТ 28147-89 (Всероссийский стандарт)
Шифр ГОСТ 28147-89 (далее будем обозначать этот шифр как шифр ГОСТ) является классическим примером итерационного блочного шифра Фейстеля с разрядностью блока данных, равной 64 бита. Объем ключевого пространства ГОСТ равен 2256. Ключевая информация представляет собой массив данных размерности 256 бит. Каждый массив из 256 бит представляется как массив из восьми 32 разрядных элементов {km}, m = 0, 1, 2, ..., 7. Таблица замен S представляет собой набор из восьми одномерных массивов {Sm}, m = 0, 1, 2, ..., 7, так называемых узлов замены, каждый из которых определяет алгоритм работы 4-разрядного блока подстановок (S-блока). На вход блока замен поступает 32 битовая последователь-ность, которая разбивается на восемь 4 битовых подпоследователь-ностей. Каждый S-блок представляет собой таблицу из шестнадцати строк, каждая из которых содержит по четыре бита заполнения в строке. Заполнение в строке представляет собой некоторую переста-новку чисел от 0 до 15. Первая 4 битовая подпоследовательность по-падает на вход первого S-блока, вторая 4 битовая подпоследователь-ность поступает на вход второго S-блока и т. д.
Пусть соответствующий S-блок представляет собой последо-вательность из 16 десятичных чисел в интервале от 0 до 15, распо-ложенных в следующем порядке: 1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12. Если на вход S-блока подается 4 битовая подпоследова-тельность, равная 0, то на его выходе будет 1. При подаче на вход S-блока 4 битовой подпоследовательности, равной 4 на выходе будет 5. Если на вход S-блока подается 4 битовая подпоследовательность, равная 12, то на выходе будет 6 и т. д. Пример реализации блока за-мен шифра ГОСТ приведен в табл. 1.14.
42
Таблица 1.14
Таблица замен шифра ГОСТ
Номер S-блока
Значение
1
4
10
9
2
13
8
0
14
6
11
1
12
7
15
5
3
2
14
11
4
12
6
13
15
10
2
3
8
1
0
7
5
9
3
5
8
1
13
10
3
4
2
14
15
12
7
6
0
9
11
4
7
13
10
1
0
8
9
15
14
4
6
12
11
2
5
3
5
6
12
7
1
5
15
13
8
4
10
9
14
0
3
11
2
6
4
11
10
0
7
2
1
13
3
6
8
5
9
12
15
14
7
13
11
4
1
3
15
5
9
0
10
14
7
6
8
2
12
8
1
15
13
0
5
7
10
4
9
2
3
14
6
11
8
12
Выходы всех восьми S-блоков объединяются в 32-битное слово. После этого слово циклически сдвигается влево (к старшим разрядам) на 11 битов. Все восемь S-блоков могут быть различными.
Более подробно структура основного шага криптопреобразова-ния шифра ГОСТ показана рис. 1.16, где di — 64-битовый блок дан-ных на i-м раунде криптопреобразования, L и R — соответственно, левый и правый 32 битовые полублоки блока di, X ― 32-разрядный ключевой массив, « + » ― операция побитового сложения по моду-лю 2.
43
Рис. 1.16. Раундовая функция шифра ГОСТ
Рис. 1.17. Раундовая функция шифра ГОСТ с учетом бло-
ка замен
R X
+
S7 S1
S0
R11
+
i d
i 1 d 
L R
L R
f
X
44
В качестве исходных данных каждый шаг криптообразования получает 64 разрядный бок данных d = (L, R) и 32 разрядный ключ X, в качестве которого используется один из элементов ключевого мас-сива km (рис. 1.17). Более подробно преобразования, осуществляемые с правой половиной R в функции f, представлены на рис. 1.17, где суммирование осуществляется по модулю 232, а R11 представляет со-бой циклический сдвиг на 11 разрядов влево.
В ходе выполнения одного шага криптопреобразования данные в правой половине блока R подвергаются следующим преобразова-ниям.
 Сложение по модулю 232 данных полублока R и ключа X.
 Разбиение результата S на восемь 4 битовых блоков, по-блочной замене по таблице замен, формированию из получившихся блоков нового значения S.
 Циклический сдвиг результата S на 11 разрядов влево.
 Поразрядное сложение по модулю 2 результата S и дан-ных, записанных в левой половине блока L.
 Данные в правой половине блока R становятся новым зна-чением элемента L, а значение результата предыдущей операции, описанной в предыдущем пункте, становится новым значением эле-мента R (рис. 1.16).
В шифре ГОСТ предусмотрено, что последовательно осуществ-ляется 32 таких раунда.
Описанный выше алгоритм функционирования называется ре-жимом простой замены, когда блоки открытого текста обрабатывают-ся независимо друг от друга. Кроме того, в шифре ГОСТ предусмот-рены режимы работы, аналогичные рассмотренным выше режимам шифра DES, которые обладают повышенной криптографической стойкостью. Шифр DES являлся прототипом для шифра ГОСТ 28147-89.
45
1.4. Поточные шифры
Структура простейшего устройства [3] для реализации поточно-го метода шифрования по битам представлена на рис. 1.18.
Рис. 1.18. Структура поточного шифра
На этом рисунке: символом + обозначена операция сложения по модулю 2, ГПСП — генератор псевдослучайной последовательно-сти, построенный обычно на вычислениях в поле Галуа GF(pm), обра-зованного делением на неприводимый многочлен степени m (разд. 3). В синхронных поточных шифрах ключ формируется независимо от входной информационной последовательности.
Стойкость криптографической системы целиком зависит от ста-тистических свойств [4] генератора псевдослучайной последователь-ности (ГПСП). Разумеется, в случае, когда используется последова-тельность истинно случайных чисел бесконечной длины, обеспечива-ется идеальная криптографическая стойкость телекоммуникационной системы передачи информации. Если псевдослучайная последова-тельность имеет небольшой период повторения, то криптографиче-
ГПСП
ГПСП
Ключ
Ключ
Открытый текст
Шифрованный текст
Шифрованный текст
Дешифрированный текст
+
+
46
ская стойкость такого шифра относительно невелика. Реальная крип-тографическая стойкость потоковых шифров зависит от конкретной реализации ГПСП. Потоковые шифры наиболее пригодны для шиф-рования непрерывных потоков данных, например, в телекоммуника-ционных сетях передачи информации.
Существуют два основных типа потоковых шифров: самосин-хронизирующиеся и синхронные. Основная идея самосинхронизи-рующихся потоковых шифров (CipherTextAutoKey) заключается в том, что внутреннее состояние генератора псевдослучайной последо-вательности является функцией фиксированного числа предшест-вующих битов шифрованного текста. Поскольку внутреннее состоя-ние зависит только от n бит шифрованного текста, генератор псевдо-случайной последовательности на приемной стороне войдет в син-хронизм с генератором псевдослучайной последовательности на пе-редающей стороне после получения определенного числа бит. С уче-том этого передача сообщений выглядит следующим образом.
Каждое сообщение предваряется случайным заголовком опре-деленной длины. Самосинхронизирующиеся потоковые шифры уяз-вимы для атак типа «воспроизведение», когда записывается достаточ-ное число бит шифрованного текста, и затем они передаются на при-емную сторону. Приемная сторона входит в состояние синхронизма, и не существует средств, чтобы определить, что эти данные искажены несанкционированным абонентом.
При использовании синхронных шифров выходные значения генератора ПСП не зависят от исходного или шифрованного текста. Основная сложность заключается в необходимости синхронизации генераторов ПСП на приемной и передающей сторонах. Если в про-цессе синхронизации неправильно принят хоть один бит, то вся по-следовательность не может быть расшифрована и необходима по-вторная синхронизация.
Наиболее часто ГПСП поточных шифров строятся на основе класса вычетов многочленов по модулю p(x) неприводимого многочлена
47
степени n, которое образует поле Галуа GF(pn) с конечным числом элементов. В этой связи необходимо рассмотреть методы практиче-ской реализации вычислений в полях многочленов.
1.4.1. Реализация вычислений в полях многочленов с по-мощью регистров с прямыми и обратными связями
Рассмотрим операцию умножения многочлена
f(x) = fn xn + fn–1 xn-1 + ... + f1 x + f0
на многочлен
h(x) = hN xN + hN–1 xN–1 + ... + h1 x + h0.
Непосредственно перемножая многочлены и приводя подобные чле-ны при одинаковых степенях, получаем:
y(x) = f(x) h(x) = yn + N xn + N + yn + N–1 xn + N–1 + ... + y1 x + y0,
где
y0 = f0 h0;
y1 = f0 h1 + f1h0;
y2 = f0 h2 + f1h1 + f2h0;
… .
Для выполнения операции умножения многочленов использу-ются схемы на основе регистров сдвига (рис. 1.19 и 1.20).
Рис. 1.19. Структурная схема устройства умножения много-членов на базе регистра сдвига
Выход
fj
fj+1
fj+2
fj–N+1
Вход
h1
h2
hN
+
+
+
T
T
T
T
h0
48
При поступлении на вход устройства первого коэффициента многочлена f(x), равного fn, на выходе появляется значение первого коэффициента произведения fn hN. В этот момент времени все ячейки регистра сдвига, куда записываются значения fj, fj + 1, fj + 2 и т. д., со-держат нули. В следующий момент времени на входе появляется зна-чение второго коэффициента fn–1, а значение fn содержится в первой ячейке регистра сдвига. На выходе устройства умножения многочле-нов появляются значения произведений fn–1 hN + fn hN–1 и так далее.
Рассмотренный выше алгоритм умножения многочленов может быть реализован на регистре сдвига (рис. 1.20) с включенными парал-лельно коэффициентами многочлена h(x). В начальном состоянии в регистре сдвига записаны нулевые значения чисел. При появлении на входе устройства значения fn происходит сложение fnh(x) с содержи-мым регистра сдвига. В результате сдвига регистра на один такт про-изводится умножение на x. После появления на входе устройства зна-чения fn–1 происходит сложение fn–1h(x) с содержимым регистра, и снова производится умножение на x.
Рис. 1.20. Структурная схема устройства умножения много-членов с параллельным включением коэффициентов многочлена
Рассмотрим операцию деления многочлена
f(x) = fn xn + fn–1 xn–1 + ... + f1 x + f0
на многочлен
Выход
h0
h1
h2
hN
+
+
+
T
T
T
T
Вход
fj
fj+1
fj+2
fj–N+1
49
h(x) = hN xN + hN–1 xN–1 + ...+ h1 x + h0.
На рис. 1.21 приведена структурная схема устройства деления многочленов на базе регистров сдвига.
Рис. 1.21. Структурная схема устройства деления
многочленов
В начальном состоянии в регистре сдвига находятся нулевые значения и выходной сигнал равен нулю для первых N сдвигов. После этого появляется первое ненулевое выходное значение равное fn (hN)–1. Процесс деления заканчивается после n сдвигов, причем на выходе формируется частное от деления многочленов, а в регистре сдвига будет находиться остаток от деления.
В качестве примера на рис. 1.22 приведено схема устройства де-ления многочлена f(x) на многочлен h(x) = x6 + x5 + x4 + x3 + 1.
Рис. 1.22. Пример деления многочленов
1.4.2. Регистры с линейными обратными связями
Общая схема регистра с линейными обратными связями приве-дена на рис. 1.23. При ненулевом начальном состоянии регистра при
fj +5
fj
fj+1
fj+2
fj +3
+
T
T
+
+
T
T
T
T
+
fj +4
Выход
fj
fj+1
fj+2
fj–N+1
Вход
hN–1
+
+
+
T
T
T
T
–h2
–h1
–h0
50
сдвиге данных, записанных в ячейках регистра, сигнал на выходе
циклически повторяется, причем период повторения зависит от того,
какой многочлен соответствует включенным обратным связям.
Рис. 1.23. Общая схема регистра с линейными обратными
связями
Обратные связи включаются путем соединения шины «Выход»
через электронные ключи «1», «х», «х2»…«хn» с соответствующими
сумматорами по модулю 2. Например, структурная схема регистра с
линейными обратными связями вида x6 + x5 + x4 + x3 + 1 совпадает
со структурной схемой деления многочленов, приведенной на
рис. 1.22.
Схемы на базе регистров с линейными обратными связями ис-
пользуются в качестве генераторов псевдослучайных последователь-
ностей, датчиков случайных чисел, модуляторов частоты или фазы
широкополосных сигналов и других устройствах. В зависимости от
вариантов включения обратной связи и начальных состояний регист-
ра сдвига на выходе устройства будут формироваться различные
формы псевдослучайных последовательностей символов. Если вклю-
ченные обратные связи соответствуют неприводимому многочлену,
то все возможные состояния регистра образуют поле многочленов
GF(2m) и число таких состояний оказывается равным q = 2m – 1, где
Выход
T T T T
1 x
2 x
n x
+ +
51
m — степень многочлена. Любое другое включение обратных связей
приводит к уменьшению числа состояний.
1.4.3. Последовательности максимальной длины
В криптографии регистры с линейными обратными связями,
имеющие период повторения последовательностей, равный 2m – 1,
используются, как генераторы псевдослучайных последовательностей
(ГПСП). При достаточно большом периоде повторения можно счи-
тать, что на выходе этих устройств значения 0 или 1 появляются неза-
висимо друг от друга с вероятностью 0,5. Такие генераторы ГПСП
реализуются на регистре с линейными обратными связями (рис. 1.23).
Рассмотрим последовательность максимальной длины на при-
мере многочлена x4 + x + 1 . Это многочлен является примитивным.
Его корень x является примитивным элементом поля GF(4), и
его степени образуют мультипликативную группу максимального по-
рядка, т. е степени примитивного элемента , где
0 = 1 и 15 = 1 однозначно соответствуют всем ненулевым элемен-
там поля GF(4).
Схема деления на многочлен x4 + x + 1 приведена на рис. 1.24.
Рис. 1.24. Структурная схема генератора последовательности
максимальной длины на основе многочлена x4 + x + 1
Заметим, что единице, сдвигаемой из ячейки старшего разряда
регистра сдвига, соответствует элемент 4, и он заменяется элементом
+1.
Другой вариант генератора последовательности максимальной
длины схемы приведен на рис. 1.25.
Выход
f j j 1 f  j N 1 f   j 2 f 
T + T T T
52
Рис. 1.25. Структурная схема генератора ПСП на основе де-
ления многочлена
Данное устройство деления многочленов также может быть ис-
пользовано в качестве генератора последовательности максимальной
длины. В этом случае форма генерируемой последовательности пол-
ностью определяется ненулевым начальным состоянием регистра.
Сдвиг влево соответствует делению на  так что единица, выходящая
из ячейки младшего разряда, дает значение –1, заменяемое эквива-
лентным значением .
1.4.4. Оценка качества последовательностей максимальной
длины
Для оценки качества генераторов псевдослучайной последова-
тельности [4] используются две группы тестов.
Графические тесты. В соответствии этим тестом строятся оп-
ределенные графические зависимости, гистограммы, и по их виду
делается вывод о свойствах тестируемой последовательности. Гисто-
грамма позволяет определить равномерность появления символов в
тестируемой последовательности, а также оценить частоту появления
конкретного символа.
Оценочные тесты. На основе оценочных тестов делается за-
ключение о степени близости статистических свойств анализируемой
и истинно случайной последовательности, например, в соответствии с
критерием 2 (хи-квадрат).
Выход
f j j 1 f 
j N 1 f   j 2 f 
T + T T T
53
Рассмотрим понятие «критерий 2». Пусть результаты n испы-
таний таковы, что их можно разбить на k интервалов. Обозначим че-
рез pi вероятность, того, что результат испытания попадает в i-й ин-
тервал, а через yi — число испытаний которые реально попали в i-й
интервал. Тогда можно написать следующее соотношение:
2
1
( )
.
k
i i
i i
y np
v
np 

 
Для оценки результата используются таблицы распределения  
К оценочным тестам относится тест на равномерность появле-
ния символов в последовательности максимальной длины. При этом
анализируется число n байт в последовательности. Один байт соот-
ветствует целому числу, находящемуся в интервале 0…255. В этой
связи определяется, сколько раз yi встречается в n испытаниях каж-
дый символ si (i = 0, 1, 2, ..., 255), после чего применяется крите-
рий 2:
255 2
0
( / 256)
.
( / 256)
i
i
y n
v
n 

 
Используется тест на равномерность распределения символов 0
и 1 в последовательности максимальной длины. Для этого подсчиты-
вается число нулей (y0) и число единиц (y1) в последовательности
символов, состоящей из n бит. Далее применяется критерий 2.
1.4.5. CRC-код
В криптографических системах для обеспечения целостности
передачи информации используется СRС-код (cyclic redundancy
check, проверка циклической суммы), выполняющий функцию аутен-
тификации содержания сообщения или документа и предназначенный
для защиты от несанкционированного изменения информации. Для
построения CRC-кода используется алгоритм вычисления контроль-
ной суммы, основанный на делении информационного многочлена на
примитивный многочлен. Популярность CRC-кода обусловлена тем,
что проверка контрольной суммы просто реализуема, легко анализи-
54
руется и позволяет обнаруживать ошибки, вызванные наличием шума в каналах передачи данных. Общая структурная схема устройства ге-нератора CRC-кода приведена на рис. 1.26.
Рис. 1.26. Структурная схема генератора CRC-кода
Исходная информационная последовательность символов пода-ется на вход устройства и эта же последовательность поступает на его выход (переключатель находится в нижнем положении). Далее пере-ключатель соединяет верхнюю шину генератора СRC-кода с выходом устройства. Таким образом, происходит считывание CRC-кода, и ка-ждый информационный блок дополняется CRC-кодом. Этот код представляет собой результат вычисления контрольной суммы (КС), основанный на делении многочленов.
Принцип вычисления КС основан на использовании свойств двоичного многочлена, в виде которого представляется исходная би-товая последовательность блока данных. При этом каждый бит такой последовательности соответствует одному из полиномиальных коэф-фициентов. Например, десятичное число 90 (1011010 в двоичной за-писи) соответствует многочлену следующего вида:
P(x) = 1·x6 + 0·x5 + 1·x4 + 1· x3+ 0·x2 + 1·x1 + 0·x0.
Выход
fj
fj+1
fj+2
fj–N+1
Вход
–h1
–h2
hN-1
+
+
+
T
T
T
T
–h0
55
Подобным же образом в виде многочлена может быть представлен любой из блоков обрабатываемых данных.
При вычислении контрольного кода по методу КС используется свойство поведения многочленов, позволяющее выполнять с ними любые арифметические действия. Контрольный код рассчитывается, как остаток от деления по модулю 2 многочлена, полученного из ис-ходной битовой последовательности на другой, заранее определѐн-ный многочлен (такой многочлен называется порождающим или примитивным):
R(x) = P(x)xr mod G(x),
где R(x) — контрольный код многочлена P(x), P(x) — исходный мно-гочлен (информационный), G(x) — порождающий многочлен, r — степень порождающего многочлена.
В качестве стандартных порождающих многочленов использу-ются следующие многочлены.
CRC-32:
G(x) = x32 + x26 + x23 + x22 + x16 + x12 + x11 + x10 + x8 + x7 + x5 +
+x4+ x2+ x+1.
CRC-24:
G(x) = x24 + x23 + x14 + x12 + x8 +1.
CRC-16:
G(x) = x16 + x15 + x2 +1.
CRC-8:
G(x) = x8 + x7 + x6 + x4 + x2 +1.
CRC-4:
G(x) = x4 + x3 + x2 + x +1.
1.4.6. Пример реализация поточного шифра
Структурная схема простейшей реализации алгоритма шифрова-ния поточным шифром приведена на рис. 1.27. На вход устройства подается информационная последовательность символов. С выхода этого устройства снимается зашифрованная последовательность сим-волов.
56
Рис. 1.27. Реализация поточного шифра
При шифровании каждый бит информационной последователь-
ности складывается по модулю 2 со случайным битом с выхода гене-
ратора псевдослучайной последовательности. Качество шифрования
оценивается методом сравнения энтропий информационного и за-
шифрованного текстов [4], поскольку после шифрования текст дол-
жен состоять из случайных наборов символов (байт) и обладать мак-
симальной энтропией.
Энтропия исходного алфавита определяется выражением
2
1
log
m
i i
i=
H(A)=p p ,
где А — множество букв алфавита, i p — вероятность появления i -й
буквы алфавита, а m — объем (количество букв) алфавита. Так, для
русского языка можно считать, что m = 32, и, если считать, что буквы
алфавита равновероятны, то H(A) = 5. Эту величину можно считать
верхней оценкой значения энтропии для текстов, написанных на рус-
ском языке.
В действительности буквы русского языка не равновероятны.
Например, буквы «о» и «а» встречаются в тексте чаще, чем буква «ф».
Это обстоятельство уменьшает значение энтропии примерно до зна-
чения H(A) = 4,35. При записи информации в текстовый файл каждая
Вход fj fj+1 fj+2 fj–N+1
x x2 xn
+
T + T + T T
1
Выход
57
буква записывается в символьном виде, где каждый символ соответ-ствует одному байту (8 бит). Если считать появление символов в по-следовательности равновероятным, то можно получить оценку для максимального значения энтропии H(A) = 8. При шифровании ин-формации поточным шифром можно считать, что происходит сумми-рование по модулю 2 каждого бита информационного текста со слу-чайной последовательностью нулей и единиц. Выходной шифрован-ный текст будет представлять собой также случайную последователь-ность нулей и единиц. При расчете энтропии такой последовательно-сти по байтам получим значение H(A) = 8. При расчете энтропии этой же последовательности по битам значение H(A) = 1.
1.4.7. Синхронный потоковый шифр RC4
С помощью синхронного потокового шифра RC4 входная ин-формация шифруется по блокам объемом по 256 бит. В этом шифре ключевая последовательность не зависит от исходного текста и пред-ставляет собой массив из 256 байт, которые принимают случайные значения в интервале от 0 до 255. Структура алгоритма включает блок замены S размерностью 8×256 бит: S0, S1, S255. Каждый байт блока за-мены описывается целым числом, принимающим значения в интерва-ле от 0 до 255. Таким образом, в блоке замен S осуществляется пере-становка чисел 0, 1, …, 255 в зависимости от ключа переменной дли-ны.
Алгоритм работы синхронного потокового шифра RC4 пред-ставлен на рис. 1.28. Для реализации этого алгоритма используются два счетчика I и J и ячейки St, Si и Sj блока замен S (рис. 1.28).
58
Рис. 1.28. Алгоритм работы синхронного потокового шифра RC4
На каждом такте работы первого счетчика I вычисляется выра-жение i = (i +1) mod 256. На каждом такте второго счетчика J вы-числяется выражение j = (j + Si) mod 256. Затем данные, находящиеся в ячейках блока замен Si и Sj, обмениваются между собой, и эта опе-рация обозначается как Si ↔ Sj. Далее вычисляется адрес ячейки бло-ка замен t = (Si + Sj) mod 256. Байт ключевой последовательности k представляет собой содержимое ячейки St блока замен k = St. Соот-ветствующий байт шифрованного текста образуется сложением байта открытого текста p с байтом ключевой последовательности k:
c = (p + k) mod 256.
Перед началом выполнения алгоритма шифрования производит-ся начальная инициализация блока замены. Ячейки блока замен за-полняются данными линейно Si = i. После начальной инициализации заполняется еще один массив, размером 256 байт, с помощью ключа ki. Если длина ключа меньше 256, то ключ повторяется необходимое
mod
mod
59
число раз. Программа инициализации выполняет следующие дейст-вия.
 Инициализируется нулевым значением счетчик j = 0.
 Осуществляется перемешивание данных в блоке замен S согласно следующему выражению: для всех i = 0, 1, 2, …, 255 вычис-ляется j = (j + Si + ki) mod 256, и ячейки блока замен Si и Sj обмени-ваются своим содержимым.
Вопросы и задания
1. Сформулируйте определение криптосистем симметричных (с сек-ретным ключом) и асимметричных (с открытым ключом).
2. На блоки какой длины разбивается открытый текст при ис-пользовании блочного шифра DES?
3. Сформулируйте определение поточного шифра.
4. Перечислите, какими свойствами обладают композиционные блочные шифры.
5. Нарисуйте блок схему конструкции Фейстеля.
6. Какому требованию должна удовлетворять функция крипто-графического преобразования в конструкции Фейстеля?
7. Какие свойства позволяют обеспечить рабочие режимы шиф-рования композиционных блочных шифров?
8. Каким требованиям должен удовлетворять генератор псевдо-случайной последовательности, входящий в структуру поточного шифра?
9. Как осуществляется проверка качества генератора псевдо-случайной последовательности по критерию хи-квадрат?
10. Нарисуйте структурные схемы, используемые для умно-жения и деления многочленов.
11. Напишите на языке высокого уровня программу шифрова-ния по алгоритму шифра DES.
60
2. Элементарные сведения о вычислениях в ко-нечных полях
2.1. Элементы теории множеств
В телекоммуникационных системах связи для защиты переда-ваемой информации от несанкционированного доступа используются криптографические системы, алгоритм работы которых основан на вычислениях в конечных полях Галуа. В этой связи необходимо на-помнить некоторые основные понятия теории множеств.
Множество считается заданным, если определено правило, по которому можно однозначно сказать принадлежит тот или иной эле-мент данному множеству или нет. Например, корректны определения: множество целых чисел, множество вещественных чисел, множество предметов в данной комнате, множество предметов красного цвета и т. д. Понятие множество — одно из наиболее абстрактных понятий в алгебре. Множество может быть конечным (состоять из конечного числа элементов), бесконечным (множество целых чисел) и даже пус-тым (не содержать ни одного элемента). Примером конечного множе-ства является любой алфавит. Например, латинский алфавит, т. е. множество букв {a, … , z} является конечным.
Без веры в то, что возможно охватить ре-альность нашими теоретическими построениями, без веры во внутреннюю гармонию нашего мира не могло быть никакой науки. Эта вера есть и все-гда остается основными мотивами всякого науч-ного творчества. А.Эйнштейн и Л.Инфельд
Эволюция физики (1938 г.)
61
Алгебраической структурой называется множество с заданными
на нем действиями. Таким образом, структура ― это набор {A, O1, O2,
..., On}, где А ― множество, а O1, O2, ..., On ― заданные на нем дейст-
вия, например, операция O1 – сложение, а операция O2 ― умножение.
Если заданы два множества А и В, то вводится понятие отобра-
жения Т. Отображение Т считается заданным (T : AB), если задано
правило, по которому для любого элемента а, принадлежащего
A (aA) , существует элемент b, принадлежащий В (bB). Понятие
отображения более общее, чем понятие функции.
Отображение Т называется биективным или взаимно-
однозначным, если для любого а, принадлежащего А (aA), сущест-
вует единственное b, принадлежащее В (bB), а также верно и об-
ратное утверждение, т. е. для любого bB существует единственное
aA, т. е. задано обратное отображение 1 T ( 1 T :B A   ).
Пусть на множестве G для каждой пары элементов a, b опреде-
лена бинарная операция, которую, например, обозначим знаком «*».
Это может быть как операция сложения, так и операция умножения,
такая, что каждой паре элементов a,bG ставится в соответствие
элемент c a *b. Такое множество называется группой, если опера-
ция «*» удовлетворяет следующим условиям.
 Замкнутость по отношению к операции «*», т. е. элемент
c a *b принадлежит множеству G (cG).
 Ассоциативность (a *b) * ca * (b * c) .
 Наличие единицы (нейтрального элемента), т. е. такого эле-
мента, что a * e  e *a  a.
 Для любого элемента а, принадлежащего множеству G, су-
ществует обратный элемент 1 a такой, что 1a *a e   .
Если операция «*» является операцией умножения, то нейтральный
элемент e 1. Для операции сложения обратный элемент является
отрицательным числом и нейтральный элемент e 0 так, что
a + 0 = 0 + a = a.
62
Если для любых двух элементов группы a * b = b * a, то группа называется коммутативной или абелевой. Если множество содержит конечное число элементов n, то группа называется конечной (группа порядка n), в противном случае группа называется бесконечной. Бес-конечная группа может быть счетной (множество целых чисел) или несчетной (множество вещественных чисел).
Кольцо R представляет собой множество с двумя определенны-ми на нем операциями, условно обозначаемыми как сложение «+» и умножение «*». В кольце должны выполняться следующие свойства.
 R является коммутативной группой по отношению к опера-ции « + »; нейтральный элемент — 0; операции « + » и « * » в кольце неравноправны.
 В кольце R обеспечивается замкнутость по отношению к операции «*».
 Существует нейтральный элемент по отношению к опера-ции «*», называемый и обозначаемый «1».
 В кольце R обеспечивается выполнение ассоциативности по отношению к операции «*», т. е. a * (b * c) = (a * b) * c.
 Обе операции должны обеспечивать выполнение свойства дистрибутивности:
а * (b + c) = ab + ac.
Рассмотрим, например, операцию вычисления по модулю цело-го числа p (остаток от деления на p). Такая операция преобразует множество целых чисел расположенных на числовой оси в порядке возрастания (..., –99, –98, ..., –2, –1, 0, 1, 2, ..., 98, 99, …) в кольцо 0, 1, …, р – 1. В этом кольце определены операции сложения, вычита-ния по модулю р и умножения по модулю р.
Пусть заданы числа р = 3, а = 5, b = 7. Эти числа преобразуются в остаток от деления на р, т. е. а = 2, b = 1. Например, с = а + b = 2 + 1 = 3. Вычисляя остаток после деления на р, получим результат с = 0. Если результат получается отрицательным, то к нему необходимо прибавить число р столько раз, сколько потребуется для
63
получения положительного результата операции. Этот результат по-
падет в кольцо 0, 1, …, р – 1. Аналогичным способом в кольце выпол-
няется и операция умножения.
Относительно обычных операций сложения и умножения мно-
жество целых чисел образует кольцо. В кольце целых чисел сложение
и умножение возможно всегда, а деление не всегда. Целое число s де-
лится на целое число r (r делит s), если s = r * a. Этот факт записыва-
ется символом r\s.
Положительное число р > 1, которое делится только на + р, – р,
1, –1 называется простым. Простых чисел бесконечно много. Доказа-
тельство этого факта дал еще Евклид.
Действительно, если предположить обратное, то существует
наибольшее простое число. Тогда, если к произведению всех простых
чисел добавить единицу, получим число, превышающее наибольшее
простое число, которое не будет делиться ни на одно из простых чи-
сел. Противоречие и доказывает неправильность предположения.
Если для большого натурального числа n количество простых
чисел обозначить, через N то можно показать, что имеется асимпто-
тическое равенство N = n/ln(n).
На практике представляют интерес простые числа вида 2 1 m  и
2 2 1
k
 . Числа вида 2 1 m  для простого числа m называются числами
Мерсенна. Числа вида 2 2 1
k
 называются числами Ферма. На сего-
дняшний день известны следующие числа Ферма: 3, 5, 17, 257, 65537.
Наименьшими простыми числами являются 2, 3, 5, 7, 11, 13, ... .
Число 1 не является простым. Не являющееся простым число называ-
ется составным. Простые числа играют важную роль при формиро-
вании криптосистем с открытым ключом.
Наибольший общий делитель двух положительных целых чисел
r и s обозначается НОД[r, s] и определяется как наибольшее положи-
тельное число, которое делит оба из них. Если НОД[r, s] = 1, то такие
числа называются взаимно простыми. В дальнейшем для краткости
будем использовать обозначение (r, s) = 1. Наименьшее общее крат-
64
ное двух положительных целых чисел r и s обозначается НОК[r, s] и
определяется как наименьшее положительное число, которое делится
на оба из них. Для каждого целого числа с и положительного числа d
найдется единственная пара целых чисел Q (частное) и s (остаток),
таких, что c = d*Q + s. Частное обозначается Q = [c/d], остаток
s = c(mod d). Вычисление остатка от сложного выражения облегчает-
ся выполнением следующих выражений:
(a + b) (mod d) = ((a mod d) + (b mod d)) mod d;
(a*b) (mod d) = ((a mod d) * (b mod d)) mod d.
Наибольший общий делитель двух заданных положительных
чисел s и t может быть вычислен с помощью итеративного примене-
ния алгоритма деления. Эта процедура известна как алгоритм Евкли-
да. Удобнее всего алгоритм Евклида записывается в матричном виде.
Введем в рассмотрение матрицу
0 1
.
1
A
Q
 
 
  
Тогда алгоритм Евклида нахождения наибольшего делителя пары чи-
сел (s, t), где s > t сводится к последовательности шагов
1 1
1
1
0 1
1
s s t
t Q t s Qt
      
      
      
 
 
, (2.1)
где остановка процесса наступает при получении нулевого остатка.
Обозначим матрицу r-го шага преобразования как
0 1
1
A
Q
r
r
 
 
  
.
Тогда окончательно имеем
11 12
11 12
21 22
( ) ;
1
n s A A s s Ar A s A t n t A A t r
    
         
     
2
2 1
;
2 1
0 1
1
s s
t Q t
    
    
    


1
1 2
;
1 2
0 1
1 n
n n
n n
s s
t Q  t
      
    
      


(2.2)
65
1
.
1
0 1
0 1 n
n n
n
s s
Q t
     
    
     


2.2. Решение диофантова уравнения первой степени на
основании алгоритма Евклида
Рассмотрим задачу целочисленного решения уравнения вида
ax – my = 1, (2.3)
где наибольший общий делитель чисел (a, m) = 1, a > 0, m > а > 0. Для
решения этой задачи можно использовать алгоритм Евклида. По-
скольку согласно (2.2),
11 12 1 sn A m A a , (2.4)
имеем 11 y  A , и 12 x  A .
2.3. Решение сравнения первой степени на основании
алгоритма Евклида
Согласно теореме Ферма — Эйлера, если (a, m) = 1, т. е. числа a
и m взаимно просты, то
m
где (m) — функция Эйлера натурального аргумента m, равна числу
положительных целых чисел меньших m и взаимно простых с m.
Для функции Эйлера справедливы следующие соотношения:
(1) = 1.
Если число p простое, то
(p) = p – 1;
(pr) = p r (p – 1).
Если числа a и b взаимно просты, т. е. (a, b) = 1, то
(ab) = (a)(b).
Для произвольного n
(n) = n(1–1/p1) (1–1/p2) ... (1–1/pk),
где p1, p2, p3, ..., pk ― все простые делители числа n.
66
Перейдем к решению сравнения первой степени, т. е. к решению уравнения
a = 1 (mod m),
где (a, m) = 1. Из теоремы Ферма следует, что
a m
следовательно, решения сравнения дается выражением
x = a (m)–1(mod m). 
Однако нахождение функции (m) — это самостоятельная и доста-точно сложная задача, если число m не простое. В этом случае для решения сравнения первой степени используется можно использовать алгоритм Евклида. В этом случае решается эквивалентное диофанто-во уравнение вида
ax – my = 1, 
где
(a, m) = 1, a > 0, m > 0.
Если вычисления проводятся по mod m, то это эквивалентно ре-шению сравнения
ax = 1 (mod m) 
Следовательно, решение сравнения является решением эквивалент-ного диофантова уравнения, и x = A12.
Вычисление по модулю большого простого числа часто исполь-зуется в криптографии, поскольку задача вычисления логарифма в поле Галуа является достаточно сложной задачей, что и определяет криптографическую стойкость систем с открытым ключом.
2.4. Проверка чисел на простоту
Простое число делится только на самого себя и на единицу. Убедиться, что число простое можно, перебирая все числа в интерва-ле от 2 до N – 1. Существуют, однако, более эффективные способы убедиться, что число N простое. Согласно малой теореме Ферма, если число N простое, то для любого целого 0 < a < N, (a, N) = 1, выполня-ется соотношение
67
aN–1 = 1 (mod N). (2.11)
Если это сравнение не выполняется, то число N составное. Проверку
условия необходимо выполнять для всех a.
К сожалению, имеются составные числа, для которых это усло-
вие выполняется. Такие числа называются числами Кармайкла. Дока-
зано, что любое число Кармайкла представимо в виде N = p1 p2 … pr ,
r > 3, где все числа pi простые и различны, причем N – 1 делится на
каждую разность pi – 1.
Из-за существования чисел Кармайкла была предложена моди-
фикация теста, называемая тестом Миллера — Рабина, которая обхо-
дит проблему составных чисел. Если N — простое число, N – 1 = 2s t,
где t нечетно, то согласно малой теореме Ферма для каждого a, тако-
го, что (a, N) = 1, хотя бы одна из скобок в произведении
1 2 2 ( 1)( 1)( 1) ( 1) 1
s t t t t N a a a a a

      (2.12)
делится на N.
Пусть N — нечетное составное число, N – 1 = 2s t, где t нечетно.
Число a называется «хорошим» для N, если нарушается одно из усло-
вий:
1) N не делится на a;
2) at = 1 (mod N) или существует целое k, 0 ≤ k < s, такое,
что
k t2 a = – 1 (mod N) .
Тогда, очевидно, что для простого числа N не существует «хороших»
чисел a.
Алгоритм, доказывающий, что число не простое.
 Выберем случайным образом число 0 < a < N, (a, N) = 1, и
проверим для этого числа условия 1) и 2), Тогда:
 Если хотя бы одно из этих условий нарушается, то число N со-
ставное;
 Если выполнены оба условия, то возвращаемся к шагу 1.
68
В [5] показано, что вероятность не определить, что число не
простое после k повторений, не превосходит 4–k, т. е. убывает доста-
точно быстро. Самое большое простое число состоит из 12 978 189
цифр.
2.5. Алгоритм быстрого возведения в степень
Для экономии времени при программной реализации вычисле-
ние выражения ax (mod p) целесообразно производить следующим об-
разом:
 Показатель степени x записывается в виде
x = x1 + 2 x2 + 4 x3 + 8 x4, + …,
где величины xi, i = 1, 2, … принадлежат полю GF(2) (двоичное
представление показателя степени). Тогда ax запишется в виде
1( 2) 2( 4) 3 ... . ax ax a x a x
Здесь каждое последующее основание является квадратом предыду-
щего.
 Процесс возведения в степень распадается на две параллель-
ные ветви. Одна — последовательно вычисляет квадраты, другая —
перемножает их в соответствии со значениями двоичных разрядов
(рис. 2.1).
Рис. 2.1. Процесс возведения в степень
В среднем число операций, необходимое для реализации этого
алгоритма, оценивается величиной 1,5 log p операций умножения (в
показателе степени примерно половина нулей, следовательно, имеем
a2
× ×
×
a4 a8 a
69
log p операций возведения в квадрат и 0,5 log p операций умноже-
ния).
2.6. Задача дискретного логарифмирования
Одним из первых способов логарифмирования является вероят-
ностный алгоритм «встречи посередине». Логарифмирование по это-
му методу осуществляется следующим образом.
Для вычисления числа x, такого, что
аx = b (mod p), (2.13)
строится база данных вида ay (mod p) для случайных чисел y, которая
сортируется. Затем для случайных чисел z таких, чтобы
НОД (z, p – 1) = 1, вычисляется bz (mod p), и сравниваются результаты
с базой данных. Поскольку поле конечное, после некоторого числа
попыток получим
ay = bz (mod p). (2.14)
Тогда, возводя обе части равенства в степень z –1 (mod p – 1), получим
ay/z = b (mod p),
т. е.
x = y/z (mod p – 1). (2.15)
Известен ускоренный вариант этого метода. Для вычисления ло-
гарифма число p – 1 раскладывается на простые множители.
p – 1 
i  pi,
Тогда задача вычисления логарифма решается на циклических груп-
пах 0, 1, ..., pi – 1 методом «встречи посередине», а значение x восста-
навливается по китайской теореме об остатках.
2.7. Китайская теорема об остатках
Любое неотрицательное целое число, не происходящее произве-
дение модулей, можно однозначно восстановить, если известны его
вычеты по этим модулям. Этот результат был известен еще в древнем
Китае и носит название китайской теоремы об остатках.
70
Теорема. Для заданного множества целых положительных m0,
m1, m2, ..., mk попарно взаимно простых чисел и множества неотри-
цательных целых чисел c0, c1, c2, ..., ck , где ci < mi , система имеет не
более одного решения в интервале 0 < c <
0
k
i
t
c .
Каждое ci рассчитывается по формуле ci = с(mod mi), где mi —
взаимно простые числа. Восстановление числа с осуществляется, со-
гласно выражению:
0
(mod )
k
i i i
i
c c N M M

  , (2.16)
где
0
k
i
i
M m

  ; Mi = M/ mi .
Числа Mi и Ni являются решениями уравнения
Mi Ni + mi ni = 1.
Здесь величины Ni и ni определяются в соответствии с алгоритмом
Евклида. Согласно китайской теореме об остатках, вычисления мож-
но производить по множеству малых попарно взаимно простых моду-
лей, а затем восстанавливать правильный результат в диапазоне от 0
до М.
2.8. Поле Галуа
Поле является математической структурой, в которой можно не
только «складывать», «вычитать» и «умножать», но и «делить». При-
мерами таких полей являются поле комплексных чисел, поле вещест-
венных чисел. Рассмотрим более подробно действия в конечном поле
целых чисел. Можно показать, что имеются поля с конечным числом
элементов. Порядком поля называется число его элементов. Поле с p
элементами называется конечным полем или полем Галуа и обознача-
ется GF(p). Можно показать, что, кольцо вычетов по модулю просто-
го числа p является полем.
71
Таблица 2.1
Таблица сложения в поле GF(5)
Операция сложения
« + »
0
1
2
3
4
0
0
1
2
3
4
1
1
2
3
4
0
2
2
3
4
0
1
3
3
4
0
1
2
4
4
0
1
2
3
Пример, в котором рассмотрим поле GF(5), операции сложения и умножения определяются табл. 2.1 и 2.2. В табл. 2.1 верхняя строка является первым слагаемым, крайний левый столбец ― вторым сла-гаемым, а результат операции сложения считывается из таблицы на пересечении строки и столбца. Аналогично в табл. 2.2 верхняя строка является первым сомножителем, крайний левый столбец —вторым сомножителем, а результат операции умножения также считывается из таблицы на пересечении строки и столбца.
Таблица 2.2
Таблица умножения в поле GF(5)
Операция умножения
«*»
0
1
2
3
4
0
0
0
0
0
0
1
0
1
2
3
4
2
0
2
4
1
3
3
0
3
1
4
2
4
0
4
3
2
1
Рассмотрим операцию деления в этом поле. Так, (1/3)*3 = 3–1 *3 = 1, из таблицы умножения видно, что 3*2 = 1, следовательно,
72
1/3 = 3–1 = 2. Таким образом, элемент 2 является обратным для эле-мента 3. Каждый ненулевой элемент поля имеет обратный. Отметим, что, например,
2*2*2*2 = 1 (mod 5),
т. е.
24 = 1.
Кроме того,
3*3*3*3 = 1 (mod 5),
т. е.
34 = 1 и 4*4*4*4 = 1 (mod 5),
Другими словами
44 = 1.
Любой ненулевой элемент a поля GF(5) в степени p – 1 равен единице ap–1 = 1.
Наименьшее поле GF(2) содержит два элемента 0 и 1. Операции сложения и умножения определяются табл. 2.3 и 2.4.
Таблица 2.3
Таблица сложения в поле GF(2)
Операция сложения « + »
0
1
0
0
1
1
1
0
Таблица 2.4
Таблица умножения в поле GF(2)
Операция умножения «*»
0
1
0
0
0
1
0
1
73
2.9. Мультипликативная структура конечных полей
Если конечное поле содержит элемент  то оно должно содер-
жать и все его степени, . Так, если поле содержит муль-
типликативный, обратный каждому ненулевой элемент, то ему при-
надлежат также Наименьшее из положительных
чисел n, для которых n = 1, называется порядком элемента . Если
порядок элемента равен n, то все элементы nразличны.
В этом случае элемент  является примитивным корнем n-й степени
из единицы. При условии, что конечное поле содержит q элементов,
элемент  называется примитивным элементом поля, если порядок
элемента  равен q – 1. Арифметика конечных полей широко исполь-
зуется в криптографии. Многие криптосистемы основаны на вычис-
лении в полях GF(р), где р — большое простое число. Чтобы увели-
чить криптографическую стойкость шифра переходят к арифметике
полей многочленов степени n, коэффициенты которых принадлежат
конечному полю GF(рn).
2.10. Кольца многочленов
Для каждого поля F имеется кольцо F(x), называемое кольцом
многочленов на F. Многочленом над полем F называется выражение
вида
1
1 1 0
0
( ) ...
п
n n i
n n i
i
f x f x f x f x f f x 


       , (2.17)
где символ х называется неопределенной переменной, а коэффициен-
ты fi принадлежат полю F. Степень многочлена обозначается deg f(x)
и определяется как индекс старшего ненулевого коэффициента. При-
веденным многочленом называется многочлен, старший коэффициент
которого fn равен единице. Два многочлена равны, если равны все их
коэффициенты.
В кольце многочленов над заданным полем сложение и умноже-
ние определяются как обычные операции сложения и умножения
многочленов:
74
( ) ( ) ( ) ;
( ) ( ) .
i
i i
i
i
i j i
i j
f x g x f g x
f x g x f g  x
  



(2.18)
Степень суммы определяется как наибольшая степень слагае-
мых. Степень произведения равна сумме степеней сомножителей. В
кольце многочленов сложение, вычитание и умножение возможно
всегда, а деление — не всегда. Многочлен s(х) делится на многочлен
r(х), или r(х) является делителем s(х), если s(х) = r(х)a(х). Ненулевой
многочлен p(x), делящийся только на p(x) и на произвольный элемент
, поля F называется неприводимым многочленом. Приведенный не-
приводимый многочлен называется простым многочленом.
Например, многочлен х4 – 2 является простым над полем рацио-
нальных чисел. Над полем вещественных чисел этот многочлен рас-
падается на произведение (x2 2)(x2 2)Над полем комплекс-
ных чисел каждый из сомножителей также не является простым.
Наибольший общий делитель двух многочленов r(х) и s(х) обо-
значается НОД[r(х), s(х)] и определяется как приведенный многочлен
наибольшей степени, делящийся оба этих многочлена. Если наиболь-
ший общий делитель двух многочленов равен 1, то они называются
взаимно простыми.
Наименьшее общее кратное двух многочленов r(х) и s(х) обо-
значается НОК[r(х), s(х)] и определяется как приведенный многочлен
наименьшей степени, делящийся на оба из них.
Рассмотрим алгоритм деления для многочленов. Для каждого
многочлена с(х) и ненулевого многочлена d(x) существует единствен-
ная пара многочленов Q(x) (частное) и s(x) (остаток), таких что
c(x) = Q(x)d(x) + s(x)
и
deg s(x) < deg d(x) < deg c(x).
Практическое вычисление частного и остатка выполняется с
помощью деления «уголком». Частное обозначается
75
Q(x) = |c(x)/d(x)|,
остаток
s(x) = c(x) (mod d(x)).
Для суммы и произведения многочленов имеются следующие
выражения:
[a(x) + b(x)] (mod d(x)) = [a(x) (mod d(x)) + b(x) (mod d(x)(mod d(x));
[a(x)b(x)] (mod d(x)) = [(a(x) (mod d(x)) (b(x) (mod d(x))] (mod d(x)).
Рассмотрим более подробно алгоритм деления многочленов, по-
скольку из него вытекает важное следствие, известное под названием
алгоритма Евклида для многочленов. Алгоритм деления «уголком»
состоит из последовательности шагов:
s(x) = Q(1)(x)t(x) + t(1) (x);
t(x) = Q(2) (x)t(1) (x) + t(2) (x);
t(1) (x) = Q(3) (x)t(2) (x) + t(3) (x); (2.19)
...
t(n–2) (x) = Q(n) (x)t(n-1) (x) + t(n) (x);
t(n–1) (x) = Q(n + 1) (x)t(n) (x),
где остановка процесса наступает при получении нулевого остатка.
Можно вычислить значение многочлена р(х) над полем F в любом
элементе  этого поля. Для этого вместо неопределенной переменной
х нужно подставить соответствующий элемент  Элемент 
называется корнем многочлена р(х), если р() = 0. Легко показать,
что в этом случае (х – ) является делителем многочлена р(х), т. е.
р(х) = (х – )Q(x). Если степень многочлена равна n, то многочлен
имеет в поле не более n корней.
Аналогично предыдущему алгоритм деления многочленов мож-
но записать в матричном виде. Введем в рассмотрение матрицу
0 1
( )
1 ( )
A x
Q x
 
 
  
.
Тогда алгоритм Евклида нахождения наибольшего делителя пары чи-
сел (s, t), где s > t сводится к последовательности шагов
76
1 1
1
1
;
( ) 0 1 ( ) ( )
( ) 1 ( ) ( ) ( ) ( ) ( )
s x s x t x
t x Q x t x s x Q x t x
      
      
             
 
 
2
2 1
2 1
;
( ) 0 1 ( )
( ) 1 ( ) ( )
s x s x
t x Q x t x
    
    
         


... (2.20)
1
1 2
1 2
;
( ) 0 1 ( )
( ) 1 ( ) ( ) n
n n
n n
s x s x
t x Q x t x 
 
 
    
    
         


1
1
,
( ) 0 1 ( )
0 1 ( ) ( ) n
n n
n
s x s x
Q x t x


    
    
         


где остановка процесса наступает при получении нулевого остатка.
Обозначим матрицу r-го шага преобразования через
0 1
( )
1 ( )
r
r
A x
Q x
 
 
  
.
Тогда окончательно
11 12
11 12
1 21 22
( ) ( ) ( ) ( ) ( ).
( ) ( ) ( )
( )
( ) ( ) ( )
n
n
r
x x x x x r s x A x A x s
s A x A s A t
 t x A x A x t
    
         
    
    (2.21)
2.11. Классы вычетов в полях многочленов
Два многочлена взаимно просты, если их наибольший общий
делитель равен единице. Классы вычетов многочленов по модулю
p(x) многочлена степени n, коэффициенты которого принадлежат по-
лю GF(p), образуют кольцо с конечным числом элементов. Класс вы-
четов многочленов по модулю p(x) неприводимого многочлена степе-
ни n образуют поле Галуа GF(pn) с конечным числом элементов pn в
случае, если p(x) нельзя представить в виде произведения многочле-
нов с коэффициентами из поля GF(p).
Совокупность корней многочлена является xq–1 – 1 совокупно-
стью всех ненулевых элементов поля GF(q). Каждый класс вычетов
по модулю многочлена f(x) степени n содержит либо 0, либо много-
член степени меньшей n. Пусть p(x) — многочлен с коэффициентами
77
из поля F. Алгебра многочленов над полем F по модулю p(x) является
полем тогда, когда многочлен p(x) неприводим, т. е. если p(x) нельзя
представить в виде произведения многочленов с коэффициентами из
поля F. Например, многочлен p(x) = x2 + 1 неприводим над полем
вещественных чисел. Поле, образованное многочленами над полем F
по модулю p(x) степени k, называется расширением поля степени k
над F. Первоначальное поле F называется основным полем. Поле мно-
гочленов над GF(p) по модулю неприводимого многочлена степени m
образуют расширение поля Галуа GF(pm) и содержит q = pm элемен-
тов. Таким образом, для любого числа q, которое является степенью
простого числа, существует поле GF(q) из q элементов. Можно пока-
зать [9], что любое конечное поле изоморфно некоторому полю Га-
луа, и отличается только выбором названий для элементов. В поле
GF(p) элемент p = 0.
2.12. Мультипликативная группа в поле многочленов
Пусть p(x) — многочлен степени m с коэффициентами из поля
GF(p), который неприводим в этом поле, и пусть — корень в рас-
ширении поля. Тогда α, α2, ..., α 1
pm образуют совокупность всех кор-
ней многочлена p(x).
Например, поле Галуа GF(24) из 24 элементов может быть обра-
зовано как поле многочленов над GF(2) по модулю x4 + x +1. Пусть
обозначает класс вычетов, который содержит x. Тогда  является
корнем многочлена x4 + x + 1 и примитивным элементом поля. Для
этого случая 15 ненулевых элементов поля приведены в табл. 2.5.
Неприводимый многочлен степени m над полем называется
примитивным, если его корнем является примитивный элемент поля
GF(qm).
78
Таблица 2.5
Форма представления элементов поля GF(24)
Степенная форма Полиномиальная форма Векторная форма
 1 
 x 
  x 
  x 
  x 
 x x 
  x x 
  x x 
  x 
  x x 
 x x 
 x x x 
  x x x 
  x x 
  x 
   
2.13. Китайская теорема об остатках для многочленов
В кольце многочленов над некоторым полем также имеется ки-
тайская теорема об остатках.
Теорема. Для заданного множества взаимно простых много-
членов m0(x), m1(x), m2(x), ..., mk(x) и множества многочленов c0(x),
c1(x), c2(x), ..., ck(x) система сравнений
ci(x) = c(x) (mod mi(x)), i = 0, 1, ..., k
имеет единственное решение
c(x) =      
0
,
k
i i i
i
c x N x M x

 mod M(x),
79
где
M(x) 
0
k
i
i
m

 ; Mi (x) = M(x) / mi (x);
а Mi (x) и Ni (x) являются решениями уравнения
Mi(x)Ni (x) + mi(x)ni (x) = 1.
Рассмотрим конечные поля Галуа образованные
 вычетами по модулю простого числа;
 остатками от деления по модулю неприводимого много-
члена.
Такие конечные поля лежат в основе криптографических систем
с открытым ключом, и знание их алгебраической структуры необхо-
димо для понимания алгоритмов шифрования информации.
Возьмем два целых числа a и b, и пусть, например, a = 4, b = 7.
При обычном сложении результат c = a + b = 11. Покажем, что тот же
результат может быть получен при вычислении в конечных полях и
восстановлении результата вычислений по китайской теореме об ос-
татках.
Пусть выбран набор из двух взаимно простых чисел m0 = 3,
m1= 5, тогда M = m0 m1 = 15 и M0 = 5, M1 = 3. Тогда a0 = 1, a1 = 4,
b0= 2, b1 = 2, с0 = 2, с1 = 1. Вычисляя, согласно алгоритму Евклида
имеем:
1 = 5N0 + 3n0;
5 = 1·3 + 2;
3 = 1· 2 + 1;
2 = 1 · 2 + 0;
N0 = –1;
1 = 3N1 + 5n1;
N1 = 2;
c = с0 N0 M0 + с1 N1 M1 = 2 · (–1) · 5 + 1 · 2 · 3 = –4 = 11 (mod 15).
Рассмотрим другой случай. Возьмем три целых числа a, b и d и
пусть, например, a = 4, b = 7, d = 5. При обычном сложении результат
c = a + b + d = 16. Покажем, что тот же результат может быть полу-
80
чен при вычислении в конечных полях и восстановлении результата вычислений по китайской теореме об остатках.
Пусть выбран набор из трех взаимно простых m0 = 3, m1 = 4, m2= 5 и M = m0 m1m2 = 60, тогда M0 = 20, M1 = 15, M2 = 12. Следо-вательно a0 = 1, a1 = 0, a2 = 4, b0 = 2, b1 = 3, b2 = 2, d0 = 2, d1 = 1, d2= 0, с0 = 4, с1 = 4, с2 = 6. Вычисляя, согласно алгоритму Евклида, имеем:
1 = 20N0 + 3n0;
20 = 6 · 3 + 2;
3 = 1 · 2 + 1;
2 = 1 · 2 + 0;
1 = 3 – 2 = 3 – (20 – 6 · 3) = –1 · 20 + 7 · 3;
N0 = –1;
1 = 15N1 + 4n1;
15 = 3 ·4 + 3;
4 = 1 · 3 + 1;
3 = 3 · 1 + 0;
1 = 4 – 3 = 4 – (15 – 3 · 4) = –1 · 15 + 4 · 4;
N1 = –1;
1 = 12N2 + 5n2;
12 = 2 · 5 + 2;
5 = 2 · 2 + 1;
2 = 2 · 1 + 0;
1 = 5 – 2 · 2 = 5 – 2 · (12 – 2 · 5) = –2 · 12 + 5 · 5;
N2 = –2;
c = с0 N0M0 + с1 N1 M1 + с2 N2 M2 =
= 4 · (–1) · 20 + 4 · (–1) · 15 + 6 · (–2) · 12 = –284 = 16 (mod 60).
Таким образом, если известны значения вычетов в кольцах по малым модулям m0, m1, m2, ..., то можно однозначно восстановить исходное число.
81
Вопросы и задания
1. Каким свойствам на множестве G должна бинарная опера-ция, чтобы это множество называлось группой?
2. Каким свойствам на множестве R должны удовлетворять, определенные на нем операции, чтобы это множество называлось кольцом?
3. Каким свойствам на множестве F должны удовлетворять, определенные на нем операции, чтобы это множество называлось по-лем?
4. Дайте определение функции Эйлера.
5. Сформулируете идею решения задачи дискретного лога-рифмирования.
6. Дайте определение неприводимого многочлена.
7. Дайте определение простого многочлена.
8. Дайте определение кольца многочленов.
9. Как образуется поле многочленов GF(2n)?
10. Сформулируйте китайскую теорему об остатках.
11. Напишите программу, реализующую алгоритм Евклида.
12. Разработайте программу решения диофантова уравнения.
13. Напишите программу решения сравнения первой степени.
14. Составьте программу вычисления функции Эйлера.
15. Напишите программу генерации простых чисел.
16. Разработайте программу решения задачи дискретного ло-гарифмирования.
17. Напишите программу восстановления числа по китайской теореме об остатках.
82
3. Криптографические системы с открытым
ключом
В [10] рассмотрен принцип построения криптосистем, не тре-бующий не только передачи ключа, но даже сохранения в тайне мето-да шифрования. Этот метод основан на вычислениях в поле Галуа. Такие шифры позволяют легко шифровать и дешифрировать текст, и их можно использовать многократно.
3.1. Криптографическая система без передачи ключей
Пусть абонентам A и B необходимо передать информацию по открытому каналу передачи (рис. 1.1). Для этой цели они выбирают достаточно большое простое число p, такое, что p – 1 разлагается на не очень большие простые множители. Если среди множителей тако-го числа нет кратных, то число p – 1 называется евклидовым. Каждый из абонентов независимо один от другого выбирает случайное число, натуральное, взаимно простое с числом p – 1. Пусть абоненты A и B случайным образом выбирают числа a, b принадлежащие полю GF(p). После этого осуществляются следующие действия.
 Абонент A находит второе число  из условия
amodpp 
причем (p) = p – 1.
Я пришел к вам как юридическое ли-цо к юридическому лицу. Вот пачка весом в три–четыре кило. Она продается и стоит миллион рублей, тот самый миллион, кото-рый вы из жадности не хотите мне подарить.
И.Ильф и Е.Петров
Золотой теленок
83
 Абонент B находит второе число  из условия
bmodp p 
причем (p) = p – 1.
Пусть абонент A посылает сообщение m абоненту B. Без огра-ничения общности, будем считать, что mp – . Процесс пере-дачи осуществляется в несколько этапов.
 Шифруется сообщение m первым ключом, и находится за-шифрованное сообщение m1 согласно выражению:
m1 = ma (mod p), mp
 Сообщение m1 отправляется абоненту B.
 Абонент B, в свою очередь, зашифровывает вновь это со-общение ключом b так, что
m2 = m1b (mod p), 0 m < p
и пересылает его обратно абоненту A.
 Абонент A, получив обратно свое дважды зашифрованное сообщение, шифрует его же в третий раз своим вторым ключом согласно выражению
m3 = m2 (mod p), 0  m3 p
и вновь отправляет его абоненту B.
 Абонент B расшифровывает это сообщение при помощи второго ключа:
m4 = m3 (mod p), 0  m4 < p.
Докажем, что m4 = m. В самом деле, из выражений для m1, m2, m3 и m4 имеем
m4 = mk (mod p),
где
k = ab (mod (p – 1))
или
k = 1 (mod (p)).
84
Поэтому m4 = m (mod p), а, так как каждое из них положительное и меньше p, m4 = m.
3.2. Алгоритмы шифрования, построенные на основе
задачи об укладке ранца
Ранцевый алгоритм, разработанный Ральфом Мерклом и Мар-тином Хеллманом, стал первым алгоритмом шифрования с открытым ключом широкого назначения. Проблема укладки ранца формулиру-ется просто. Дано множество предметов c разными весами и спраши-вается, можно ли положить некоторые из этих предметов в ранец так, чтобы его вес стал равен определенному значению? Более формально задача формулируется так: дан набор значений М1, М2, …, Мn и сум-марное значение S, требуется вычислить значения bi такие что
S = b1 М1 + b2 М2 + … + bn Мn.
Здесь bi может быть либо нулем, либо единицей. Значение bi = 1 оз-начает, что предмет Mi кладут в рюкзак, а bi = 0 — не кладут. В ос-нове алгоритма, предложенного Мерклом и Хеллманом, лежит идея шифрования сообщения на основе решения серии задач по укладке ранца. Предметы из кучи выбираются с помощью блока открытого текста, длина которого (в битах) равна количеству коэффициентов bi. При этом биты открытого текста соответствуют значениям bi, а шиф-рованный текст является полученным суммарным весом. Пример текста, зашифрованного с помощью задачи укладки ранца, показан в табл. 3.1.
Таблица 3.1
Ранцевый алгоритм шифрования
Открытый текст
1 1 1 0 0 1
0 1 0 1 1 0
0 0 0 0 0 0
0 1 1 0 0 0
Последователь-ность весов
2 3 6 13 27 52
2 3 6 13 27 52
2 3 6 13 27 52
2 3 6 13 27 52
Шифрованный текст
2 + 3 + 6 + 52 = 63
3 + 13 + 27 = 43
0 = 0
3 + 6 = 9
85
Существуют две различные задачи укладки ранца; одна из них характеризуется линейным ростом трудоемкости, а другая – как при-нято считать, нет.
В первой задаче укладки ранца используется сверхвозрастаю-щая последовательность весов. Сверхвозрастающей называется по-следовательность, в которой каждый член больше суммы всех пре-дыдущих членов. Например, последовательность {1, 3, 6, 13, 27, 52} является сверхвозрастающей, а последовательность {1, 3, 4, 9, 15, 25} — нет. Рассмотрим решение первой задачи. Возьмем в качестве текущего полный вес, который надо получить, и сравним его с весом самого тяжелого предмета в куче. Если текущий вес меньше веса данного предмета, то предмет в ранец не кладут. Если текущий вес больше или равен весу этого предмета, то он кладется в ранец. Уменьшим текущий вес на вес положенного предмета и перейдем к следующему по весу предмету в последовательности. Будем повто-рять такие шаги, пока процесс не закончится. Если текущий вес уменьшится до нуля, то решение найдено. В противном случае, нет.
Например, пусть полный вес рюкзака равен 63, а последова-тельность весов предметов равна {2, 3, 6, 13, 27, 52}. Самый боль-шой вес — 52, он меньше 63, поэтому предмет весом 52 кладется в рюкзак. Вычитаем 52 из 63 и получаем 11. Следующий наибольший вес в последовательности равен 27, он больше 11, поэтому предмет весом 27 в рюкзак не кладется. Следующий самый тяжелый предмет имеет вес 6, он меньше 11, поэтому предмет весом 6 также кладется в рюкзак. Вычитаем 6 из 11 и получаем 5. Следующий самый тяже-лый предмет имеет вес 3, он меньше 5, поэтому предмет весом 3 в рюкзак кладется. Заканчивая этот процесс, покажем, что предмет с весом 2 кладется в рюкзак, и полный вес уменьшается до 0. Это оз-начает, что решение найдено. Добавление одного предмета к после-довательности увеличивает трудоемкость поиска решения лишь на одну операцию. Алгоритм Меркла — Хеллмана базируется на опи-санном выше свойстве. Если бы этот рюкзак был бы применен для
86
шифрования по алгоритму Меркла — Хеллмана, то открытый текст, полученный из значения шифрованного текста 63, был бы равен 111001. Последовательность весов при решении задачи укладки сверхвозрастающего ранца является закрытым ключом.
Несверхвозрастающие (нормальные) рюкзаки представляют со-бой вторую задачу, для решения которой быстрый алгоритм неизвес-тен. Единственным известным методом определения предметов, по-мещаемых в рюкзак, является полный перебор возможных решений, проводимый до нахождения правильной комбинации. Самый быст-рый алгоритм, принимающий во внимание различные эмпирические правила, характеризуется экспоненциальной зависимостью от числа возможных предметов. При этом добавление к куче одного предмета удваивает трудоемкость поиска решения. Последовательность весов для задачи укладки нормального ранца является открытым ключом.
Меркл и Хеллман разработали способ преобразования первой задачи укладки сверхвозрастающего рюкзака во вторую задачу ук-ладки нормального рюкзака. Для этого используется арифметика мо-дульных операций. Создание открытого ключа по закрытому ключу осуществляется следующим образом. Для преобразования сверхвоз-растающей последовательности для укладки рюкзака в нормальную возьмем сверхвозрастающую последовательность {2, 3, 6, 13, 27, 52} и умножим все значения в последовательности на число п по модулю т. Значение модуля т должно быть больше суммы всех чисел после-довательности, например, 105. Множитель должен быть взаимно про-стым числом с модулем, например, 31. Нормальной последовательно-стью будет
2 · 31 mod 105 = 62;
3 · 31 mod 105 = 93;
6 ·31 mod 105 = 81;
13 ·31 mod 105 = 88;
27 · 31 mod 105 = 102;
52 · 31 mod 105 = 37.
87
Запись этой последовательности имеет вид {62, 93, 81, 88, 102, 37}. Для шифрования сообщение сначала разбивается на блоки, по разме-рам равные числу элементов последовательности для укладки рюкза-ка. Затем, считая, что единица указывает на присутствие элемента по-следовательности в рюкзаке, а ноль — на его отсутствие, вычисляют-ся полные веса рюкзаков. Например, если сообщение в бинарном виде выглядит как 011000 110101 101110, то шифрованным текстом будет последовательность 174, 280, 333.
Дешифрирование происходит следующим образом. Законный абонент данного сообщения знает закрытый ключ, а именно —исходную сверхвозрастающую последовательность, а также значения n и т, использованные для превращения ее в нормальную последова-тельность. Для дешифрирования сообщения абонент должен сначала определить n–1, такое что n (n–1) = 1 (mod m). Каждое значение шиф-рованного текста умножается на n–1 mod m, а затем разделяется на би-ты с помощью закрытого ключа, чтобы получить значения открытого текста. Например, если сверхвозрастающая последовательность равна {2, 3, 6, 13, 27, 52}, т равно 105, а п равно 31,то шифрованный текст имеет вид: 174, 280, 333. Следовательно, n–1 равно 61, поэтому значе-ния шифрованного текста должны быть умножены на 61 по модулю 105. Тогда получим
174 · 61 mod 105 = 9 = 3 + 6,
что соответствует 011000;
280 · 61 mod 105 = 70 = 2 + 3 + 13 + 52,
что соответствует 110101;
333 · 61 mod 105 = 48 = 2 + 6 + 13 + 27,
что соответствует 101110.
Следовательно, открытым текстом является битовая последователь-ность 011000 110101 101110.
88
3.3. Обмен сообщениями по алгоритму Диффи — Хелл-мана
Рассмотрим практическую реализацию обмена сообщениями с использованием вычислений в поле GF(p), где p — простое число. Наиболее простой метод передать сообщение m другому абоненту, заключается в следующей последовательности шагов.
 Абонент A генерирует случайное число x, такое что
(x, p – 1) = 1, вычисляет m1 = mx (mod p) и отправляет m1 абоненту B.
 Абонент B генерирует случайное число y такое, что
(y, p – 1) = 1, вычисляет m2 = (m1)y (mod p) и отправляет m2 абоненту A.
 Абонент A возводит полученное число в степень z = x–1, вычисляет m3 = (m2)z (mod p) и отправляет m3 абоненту B;
 Абонент B возводит полученное число в степень r = y–1, вычисляет m4 = (m3)r (mod p) и получает m.
Действительно,
m4 = (m3)r = ((m2)z)r = ((m1)y)z)r) = ((mx)y)z)r) = m.
Этот алгоритм обычно используется для открытого распределе-ния ключей в сеансе связи.
3.4. Обмен сообщениями по алгоритму Т. Эль-Гамаля
Алгоритм Т. Эль-Гамаля используется как для шифрования от-крытым ключом, так и для цифровой подписи. Алгоритм Т. Эль-Гамаля стал в США национальным стандартом цифровой подписи (DSS, Digital Signature Standard), затем с небольшими изменениями применен во всероссийском стандарте подписи ГОСТ Р43.10-94.
Пусть число p простое и  — примитивный корень степени p – 1 из единицы являются общими для всей сети связи. Заметим, что в общем случае  может образовывать мультипликативную группу по-рядка q < p. Абонент A генерирует случайное число xa, вычисляет
89
xa (mod )
ad  p и опубликовывает его. Аналогично, действует второй
абонент В, получается следующая таблица ключей (табл. 3.2).
Таблица 3.2
Таблица ключей
Абонент Открытый ключ Закрытый ключ
A da xa
B db xb
Пусть абонент A посылает сообщение m, 0 < m < p. Для этого
абонент A осуществляет следующую последовательность действий.
 Генерирует случайное число k, вычисляет k (mod p), затем
формирует шифрованный текст, состоящий из пары чисел (с1, с2):
с1 = k (mod p), с2 = m(dbk (mod p)
и отправляет абоненту B.
 Для дешифрирования этого сообщения абонент B вычис-
ляет
1
2 1 ( ) b (mod ) p x
b m c c p .
Покажем, что mb = m. Имеем:
1
1
1
1
( ) ( ) (mod )
( ) ( ) (mod )
( ) (1 ) .
b
b b
k p x
b b
x k k p x
k p k
m m d c p
m p
m m m
3.5. Криптографическая система с открытым ключом
RSA
Криптографическая система с открытым ключом RSA [2] осно-
вана на использовании того факта, что легко перемножить два боль-
ших простых числа, в то же время, крайне трудно разложить на мно-
жители их произведение. В результате произведение может быть ис-
пользовано в качестве элемента открытого ключа шифрования.
90
Пусть абонентам A и B необходимо передать закрытые данные по открытому каналу передачи. Тогда каждый из них, независимо один от другого, выбирает два больших простых числа, находит их произведение и функцию Эйлера от этого произведения и выбирает случайное число, меньшее вычисленного значения функции Эйлера и взаимно простое с ним. Итак,
A: p1, p2, ra = p1 p2, (ra), (a, (ra)) = 1, 0 < a < (ra),
B: q1, q2, rb = q1 q2, (rb), (b, (rb)) = 1, 0 < b < (rb).
Затем абонентам A и B становится доступной таблица, которая имеет вид
A: ra, a;
B: rb, b,
где ra — произведение двух простых чисел, которые известны только абоненту A; a — открытый ключ, доступный каждому, кто хочет пе-редать сообщение абоненту А, rb — произведение двух простых чисел, которые известны только абоненту B, b — открытый ключ, доступ-ный каждому, кто хочет передать сообщение абоненту B.
Эта таблица может быть продолжена для любого конечного числа абонентов. Каждый из абонентов находит свой закрытый ключ путем решения сравнений
ax = 1 (mod ( ra)); bx = 1 (mod ( rb)),
выбирая и  из условий:
a = 1 (mod ( ra)), 0  ra),
b = 1 (mod ( rb)), 0 < ( rb).
Полученные сведения приведены в табл. 3.3.
Таблица 3.3
Таблица ключей
Абонент
Открытые ключи
Секретные ключи
A
a, ra

B
b, rb

91
Рассмотрим подробнее процесс передачи сообщений. Пусть абонент A посылает сообщение 0 < m < rb, (при m > rb сообщение де-лят на отрезки, длиной менее rb и шифруют отрезки отдельно друг за другом) абоненту B.
 Абонент A шифрует сообщение m открытым ключом абонен-та B, который есть в телефонной книге, вычисляет
m1 = mb (mod rb), 0 < m1 < rb.
и посылает сообщение m1 абоненту B.
 Абонент B дешифрирует сообщение m1 своим секретным ключом, вычисляя
m2 = m1 (mod rb), 0 < m2 < rb.
Покажем, что m2 = m. Действительно,
m2 = mb(mod rb)
и
b = 1 (mod ( rb)),
следовательно,
m2 = m (mod rb),
но m2 и m меньше rb, тогда m2 = m.
Криптографическая система RSA является частью многих стан-дартов, например стандарта X9.44. Рассмотрим возможность реализа-ции этой системы на базе криптографической системы с открытым ключом. Криптографическая система с открытым ключом неудобна в том смысле, что получатель сообщения не знает, кто является отпра-вителем сообщения. Этого недостатка лишена приведенная ниже сис-тема.
Пусть имеется абонент B и несколько абонентов W1, W2, W3, ... . Абонент B и каждый из абонентов Wi независимо друг от друга выби-рают по два простых числа. Пусть P и Q — простые числа абонента B, pi и qi — простые числа абонентов Wi, i = 1, 2, 3, ... . Пусть абонент B произвольным образом выбирает целое число S, удовлетворяющее условиям 0 < S < (R), (S, (R)) = 1, а каждый из абонентов также случайно и независимо друг от друга выбирает число si удовлетво-
92
ряющее условиям 0 < si < (ri), (si, (ri)) = 1, i = 1, 2, 3, ... . После этого публикуется доступная всем таблица:
B : R, S;
W1 : r1, s1;
W2 : r2, s2;
…
Wi : ri, si.
Каждый из них — абонент B и абоненты Wi — находят свои секретные ключи T, ti из условий
STmod (R)), 0 T(R),
si timod ( ri)), 0  ti ri), i = 1, 2, 3, ... .
Предположим, абонент Wi собирается передать сообщение m абонен-ту B, и пусть также r = ri, t = ti, s = si и 0 < r < R. Последнее нера-венство, как будет показано ниже, существенно. Будем считать, что m < r и (m, r) = 1.
Абонент Wi шифрует сообщение m сначала своим секретным ключом:
m1 = mt (mod r), 0 < m1 < r,
а потом открытым ключом абонента В:
m2 = m1S (mod R), 0 < m2 < R.
Абонент В, получив шифрованное сообщение m2, расшифровы-вает распоряжение сначала своим секретным ключом:
m3 = m2T (mod R), 0 < m3 < R,
а потом открытым ключом абонента Wi :
m4 = m3s (mod r), 0 < m4 < r.
Покажем, что m4 = m. Из соотношений
m3 = m2T (mod R);
m2 = m1S (mod R)
следует, что
m3 = m1ST (mod R),
где
STmod (R)).
93
По теореме Эйлера
m3 = m1ST = m1 (mod R) = m1.
Аналогично
m4 = m3s (mod r) = m1s (mod r) = mst (mod r), stmod r.
Следовательно, m4 = m. Таким образом, абонент B знает, что полу-чил сообщение от абонента Wi .
3.6.Телекоммуникационные протоколы, исполь-зующие сеансовые ключи
Общепринятой криптографической техникой является шифро-вание каждого индивидуального обмена сообщениями отдельным ключом. Такой ключ называется сеансовым, так как он используется для единственного отдельного сеанса обмена информацией. Передача общего сеансового ключа в руки абонентов, обменивающихся ин-формацией, является одной из задач, которые решаются в телекомму-никационных системах.
3.6.1. Обмен ключами с помощью симметричного шиф-рования
При обмене ключами с помощью симметричного шифрования используется протокол, в котором абоненты сети А и В, получают секретный ключ от центра распределения ключей (ЦРК). Перед нача-лом работы сети с использованием указанного протокола ключи должны быть известны абонентам. В этой связи последовательность действий абонентов следующая
 Абонент А обращается к ЦРК и запрашивает сеансовый ключ для связи с абонентом В.
 Центр распределения ключей формирует случайный сеансо-вый ключ. Зашифровывается две копии ключа: одна для абонента А, а
94
другая — для абонента В. Затем с ЦРК посылается обе копии абонен-ту А.
 Абонент А расшифровывает свою копию сеансового ключа.
 Абонент А посылает абоненту В его копию сеансового ключа.
 Абонент В расшифровывает свою копию сеансового ключа.
 Абоненты А и В используют этот сеансовый ключ для безо-пасного обмена информацией.
Этот протокол основан на абсолютной надежности центра рас-пределения ключей.
Рассмотрим протоколы, которые реализованы с применением симметричного шифрования. Пусть абоненты A и B владеют общим секретным ключом kab, который применяется в симметричном шиф-ровании. Тогда для передачи нового ключа k от абонента A к абоненту B используется следующий алгоритм [5]:
A B: Ekab(k, t, B),
где Ekab ( ) — обозначение, свидетельствующее о том, что содержи-мое круглых скобок зашифровано на ключе kab, k — новый ключ, t —метка времени, B — идентификатор участника протокола B.
При односторонней аутентификация используется следующая схема протокола.
 Абонент B генерирует случайное число rb и пересылает его абоненту A.
 Абонент A пересылает абоненту B сообщение
Ekab(k, t, rb, B).
Если требуется двусторонняя аутентификация, то используется протокол следующего вида.
 Абонент B формирует случайное число rb и пересылает его абоненту A.
 Абонент A генерирует случайное число ra и пересылает або-ненту B сообщение
Ekab(k, t, ra, rb, B).
 Абонент B пересылает абоненту A сообщение Ek(ra).
95
Третий шаг позволит абоненту A убедиться в том, имеет ли он дело с абонентом B и получил ли он правильное значение ключа k.
Последний протокол можно модифицировать таким образом, чтобы в формировании нового ключа принимали участие абоненты A и B [5]. Пример такого протокола дан ниже.
 Абонент B генерирует случайное число rb и пересылает его або-ненту A.
 Абонент A генерирует случайное число ra, ключ ka и пересылает абоненту B сообщение
Ekab(ka, t, ra, rb, B).
 Абонент B генерирует ключ kb и пересылает абоненту B сооб-щение
Ekab(kb, t, ra, rb, A).
После обмена по протоколу каждый абонент по некоторой функции вычисляет общий ключ
k = f(ka, kb).
3.6.2. Обмен ключами, используя алгоритмы с открытыми ключами
Для согласования сеансового ключа абоненты А и В применяют алгоритмы с открытыми ключами, а затем используют этот сеансовый ключ для шифрования данных. Применяемые ключи абонентам А и В доступны в некоторой базе данных. Это значительно облегчает про-токол работы сети. В этом случае этот протокол имеет следующий вид.
 Абонент А получает открытый ключ абонента В из базы дан-ных.
 Абонент А генерирует случайный сеансовый ключ, зашифро-вывает его открытым ключом абонента В и посылает его абоненту В.
 Абонент В расшифровывает сообщение абонента А с помощью своего закрытого ключа.
 Абоненты А и В шифруют свой обмен информацией этим се-ансовым ключом.
96
3.6.3. Передача ключей и сообщений
Рассмотрим ситуацию, когда абоненты А и В не выполняют про-токол обмена ключами перед обменом сообщениями. В этом случае абонент А отправляет абоненту В сообщение без предварительного протокола обмена ключами.
 Абонент А генерирует случайный сеансовый ключ K и зашифровывает этим ключом сообщение М, которое представим в ви-де ЕK(М)
 Абонент А получает открытый ключ абонента В из базы данных.
 Абонент А шифрует K открытым ключом абонента В и этот шифр имеет вид ЕВ(K).
 Абонент А посылает абоненту В шифрованные сообщение ЕK(М) и сеансовый ключ ЕВ (K). Для дополнительной защиты от вскрытия абонент А подписывает передачу сообщения.
 Абонент В расшифровывает сеансовый ключ K, используя свой закрытый ключ.
 Абонент В, используя сеансовый ключ, расшифровывает сообщение от абонента А.
Подобная смешанная система употребляется чаще всего в теле-коммуникационных системах передачи информации. Ее соединяют с цифровыми подписями, метками времени и другими протоколами обеспечения безопасности.
3.6.4. Алгоритм открытого распределения ключей
Диффи — Хеллмана
Алгоритм открытого распределения ключей был изобретен в 1976 г. Абоненты А и В с помощью этого алгоритма производят гене-рацию секретного ключа. Рассмотрим этот алгоритм подробнее.
97
Абоненты А и В вместе выбирают большие простые числа п и g так, чтобы g было примитивным элементом по mod n. Абоненты А и В договариваются об их использовании по открытому каналу. Эти числа могут совместно использоваться группой абонентов. Затем выполня-ется следующий протокол:
 Абонент А выбирает случайное большое целое число х и посылает абоненту B сообщение
Х = gx mod n.
 Абонент В выбирает случайное большое целое число у и посылает абоненту A сообщение
Y = gy mod n.
 Абонент А вычисляет значение
k = Yх mod n.
 Абонент В вычисляет
k' = X y mod n.
Можно показать, что значения k, и k' равны значению gxy mod n. Несанкционированный абонент не сможет вычислить это значение, поскольку известно только n, g, X и У.
3.6.5. Алгоритм распределения ключей Диффи — Хеллмана с тремя и более абонентами
Протокол обмена ключами Диффи — Хеллмана можно расши-рить на случай с тремя и более абонентами. Рассмотрим пример трех абонентов А, B и C, которые совместное генерируют секретный ключ.
 Абонент А выбирает случайное большое целое число х и вычисляет
Х = gx mod n.
 Абонент B выбирает случайное большое целое число у и посылает абоненту C
Y = gy mod n.
98
 Абонент C выбирает случайное большое целое число z и посылает абоненту A
Z = gz mod n.
 Абонент А посылает абоненту B
Z'= Z x mod n.
 Абонент B посылает абоненту C
X' = Xy mod n.
 Абонент C посылает абоненту A
Y' = Yz mod n.
 Абонент A вычисляет закрытый ключ
k = Y'x mod n.
 Абонент B вычисляет закрытый ключ
k = Z'y mod n.
 Абонент C вычисляет закрытый ключ
k = X'z mod n.
Секретный ключ k равен gxyz mod n. Протокол распределения ключей можно расширить для четверых и более абонентов.
3.6.6. Алгоритм распределения ключей Хьюза
Этот вариант алгоритма Диффи — Хеллмана позволяет абонен-ту А генерировать ключ и послать его абоненту В.
 Абонент А выбирает случайное большое целое число х и генерирует закрытый ключ
k = gx mod n.
 Абонент B выбирает случайное большое целое число у и посылает абоненту А
Y = gy mod n.
 Абонент А посылает абоненту B
Х = Yx mod n.
 Абонент B вычисляет
z = y–1 mod (п – 1);
99
k' = Xz mod n.
Если все процедуры выполнены, то закрытый ключ k = k'.
Преимуществом этого протокола распределения ключей над ал-горитмом Диффи — Хеллманом состоит в том, что закрытый ключ k можно вычислить заранее, до взаимодействия, и абонент А может шифровать сообщения с помощью закрытого ключа k до установле-ния соединения абонента А с абонентом В. Абонент А может послать сообщение сразу множеству абонентов, а закрытый ключ передать позднее каждому по отдельности.
3.6.7. Протокол обмена зашифрованными ключами ЕКЕ
Протокол обмена зашифрованными ключами EKE (Encrypted Key Exchange) был разработан С. Белловином и М. Мерриттом. Он обеспечивает безопасность и проверку подлинности в компьютерных сетях, используя симметричные шифры и шифры с открытыми клю-чами. Общий закрытый ключ используется для шифрования генери-рованного случайным образом открытого ключа.
Пусть абоненты А и В имеют общий пароль Р. Проверка под-линности абонентов и генерирование общего сеансового ключа K. осуществляется в соответствии со следующим протоколом.
 Абонент А случайным образом генерирует пару «откры-тый ключ/закрытый ключ». Он шифрует открытый ключ K' с помо-щью симметричного шифра, используя Р в качестве ключа: Ер(K'). Абонент А посылает абоненту В сообщение
Ер(K').
 Абонент В, зная общий пароль Р, расшифровывает сооб-щение и выделяет открытый ключ K'. Затем абонент В генерирует случайный сеансовый ключ K и шифрует его открытым ключом, ко-торый он получил от абонента А. После этого, используя общий па-роль Р качестве ключа он посылает абоненту А сообщение
100
Ер(ЕK' (K)).
 Абонент А расшифровывает сообщение, получая сеансо-вый ключ K. Он генерирует случайную строку чисел RA, шифрует ее с помощью сеансового ключа K и посылает абоненту В
ЕK (RA).
 Абонент B расшифровывает сообщение, выделяя RA. Он генерирует другую случайную строку, RB, шифрует обе строки сеан-совым ключом K и посылает абоненту А результат
ЕK (RA, RB).
 Абонент А расшифровывает сообщение, получая RA и RB. Если строка RA, полученная от абонента B, является истинной, той са-мой строкой, которую он послал абоненту B на третьем этапе прото-кола, то абонент А, используя сеансовый ключ K шифрует строку RB и посылает ее абоненту В:
ЕK (RB).
 Абонент В расшифровывает сообщение и получает RB. Ес-ли строка RB полученная от абонента А является той самой строкой, которую он послал абоненту А на четвертом этапе протокола, то счи-тается что протокол завершен. Теперь оба абонента могут обмени-ваться информацией, используя сеансовый ключ K.
Весь протокол можно условно разбить на группы: с третьего по шестой этапы обеспечивает подтверждение, с третьего по пятый эта-пы доказывают абоненту А, что абонент В знает сеансовый ключ K, шестой этап доказывает абоненту В, что абонент А знает K.
Алгоритм ЕKЕ может быть реализован с использованием мно-жества алгоритмов с открытыми ключами, например алгоритмы: RSA, Эль-Гамаля, Диффи — Хеллмана.
Рассмотрим реализацию протокола обмена зашифрованными ключами ЕKЕ с помощью протокола Диффи — Хеллмана. При ис-пользовании протокола Диффи — Хеллмана сеансовый ключ K гене-рируется автоматически. Значения g и п определяются для всех або-нентов сети.
101
 Абонент А выбирает случайное число rA и посылает або-
ненту B
A mod r g n.
При использовании протокола Диффи — Хеллмана абоненту A
не нужно шифровать свое первое сообщение с помощью общего па-
роля Р.
 Пользователь B выбирает случайное число rB и вычисляет
A B mod r r K  g n.
Он генерирует случайную строку rB, затем вычисляет и посыла-
ет абоненту А сообщение зашифрованное с помощью общего пароля
Р:
( mod ), ( ). P K B
B r E g n E r
 Абонент А расшифровывает первую половину сообщения
абонента B, извлекая сообщение B mod r g n. Затем абонент А вычисля-
ет сеансовый ключ K и использует его для шифрования RB. Абонент А
генерирует другую случайную строку RA, шифрует обе строки клю-
чом K и посылает результат абоненту B.
( , ). K A B E R R
 Абонент B расшифровывает сообщение, получая rA, и rB.
Если полученная от абонента А строка rB совпадает с той, которую он
посылал абоненту А на втором этапе, абонент В он шифрует rA сеан-
совым ключом K и посылает результат абоненту А
( ). K A E R
 Абонент A расшифровывает сообщение, получая rA. Если
полученная от абонента B строка rA совпадает с той, которую он по-
сылал абоненту В на третьем этапе, протокол завершается.
Оба абонента могут обмениваться сообщениями, используя K в
качестве сеансового ключа.
102
3.7. Удостоверение подлинности
Протокол аутентификации представляет собой криптографиче-ский протокол, в ходе выполнения, которого один абонент удостове-ряется в идентичности другого абонента, использующего протокол. Протоколы аутентификации применяются достаточно часто в теле-коммуникационных системах. Например, в системе мобильной связи при включении мобильной станции (мобильного телефона) происхо-дит процедура аутентификации абонента по информации, имеющейся в SIM-карте. В любом протоколе аутентификации участвуют две сто-роны: абонент доказывающий (абонент Р) и абонент проверяющий (абонент V). Цель абонента V заключается в том, чтобы подтвердить предполагаемую идентичность абонента доказывающего Р, что он в действительно является Р, а не кем-то иным. После выполнения про-токола аутентификации абонент проверяющий должен либо принять абонента доказывающего как аутентичного, либо отвергнуть его как не соответствующего заявленной идентичности. Рассмотрим три спо-соба аутентификации.
 «Субъект знает» — абонент доказывающий обладает неко-торой информацией, которой нет у других субъектов телекоммуника-ционной системы (паролями, цифровыми кодами, закрытыми ключа-ми) и знание которой он демонстрирует в протоколах аутентифика-ции.
 «Субъект обладает» — абонент доказывающий имеет не-который физический предмет (магнитную карту, интеллектуальную карту, генератор паролей), который необходим для его участия в про-токоле аутентификации и который выполняет для него криптографи-ческие преобразования информации.
 «Субъект есть» — в протоколе проверяются некоторые признаки, характеризующие индивидуальность субъекта (биометри-ческие признаки: отпечатки пальцев, голос, рисунок радужной обо-лочки глаза и др.).
103
Криптографические протоколы реализуют первый способ. Когда абонент А подключается к телекоммуникационной сети, его опозна-ние осуществляется с помощью паролей. Абонент А вводит свой па-роль, и в телекоммуникационной сети проверяется его правильность. Таким образом, и абоненту А и телекоммуникационной сети известна некоторая закрытая информация, которую телекоммуникационная сеть запрашивает всякий раз, когда абонент А пытается подключится.
3.7.1. Удостоверение подлинности с помощью
однонаправленных функций
Для проверки паролей можно хранить, не сами значения, а хеш-функции паролей. Хеш-функция является отображением сообщения произвольной длины в строку фиксированного размера. Подробнее свойства хеш-функций рассматриваются в разд. 3.8. При этом прото-кол проверки паролей следующий
 Абонент А посылает в телекоммуникационную сеть свой пароль.
 В телекоммуникационной сети вычисляется однонаправ-ленная хеш-функция пароля.
 В телекоммуникационной сети происходит сравнение по-лученного значение хеш-функция пароля с хранящимся в памяти зна-чением хеш-функции.
Поскольку в телекоммуникационной сети не хранится таблица паролей всех абонентов, снижается угроза похищения таблицы паро-лей. Список паролей, обработанный однонаправленной функцией, не может быть расшифрован, так как однонаправленную функцию не удастся инвертировать для получения паролей.
104
3.7.2. Удостоверение подлинности с помощью открытых ключей
В телекоммуникационной сети хранятся данные об открытых ключах всех абонентов, а все абоненты хранят свои закрытые ключи. В этом случае протокол подключения имеет следующий вид.
 Из телекоммуникационной сети абоненту А посылается случайная строка.
 Абонент А шифрует эту строку своим закрытым ключом и посылает ее обратно в телекоммуникационную сеть вместе со своим именем.
 В телекоммуникационной сети из базы данных определя-ется открытый ключ абонента А, и дешифрируется сообщение.
 Если отправленная сначала и расшифрованная строки совпадают, то телекоммуникационная сеть предоставляет абоненту А доступ к системе.
Несанкционированный абонент не сможет воспользоваться за-крытым ключом абонента А, следовательно, не сможет выдать себя за абонента А. Абонент А никогда не посылает в телекоммуникацион-ную сеть свой закрытый ключ. Закрытый ключ должен быть доста-точно длинным и не должен быть мнемоническим. Он будет автома-тически обрабатываться аппаратурой абонента или программным обеспечением телекоммуникационной сети.
3.7.3 Формальный анализ протоколов проверки
подлинности и обмена ключами
Задача формирования безопасного сеансового ключа для пары абонентов привела к задаче анализа протоколов проверки подлинно-сти и обмена ключами. Существует четыре основных подхода к ана-лизу криптографических протоколов
105
 Моделирование и проверка работы протокола с использо-ванием языков описания и средств проверки, не разработанных спе-циально для анализа криптографических протоколов.
 Создание экспертных систем, позволяющих конструкто-ру протокола разрабатывать и исследовать различные сценарии.
 Выработка требований к семейству протоколов, исполь-зуя понятия «знание» и «доверие».
 Разработка формальных математических методов, осно-ванных на записи свойств криптографических систем в алгебраиче-ском виде.
3.7.4. Протокол аутентификации с нулевым
разглашением информации
Пусть абонент А обладает информацией S и должен доказать абоненту В, что эту информацию имеет.
Нулевое разглашение информации подразумевает, что в резуль-тате работы протокола интерактивной системы доказательства або-нент В не увеличит свои знания об информации S или не сможет из-влечь никакой информации о том, почему S истинно.
В ходе протокола абоненты А и В обмениваются сообщениями. Каждый из них может генерировать случайные числа и использовать их в своих вычислениях. В конце протокола абонент В должен выне-сти решение о том, является ли S истинным или ложным.
Цель абонента А всегда состоит в том, чтобы убедить абонента В в том, что S истинно, независимо от того, истинно ли оно на самом деле или нет. Цель абонента В заключается в том, чтобы вынести ре-шение, является ли S истинным или ложным.
Рассмотрим теперь примеры протоколов доказательства с ну-левым разглашением знания. В качестве первого протокола рассмот-рим решение задачи, которая называется «Задача о пещере Али-Бабы». Имеется пещера, план которой показан на рис. 3.1. Пещера
106
имеет дверь с секретом между точками С и D. Каждый, кто знает ко-да, может открыть эту дверь и пройти из С в B или наоборот. Для всех остальных оба хода пещеры ведут в тупик.
Пусть абонент А знает секрет пещеры. Он хочет доказать або-ненту В знание этого секрета, не разглашая код. Вот протокол их об-щения.
 Абонент В находится в точке E.
 Абонент А заходит в пещеру и добирается либо до точки С, либо до точки D.
 После того, как абонент А исчезает в пещере, абонент В приходит в точку F, не зная, в какую сторону пошел абонент А.
 Абонент В зовет абонента А и просит его выйти либо из левого, либо из правого коридора пещеры согласно желанию абонен-та В.
 Абонент А выполняет это, открывая при необходимости дверь, если он знает код.
 Абоненты А и В повторяют предыдущие шаги n раз.
Рис. 3.1. Задача о пещере Али-Бабы
Алгоритм повторяется столько раз, сколько требуется для того, чтобы убедить абонента В, что абонент А обладает знанием S.
107
3.7.5. Протоколы аутентификации с вероятностной
системой доказательств
В класс вероятностных доказательств включают: интерактивные
системы доказательств, доказательства с нулевым разглашением, ве-
роятностно-проверяемые доказательства и другие виды доказа-
тельств.
Рассмотрим протокол доказательства знания дискретного лога-
рифма x числа X. Задаются открытые простые числа p и q, такие, что q
делит p – 1. Задается примитивный элемент g множества GF(p). Дока-
зывающему абоненту А необходимо доказать абоненту В, что ему из-
вестна величина, такая что число x принадлежит множеству GF(p),
причем число gx = X — открытое.
 Абонент A выбирает случайное число r, вычисляет
gr = M mod p и посылает его абоненту В.
 Абонент В посылает абоненту A случайное число R при-
надлежащее множеству GF(p).
 Абонент A вычисляет число m = r + xR mod q и посылает
его абоненту В.
 Абонент В проверяет, что gm = XRM (mod p).
Этот этап протокола называется аккредитацией. Абоненты A и В
повторяют этот протокол t раз, пока абонент В не убедится, что або-
нент А знает число x.
Рассмотрим протокол аутентификации Шнорра с нулевым раз-
глашением. Пусть p и q — простые числа такие, что q делит p – 1. В
этом протоколе предлагается использовать p длиной 512 бит и q дли-
ной 140 бит. Пусть g  Zp таково, что gq = 1 (mod p), g  1. Пусть x 
Zq
и y = g x (mod p). Задача вычисления значения x по заданному зна-
чению y при известных значениях p, q и g называется задачей дис-
кретного логарифмирования. Воспользуется гипотезой о вычисли-
тельной трудности задачи дискретного логарифмирования. В качестве
закрытого ключа схемы аутентификации абонент А выбирает случай-
ное число x из {1, …, q – 1}. Далее абонент А вычисляет
108
y = g –x (mod p) и публикует открытый ключ y. Открытые ключи всех
абонентов должны публиковаться таким образом, чтобы исключалась
возможность их подмены. Запишем протокол аутентификации Шнор-
ра.
 Абонент А выбирает случайное число k из множества {1,
…, q – 1}, вычисляет r = gk (mod p) и посылает r абоненту В.
 Абонент В выбирает случайный запрос e из множества
{1, …, 2t – 1}, где t — некоторый параметр, и посылает e абоненту А
 Абонент А вычисляет s = (k + xe) (mod q) и посылает s
абоненту В.
 Абонент В проверяет соотношение r=gs ye (mod p), и ес-
ли оно выполняется, то принимает доказательство, в противном слу-
чае отвергает его.
Протокол выполняется столько раз, сколько необходимо для до-
казательства знания х.
Рассмотрим алгоритм идентификации Гиллу — Кискате. Або-
нент А обладает строкой данных, передавая которую он должен дока-
зать абоненту В доказать свою подлинность (именно он является або-
нентом А) абоненту В. Идентификация абонента А проводится по ряду
признаков строки данных. Эта битовая строка обозначается J. Она
аналогична открытому ключу. Другой открытой информацией явля-
ется показатель степени V и модуль n, где n — произведение двух
простых чисел. Закрытым ключом, которым владеет абонент А, слу-
жит число D, рассчитываемое так, чтобы
JDv = 1 (mod n).
Абонент A посылает абоненту В признаки J. Абонент А хочет
доказать абоненту В, что это именно признаки J. Для этого нужно до-
казать абоненту В, что абонент А владеет закрытым ключом D. Дока-
зательство выполняется в соответствии со следующим протоколом.
 Абонент A выбирает случайное целое число r, находя-
щееся в диапазоне от 1 до п – 1. Вычисляется Т = rv mod п и отправ-
ляется абоненту В.
109
 Абонент В выбирает случайное целое d, находящееся в диапазоне от 0 до V – 1 и посылает число d абоненту A.
 Абонент A вычисляет число C = rDd mod п и посылает его абоненту В.
 Абонент В вычисляет число Т' = Cv Jd mod n. Если Т = Т' (mod n), то абонент В убеждается в том, что абонент является подлинным. Данное равенство выполняется в соответствии с выраже-ниями
Т' = Cv Jd = (rDd )v Jd = r v (Dv J) d = r v = Т (mod п),
так как
JDv = 1 (mod n).
3.7. Хеш-функция
Хеш-функция (функция хеширования) H представляет собой отображение, на вход которого подается сообщение переменой длины M, а выходом является строка фиксированной длины H(M). Хеш-функция должна обладать следующими свойствами.
1. Хеш-функция может быть применена к аргументу любо-го размера.
2. Выходное значение хеш-функции имеет фиксированный размер.
3. Хеш-функцию H(M) достаточно просто вычислить для любого M.
4. Для любого y с вычислительной точки зрения невозмож-но найти x, такое что H(x) = y.
5. Для любого фиксированного x с вычислительной точки зрения невозможно найти z, не равное x, такое, что H(x) = H(z).
Четвертое свойство эквивалентно тому, что H является односто-ронней функцией. Пятое свойство гарантирует, что не может быть найдено другое сообщение, дающее то же значение. Это позволяет использовать H в качестве контрольной суммы для проверки целост-
110
ности передаваемого сообщения. Рассмотрим основные области ис-пользования хеш-функции.
 Защита паролей при их передаче и хранении.
 Формирование контрольных кодов MDC (Manipulation Detection Code) — кода обнаружения манипуляций с данными.
 Получение сжатого образа сообщения перед формиро-ванием электронной подписи.
Рассмотрим более подробно использование хэш-функции для формирования электронной подписи.
Пусть абоненту А необходимо послать сообщение М с элек-тронной подписью. С этой целью абонентом А выбирается два про-стых числа P и Q, вычисляет N = PQ и (N). После этого выбирается число 0 < d < (N) (открытое число) и вычисляется закрытое число с = d–1mod (N).
Для формирования электронной подписи под передаваемым со-общением M = (m1, m2, …, mn), вычисляется хеш-функция y = H(M) и число s = yc mod N, которое и является цифровой подписью под со-общением M. Абонент А передает пару сообщений (M, s). Абонент В, зная открытое число d, проверяет цифровую подпись, вычисляя хеш-функцию y1 = H(M) и w = sd mod N = y1cd mod N. Подпись является подлинной, если y1 = y.
3.8.1. Функция хеширования в стандарте DSS
Алгоритм безопасного хеширования (алгоритм формирования функции хеширования) принят в качестве стандарта США в 1992 г. и предназначен для использования совместно с алгоритмом цифровой подписи, определенным в стандарте DSS (Digital Signature Standard). Рассмотрим реализацию этого алгоритма подробнее.
Прежде всего, исходное сообщение дополняется символами так, чтобы его длина стала кратной 512 битам. При дополнении к сообще-нию добавляется единица, затем столько нулей, сколько необходимо
111
для получения сообщения, длина которого на 64 бита меньше, чем кратная 512, и затем добавляется 64-битовый код длины сообщения.
После дополнения полученная информационная последователь-ность имеет вид
p = p1, p2, ..., pm, i = 1, 2, ..., m,
где длина всех блоков равна 512 битам. Используется рекуррентный алгоритм вычисления хеш-функции последовательно по мере обра-ботки блоков.
На вход i-го основного цикла рекуррентного алгоритма хеширо-вания, который обозначен как SHAi, поступает i-й блок информацион-ной последовательности pi и результат работы предыдущего цикла SHAi –1, т. е.
SHAi = h(pi, SHAi –1).
Каждый блок pi может быть представлен как результат конкате-нации шестнадцати 32 разрядных слов (последовательного слияния разрядов каждого из 16 слов) в соответствии с выражением
pi = w1//w2// ... //w16,
где «//»— означает знак конкатенации. Тогда набор из 16 слов пол-ностью отражает информацию, содержащуюся в блоке pi. Перед нача-лом каждого цикла соответствующий блок w1, w2, ... , w16 расширяется до 80 слов по 32 разряда в каждом. Расширение происходит следую-щим образом. Пусть w1,w2, ... w16 исходный блок, а w1, w2, ... , w80 расширенный блок. При этом алгоритм расширения может быть запи-сан в виде
wj = wj для j = 1, 2, ... , 16,
wj = Rol (wj–3wj–8 wj–14wj–16) для j = 17, 18, ... , 80,
где Rol — операция циклического сдвига на один разряд влево. Пер-вые 16 слов остаются неизменными, а все остальные слова определя-ются в соответствии с последней формулой.
Инициализируются пять 32 битовых переменных следующими шестнадцатеричными постоянными числами:
112
A = 67452301, B = EFCDAB89, C = 98BADCFE, D = 10325476,
E = C3D2E1F0.
При этом первый (стартовый) цикл рекуррентного алгоритма хеши-
рования SHA0 является результатом конкатенации (слияния) этих пе-
ременных, т. е.
SHA0 = A//B//C//D//E.
Полученные пять переменных копируются в новые переменные a, b,
c, d и e соответственно.
Главный цикл вычисления хеш-функции имеет следующий вид.
 Переменная t последовательно за 80 шагов принимает
значения от 0 до 79 с шагом 1.
 На каждом шаге вычисляется вспомогательная пере-
менная temp, и изменяются переменные a, b, c, d и e согласно выра-
жениям
temp = (a << 5) + ft(b, c, d) + wt + kt;
e = d; d = c; c = b << 30; b = a; a = temp.
Здесь обозначено: << — операция циклического сдвига влево;  —
операция логического побитового «и»;  — операция логического
побитового «или»;  — операция побитового «не»;  — операция
побитового сложения по модулю 2; kt — шестнадцатеричные посто-
янные числа, определяемые по следующим формулам:
kt = 5A827999, t = 0, 1, ..., 19;
kt = 6ED9EBA1, t = 20, 21, ..., 39;
kt = 8F1BBCDC, t = 40, 41, ..., 59;
kt = CA62C1D6, t = 60, 61, ..., 79.
Функции ( , , ) t f x y z задаются следующими выражениями:
ft (x, y, z) x yxz;, t = 0, 1, ..., 19;
( , , ) ; t f x y z  xyz t = 20, 21, ..., 39; t = 60, 61, ..., 79;
( , , ) ; t f x y z  x yxz yz , t = 40, 41, ..., 59;
После окончания цикла значения a, b, c, d и e складываются по
модулю 2 с пятью 32-битовыми переменными A, B, C, D и E соответ-
ственно, и осуществляется переход к обработке следующего 512-
113
битового блока расширенного сообщения. Выходное значение хэш-функции является конкатенацией (слиянием) значений A, B, C, D и E.
3.8.2. Функция хеширования в стандарте ГОСТ Р34.11-94
В этом стандарте с помощью функция хеширования информа-ционная последовательность преобразуется в выходную последова-тельность разрядностью 256 бит. В соответствии со стандартом в ос-нове данной хеш-функции лежит алгоритм блочного кодирования ГОСТ 28147-89.
Пусть p входная информационная последовательность. После-довательность p разбивается на блоки p1, p2, ..., pm, i = 1, 2, ..., m, где длина всех блоков равна 256 битам. Последний неполный блок до-полняется до требуемого размера. Добавляются еще два 256-разрядных блока, содержащие код длины последовательности и кон-трольную сумму. Тогда рекуррентный процесс вычисления хеш-фукции H(p) может быть описан следующим образом:
GOSTi = H(pi, GOSTi–1),
где GOSTi — результат i-го цикла алгоритма преобразования; GOST0 — 256-разрядный стартовый цикл хеширования, на выбор ко-торого ограничений не накладывается; pi — очередной i-й блок вход-ной информации i = 1, 2, … m. Алгоритм вычисления функции хеши-рования GOSTi — состоит из трех частей:
 генерации четырех 256-битовых ключей;
 шифрующего преобразования, заключающегося в том, что происходит шифрование 64-битовых подслов слова X разрядности 256 бит, где X — очередной блок обрабатываемой открытой инфор-мации. Шифрование осуществляется на ключах Ki, где i = 1, 2, 3, 4 с использованием алгоритма шифрования ГОСТ 28147-89 в режиме простой замены;
 перемешивающего преобразования результата шифрования.
Рассмотрим процесс генерации ключей. Обозначим очередной 256-битовый вектор pi через X:
114
X = (b256, b255, ..., b1),
где bi выбираются из множества {0, 1}, i = 1, 2, …, 256. Этот же век-тор X можно представить и в других эквивалентных формах записи:
X = x4  x3  x2x1 =  
где xi, i = 1, 2, 3, 4 — 64-битовые вектора; j, j = 1, 2, 3, ... 16 — 32-битовые вектора; k, k = 1, 2, 3, …, 32 — 8-битовые вектора, обо-значение «» соответствует операцииконкатенации (слияния) бито-вых символов. Таким образом, 256-битовый вектор X может быть по-лучен конкатенацией (слиянием) различных битовых символов.
Обозначим через A(X) функцию вида
A(X) = (x1 x2 )  x4 x3 x2,
где xi, i = 1, 2, 3, 4 — 64-битовые вектора. Введем отображение T, ко-торое отображает вектор

в вектор
,
где функцию  можно записать в виде
i kik, ik
Перестановка элементов 256-битовой последовательности вы-полняется по формуле y = (x), где x — порядковый номер 8-битового значения в исходной последовательности; y — порядко-вый номер 8-битового значения в результирующей последовательно-сти.
Для генерации ключей необходимо использовать следующие исходные данные.
 G0 = С0 = GOST0 — 256-разрядный стартовый вектор;
 Постоянные числа Сi (i = 2, 3, 4), имеющие значения
С2 = С4 = 0256 (256 нулей),
С3 = 18 08 116 024 116 08 (08 18 )2 18 08 (08 18 )4 (18 08 )4,
где показатель степени означает число повторений соответствующей цифры. Поскольку алгоритм вычисления хеш-функции рекуррентный, для текущих значений введем обозначения G — текущее значение
115
хеш-функции, X ― очередной блок обрабатываемой открытой ин-формации. При вычислении ключей реализуется следующий алго-ритм.
1. Присвоить значения i = 1, U = G, V = X.
2. Выполнить вычисление W = U  V, Ki = T(W).
3. Увеличить счетчик i на единицу i = i + 1.
4. Проверить условие i = 5. При положительном исходе пе-рейти к седьмому шагу.
5. Выполнить вычисление
U = A(U) Сi, V = A(A(V)), W = U  V, Ki = T(W).
6. Перейти к третьему шагу.
7. Окончание вычислений.
При преобразовании осуществляется шифрование 64-битовых подслов 256-битового слова G. Для шифрующего преобразования ис-пользуется представление G в виде
G = x4  x3 x2  x1,
где xi ― 64-битовый вектор, i = 1, 2, 3, 4 и набор ключей Ki, i = 1, 2, 3, 4. После выполнения шифрования, согласно шифру ГОСТ 28147-89, получаются слова
si = Ei(xi),
где i = 1, 2, 3, 4; Ei ― функция шифрования в режиме простой заме-ны на ключе Ki. В результате получается вектор
S = s4  s3  s2  s1.
Затем осуществляется перемешивание полученной последовательно-сти с применением регистра сдвига. Исходными данными являются слова G, X и S.
Пусть отображение  преобразует слово S 
в слово S) по правилу
S
Тогда в качестве значения функции хеширования на следующем шаге принимается слово
GstepGX S))),
116
где i ― i-я степень преобразования , т. е. преобразование осущест-вляется i раз, Gstep ― значение функции хеширования на следующем шаге.
Возвращаясь к ранее введенным обозначениям, имеем
GOSTi (GOSTi – 1pipi
Процесс повторяется до тех пор, пока не будет обработана вся ин-формационная последовательность. Полученный на последнем шаге 256-битовый блок символов является значением функции хеширова-ния y = H(M) = GOSTimax, где imax ― номер последнего 256-битового блока.
3.8.3. Стандарт цифровой подписи ГОСТ Р34.10-94
Формирование цифровой подписи осуществляется в несколько этапов. На предварительном этап выбираются числа p, q и g такие, что p является простым числом, 2509 < p < 2512, либо 21020 < p < 21024; q — простым делителем числа p – 1, 2254 < q < 2256 ; g является числом порядка q, 1 < q < p – 1. Эти три числа известны группе абонентов. Выбирается закрытый ключ x, 1 ≤ x ≤ q и вычисляется открытый ключ y = gx (mod p) для проверки подписи.
Формирование электронной подписи происходит в соответствии со следующим алгоритмом.
 Вычисление значение хеш-функции H(M) от сообщения M. Если значение H(M) (mod q) = 0, то присваивается H(M) значение 02551, где 0255 является 255 кратным повторением нуля.
 Вырабатывается целое число k, 0 < k < q. Число k снимается с датчика случайных чисел.
 Вычисляется два значения r1 = gk (mod p) и r = r1 (mod q), так, что если r = 0, то осуществляется переход ко второму шагу и выраба-тывается другое значение k.
 С использованием секретного ключа x абоненты вычисляют значение
117
s = (xr + kH(M)) (mod q).
Если s = 0, то осуществляется переход ко второму шагу.
Проверка цифровой подписи возможна при наличии у абонента
открытого ключа абонента, пославшего сообщение. Пусть m — полу-
ченное сообщение. Уравнение проверки будет иметь вид
hm1 = H(m)–1(mod q);
 1 – 1   
1 mod mod . hm s r hm r  g y p q
Если r1 = r, то считается, что подпись подлинная. В самом деле
 1 – 1     1 – 1    mod mod mod mod hm s r hm hm s xr hm g y p q  g g p q 
 1( – )     1 ( )    mod mod mod mod . hm s xr hm kH m  g p q  g p q  r
Таким образом, можно удостовериться в подлинности цифровой
подписи.
3.9. Скрытый канал
Пусть абоненты А и В могут обмениваться сообщениями через
абонента С, но абонент С несанкционированно хочет получать их со-
общения. Абоненты А и В мирятся с риском возможного раскрытия,
иначе они вообще не смогут общаться, но им нужно согласовать свои
планы. Для этого им необходимо найти способ передавать информа-
цию, максимально защищенную от перехвата. Для этого нужно соз-
дать скрытый (виртуальный, содержащийся в самих открытых сооб-
щениях) канал связи при передаче по каналу открытых сообщений. С
помощью обмена подписанными сообщениями они передают инфор-
мацию, и абонент С, даже если он просматривает все сообщения, не
сможет обнаружить в открытых сообщениях наличие скрытой ин-
формации.
Рассмотрим идею организации скрытого канала, построенного
на основе алгоритма цифровой подписи. Абонент С видит, как подпи-
санные сообщения передаются туда и обратно, но реальная переда-
ваемая информация проходит незаметно для него по скрытому кана-
лу. В действительности, алгоритм скрытого канала в подписях не от-
118
личим от нормального алгоритма в подписях, по крайней мере, для абонента С. Он не только не может прочитать сообщение, передавае-мое по скрытому каналу, но у него вообще нет представления о суще-ствовании такого канала. Рассмотрим реализацию такого алгоритма.
 Абонент А создает сообщение, все равно какое.
 Используя общий с абонентом В закрытый ключ, абонент А подписывает сообщение, пряча свое скрытое сообщение в подписи.
 Абонент А посылает подписанное сообщение абоненту В и абонент С может его прочесть.
 Абонент С читает сообщение и проверяет подпись. Не об-наружив ничего подозрительного, он передает подписанное сообще-ние абоненту В.
 Абонент В проверяет подпись под сообщением, убежда-ясь, что сообщение получено от абонента А.
 Абонент В игнорирует сообщение и, используя общий с абонентом А закрытый ключ, извлекает скрытое сообщение.
3.10. Организация скрытого канала на основе подписи Эль-Гамаля
Рассмотрим организацию оригинальной подписи сообщения. Чтобы подписать сообщение М выбирается случайное число k, взаим-но простое с р – 1. Затем вычисляется
а = gk mod р,
и с помощью расширенного алгоритма Эвклида находится b из сле-дующего уравнения:
М = (ха + kb) mod (p – 1).
Подписью является пара чисел а и b. Случайное значение k яв-ляется неизвестным для несанкционированного абонента. Для про-верки подписи нужно убедиться, что
y a ab mod р = gM mod р.
119
Такой алгоритм называется подписью Эль-Гамаля . Она требует ново-го значения k, и это значение должно быть выбрано случайным обра-зом.
Рассмотрим организацию скрытого канала на основе подписи Эль-Гамаля. Сначала выбирается простое число р и два случайных числа, g и r, меньшие p. Затем вычисляется
K = gr mod р.
Открытым ключом служат K, g и р. Закрытым ключом является r. Помимо абонента А закрытый ключ r известен и абоненту В. Это чис-ло используется не только для подписи сообщения, но и в качестве ключа для отправки и чтения скрытого сообщения.
Чтобы послать скрытое сообщение М в сообщении М' числа М и р должны быть попарно взаимно простыми; кроме того, взаимно про-стыми должны быть числа М' и р – 1. Абонент А вычисляет
X = gM mod p
и решает следующее уравнение для Y (с помощью расширенного ал-горитма Эвклида):
M' = rX + MY mod (p – 1).
Подписью является пара чисел Х и Y. Абонент C может проверить подпись Эль-Гамаля. Он убеждается, что
KX XY = gM' mod p
Абонент В может восстановить скрытое сообщение. Сначала он убе-ждается, что
(gr)X XY = gM' mod p.
Если это так, то абонент В считает сообщение подлинным, затем для восстановления М он вычисляет
M = (Y –1(M' – rX)) mod (p – 1).
Например, пусть p = 11, а g = 2. Закрытый ключ r выбирает-ся равным 8. Это означает, что открытым ключом, который абонент C может использовать для проверки подписи, будет
120
gr mod p = 28 mod 11 = 3.
Чтобы отправить скрытое сообщение М = 9, используя сообще-ние М' = 5, абонент А проверяет, что 9 и 11, а также 5 и 11 попарно взаимно просты. Он также убеждается, что взаимно просты числа 9 и 11–1 = 10. Поэтому он вычисляет
Х = gM(mod р) = 29 mod 11 = 6.
Затем он решает следующее уравнение для Y:
5 = 8·6 + 9·Y mod 10.
Решая это уравнение, получим, что Y = 3, поэтому подписью служит пара чисел 6 и 3 (X и Y). Абонент B убеждается, что
(gr)X XY = gM' mod p;
(2 8)6 63 = 25 (mod 11),
поэтому он может восстановить скрытое сообщение, вычисляя
M = (Y–1(M' –rX)) mod (p – 1) = 3–1 (5 – 8·6) mod 10 = 49 mod 10 = 9.
Таким образом, непосредственно в цифровой подписи может нахо-диться скрытая информация, которую нельзя обнаружить при вери-фикации подписи. Эта идея организации скрытого канала может быть реализована и для других алгоритмов электронной цифровой подпи-си.
Вопросы и задания
1. Каким свойством обладают члены сверхвозрастающей по-следовательности?
2. Проверьте вручную на малых простых числах алгоритмы Диффи — Хеллмана и Т. Эль-Гамаля.
3. Для абонентов А и В в алгоритме RSA выберите просдые числа и определите открытые и закрытые ключи.
4. Напишите программу реализующую алгоритмы Диффи — Хеллмана и Хьюза открытого распределения ключей.
5. Напишите программу реализующую протокол обмена за-шифрованными ключами EKE
121
6. Поясните основную идею протоколов доказательства с ну-левым разглашением знания.
7. Напишите программу реализующую протокол доказатель-ства знания дискретного логарифма x числа X.
8. Напишите программу реализующую алгоритм идентифи-кации Гиллу — Кискате.
9. Дайте определение хеш-функции.
10. Напишите программу вычисления хеш-функции SHA-1.
11. Напишите программу вычисления хеш-функции ГОСТ 28147-89.
12. Напишите программу вычисления цифровой подписи по стандарту ГОСТ Р34.10-94.
13. Напишите программу организации скрытого канала на ос-нове подписи Т. Эль-Гамаля.
122
4. Защита информации в стандарте GSM
Радиосвязь по своей природе является более уязвимой для про-слушивания, чем связь по проводам. Сотовый принцип впервые был предложен лабораторией Веll Labs в США. В 1979 г. в Чикаго начала работу первая сотовая сеть в диапазоне частот 800 МГц. Благодаря высокой пропускной способности, эффективности и открытым стан-дартам GSM был выбран в качестве международного стандарта.
В стандарте GSM (Global System for Mobile Communications) с целью повышения криптографической защиты информации использу-ется алгоритм аутентификации, шифрование поточным шифром и ал-горитм генерации ключей. Для исключения несанкционированного использования ресурсов системы связи вводятся и определяются ме-ханизмы аутентификации или проверки подлинности абонента [17].
Телефонный разговор в телекоммуникационной системе стан-дарта GSM передается в цифровой форме в виде последовательности кадров. Каждый кадр передаваемой информации фактически шифру-ется своим ключом шифрования, которое обеспечивается поточным шифром.
Алгоритм генерации ключей реализован в SIM-карте абонента (Subscriber Identification Module) и используется в механизме аутенти-фикации абонента.
Вот зрелище, достойное того, чтобы на него взглянул Бог, созерцая свое творение.
Сенека Младший
123
4.1. Обеспечение безопасности передачи информации в телекоммуникационных системах стандарта GSM
Единственной гарантией надежности криптографических алго-ритмов является их абсолютная открытость, которая позволяет изу-чать алгоритмы и находить в них слабые места. Безопасность теле-коммуникационной системы стандарта GSM основана на разделении степени защиты между мобильной станцией и ее базовой приемопе-редающей станцией. Режимы защиты информации в стандарте GSM определяются несколькими рекомендациями (табл.4.1).
Таблица 4.1
Спецификации безопасности стандарта GSM
Специфи-кация
Название
Описание
GSM 02.09
Аспекты сек-ретности
Определяет характеристики безопасности, применяемые в сетях GSM.
GSM 03.21
Алгоритмы секретности
Определяет криптографиче-ские алгоритмы в системе связи
GSM 02.17
Модули под-линности або-нента (SIM)
Определяет основные харак-теристики модуля подлинно-сти абонента.
Для изучения принципов организации безопасной передачи ин-формации в системах GSM определим, как взаимодействуют между собой все участники процесса передачи данных.
4.2 Принципы взаимодействия компонентов системы
стандарта GSM
В телекоммуникационных системах передачи информации стан-дарта GSM для обеспечения связь на больших расстояниях использу-
124
ется сеть смежных радиосот [17]. В каждой соте имеется базовая приемопередающая станция BTS (Вasе Тransceiver Station), работаю-щая на выделенном для нее наборе радиоканалов, которые отличают-ся от радиоканалов, используемых в соседних сотах, чтобы избежать совпадений (рис 4.1).
Рис. 4.1. Структура сети стандарта GSM
В структуре сети стандарта GSM основной функцией базовых приемопередающих станций BTS является обеспечение передачи и приема сообщений (информации) по радиоканалу между самой BTS и мобильной станцией MS (Mobile Station, например, телефоном). Все базовые станции логически сгруппированы и управляются контрол-лером базовых станций BSC (Вase Station Controller) для передачи вы-зова при движении абонента из одной соты в другую (так называемая эстафета) и управления мощностью. Группу контроллеров BSC об-служивает коммутационный центр мобильных услуг MSC (Mobile services Switching Centre). По своему назначению он аналогичен обычному телефонному коммутатору и отвечает за идентификацию и регистрацию абонентов, маршрутизацию вызовов, за интерфейс с традиционными телефонными сетями и т. д. Он направляет вызовы в
Коммутационный центр мобильных
услуг (MSC)
Контроллер базовых станций (BSC)
BTS
BTS
BTS
MS
MS
MS
125
телефонную сеть общего пользования, цифровую сеть интегрального обслуживания и другие сети частного или общего пользования, ста-ционарные или мобильные. Коммутационный центр является свя-зующим элементом сети стандарта GSM. Он отвечает за маршрутиза-цию или коммутацию вызовов от места возникновения к месту их на-значения. Коммутационный центр мобильных услуг MSC действует так же, как интерфейс между сетью стандарта GSM, телефонной се-тью и сетями данных. Он может быть также соединен с другими ком-мутационными центрами MSC той же самой сети и с другими сетями стандарта GSM.
4.3 Аутентификация
Для исключения несанкционированного использования ресурсов системы связи определяется механизм аутентификации или проверки подлинности абонента. Аутентификация определяется с помощью ал-горитма А3. Каждому абоненту системы связи присваивается «вре-менное удостоверение личности» или временный международный идентификационный номер пользователя TMSI (Temporary Mobile Station Indentifer). Если абоненту еще не присвоен временный номер (например, при первом включении мобильной станции), идентифика-ция проводится через международный идентификационный номер IMSI (International Mobile Station Indentifer), который выдается каж-дому абоненту при его подключении к сети. После окончания проце-дуры аутентификации и начала режима шифрования временный идентификационный номер TMSI передается на мобильную станцию только в зашифрованном виде. Этот номер TMSI будет использовать-ся при всех последующих доступах к системе. Необходимая инфор-мация об абонентах хранится в базах данных оператора сети абонен-та.
Рассмотрим более подробно аутентификацию с помощью алго-ритма А3. Процедура проверки сетью подлинности абонента реализу-ется следующим образом. Если мобильная станция регистрируется в
126
данной сети впервые (рис. 4.2), то она с помощью BTS передает на коммутационный центр MSC свой IMSI.
Рис. 4.2. Алгоритм аутентификации А3
В случае, если аутентификация проводится не в первый раз, то на коммутационный центр передается идентификационный номер TMSI. Коммутационный центр мобильных услуг MSC производит поиск по IMSI или TMSI в своей базе данных и определяет ключ Ki, соответствующий данному абоненту. Коммутационный центр мо-бильных услуг MSC с помощью генератора псевдослучайных после-довательностей (ГПСП) генерирует случайное число RAND, которое передается на мобильную станцию абонента.
Мобильная станция определяет значение отклика SRES с помо-щью вычисления хэш-функции по алгоритму СОМP128, используя RAND и Ki, после чего станция отсылает этот отклик в коммутацион-
127
ный центр мобильных услуг. Центр MSC также определяет значение отклика, используя RAND и значение Ki из своей базы данных, и сравнивает полученное значение с откликом, принятым от мобильной станции. Если они совпали, то аутентификация прошла успешно. Да-лее мобильная станция и центр коммутации переходят в режим шиф-рования, в котором если мобильная станция аутентифицировалась впервые, то ей в зашифрованном виде передается номер TMSI.
Часть выходного значения идентификационного номера значе-нием отклика SRES и служит для аутентификации (32 бита), а часть (54 бита) ― для формирования ключа шифрования Kc (алгоритм А8), который используется алгоритмом шифрования поточным шифром А5. Фактически аутентификация и генерация ключа шифрования происходят одновременно. Алгоритмы A3 и A8 в большинстве случа-ев используют хеш-функцию COMP128, на вход которой подаются значения Ki и RAND. Такой подход используется как при регистра-ции в домашней сети, так и при регистрации во внешней сети. По причине секретности вычисление SRES и Kс происходит в рамках SIM-карты.
4.4. Алгоритмы аутентификации A3 и генерации ключа A8. Хеш-функция СOMР128
Алгоритмы А3 и A8 рассматриваются вместе, так как, по сути, они представляют собой один алгоритм, который одновременно про-водит аутентификацию абонента и генерацию ключа шифрования. Оба алгоритма используют одну и ту же хеш-функцию СОМP128, на вход которой поступают значения RAND и Ki, а на выходе получают-ся значения SRES и Kc (рис 4.2).
Алгоритмы аутентификации А3 и генерации ключа A8 основаны на разделении секрета мобильной станцией и базовой станцией, т.к. обеим сторонам известно значение секретного ключа Ki. Рассмотрим более подробно алгоритм аутентификации АЗ, который осуществля-ется в несколько этапов.
128
 Базовая станция с помощью генератора псевдослучайных кодов формирует случайное число RAND, которое передается на мо-бильную станцию.
 Из 128-разрядного числа RAND и 128-разрядного секрет-ного ключа Ki мобильная станция формирует 256-разрядное входное значение для хэш-функции СOMP128. Число RAND составляет младшие биты входного значения, а секретный ключ Ki ― старшие. Далее хеш-функция СОМР128 формирует выходное 128-разрядное значение, но реально используются только 96 разрядов. Старшие 32 разряда являются значением отклика SRES, а младшие 54 разряда оп-ределяют значение ключа шифрования Kс. Отклик SRES пересылает-ся базовой станции.
 Базовая станция проводит такие же операции, как и мо-бильная и сравнивает свое значение отклика со значением, принятым от мобильной станции. Если значения совпали, то считается, что мо-бильной станции известен секретный ключ Ki, и, значит, аутентифи-кация прошла удачно. После этого можно начать шифрование ин-формации, так как обе стороны будут использовать один ключ шиф-рования.
Таким образом, в результате аутентификации получается ключ шифрования Кс, который могут использовать для шифрования как мобильная, так и базовая станции.
Хеш-функция СОМР128 принимает 256-разрядное значение и формирует 128-разрядное. Работа этой функции основана на пяти таблицах различного размера, а именно: T0[0..511], T1[0..255], T2[0..127], T3[0..63] и T4[0..31]. Выходные значения этих таблиц име-ют размер 8, 7, 6, 5 и 4 бит соответственно. Формируется входной 256-битовый вектор Х, являющийся конкатенацией Ki и RAND
X = Ki // RAND. (5.1)
Этот же вектор X можно представить и в другой эквивалентной форме записи:
X = 
129
гдеk, k = 1, 2, 3, …, 32 — 8-битовые вектора. Главный цикл вычисле-ния хэш-функции может быть описан следующим образом
 Переменная i последовательно за 5 шагов принимает зна-чения от 0 до 4 с шагом 1, что соответствует использованию на каж-дом шаге другой таблицы Тi.
 На каждом шаге по i формируется внутренний цикл по вспомогательной переменной j, принимающей значения от 0 до 2i – 1 с шагом 1.
 На каждом шаге по j формируется еще один внутренний цикл по вспомогательной переменной k, принимающей значения от 0 до 24–i – 1 с шагом 1.
 На каждом шаге по k вычисляются вспомогательные пере-менные s, t, x, y согласно выражениям
s = k + j 25–i;
t = s + 24–i;
x = (s + 2t) (mod 29–i) ;
y = (2s + 
t) ( mod 29–i) ;
s = Ti[x];
t = Ti[y].
Этот процесс повторяется 9 раз, и, поскольку таблица T4 имеет выходной размер 4 бита, в итоге в массиве X оказываются 32 полу-байта, что соответствует 128-битовому выходному значению хэш-функция СОМР128
X = 
гдеk, k = 1, 2, 3, …, 32 — 4-битовые вектора.
4.5. Шифрование поточным шифром А5
Телефонный разговор [14] в формате стандарта GSM передается в виде последовательности кадров. Каждый кадр передаваемой ин-формации фактически шифруется своим ключом шифрования. Шиф-рование обеспечивается поточным шифром A5. Для шифрования ка-ждого кадра алгоритм A5 инициализируется ключом Kс, полученным
130
обычно на стадиях аутентификации алгоритмом A8, и последователь-
ным номером передаваемого кадра. Последовательный номер кадра
является открытой информацией и может быть использован для рас-
шифровывания разговора. Ключ Kс используется до следующей ау-
тентификации абонента. Разговор шифруется только на этапе переда-
чи информации между мобильной станцией MS и базовой приемопе-
редающей станцией BTS. Для установки режима шифрования BTS
передает мобильной станции команду на переход в режим шифрова-
ния. После получения команды СМС (Ciphering Mode Command) мо-
бильная станция, используя имеющийся у нее ключ Kс, приступает к
шифрованию и дешифрированию сообщений. Алгоритм A5 описан в
стандарте GSM 03.20. Этот алгоритм существует в двух модификаци-
ях А5/2 и А5/1. Алгоритм А5/1 обладает повышенной стойкостью.
Рассмотрим наиболее распространенный алгоритм А5/2. Генератор
ПСП (псевдослучайной последовательности) А5/2 состоит из трѐх ре-
гистров с линейной обратной связью [6], которые обозначим как R1,
R2 и R3. Образующие многочлены этих регистров имеют вид:
x19 + x18 + x17 + x14 + 1;
x22 + x21 + 1;
x23 + x22 + x21 + x8 + 1
соответственно.
Выходные биты снимаются со старших разрядов этих регистров
и складываются по модулю 2, образуя выходной бит генератора ПСП.
В алгоритме А5/2 используется изменяемое управление тактировани-
ем. Сдвигом регистров управляет функция majority, которая имеет
следующий вид:
majority( x1, x2, x3 ) = x1  x2  x1  x3  x2  x3 , (5.2)
где ― операция побитового сложения по модулю 2,  ― операция
«и». Результатом работы этой функции является один бит, который
определяет, какие регистры будут тактироваться (сдвигаться), а какие
нет, т. е. если бит с выхода функции совпадает со значением бита ре-
гистра на определенной позиции, то в регистре осуществляется сдвиг
131
на один такт. На вход функции majority значения x1, x2, x3 поступают значения битов с номерами 3, 7, 10 четвертого регистра R4. Обра-зующий многочлен этого регистра имеет вид
x17 + x5 + 1,
причем каждый бит отвечает за тактирование одного из трех регист-ров R1, R2 и R3. Обычно на каждом этапе тактируются два из трех ре-гистров. Регистр R4 тактируется на каждом шаге.
Вопросы и задания
1. Как осуществляется аутентификация в стандарте GSM?
2. Какие шифры используются в стандарте GSM?
3. Сравните криптостойкость различных шифров применяе-мых в стандарте GSM
4. Поясните, на каком принципе реализован генератор псев-дослучайной последовательности в шифре А5.
5. Какой период повторения регистров R1, R2 и R3?
6. Напишите программу реализующую работу регистров сдвига, применяющихся в аутентификации в стандарте GSM.
7. Напишите программу реализующую алгоритм работы функции majority в шифре A5/2.
8. Получите алгоритм работы и напишите программу шифра A5/2.
9. Получите алгоритм работы и напишите программу шифра A5/1.
132
5. Защита информации в телекоммуникационных системах стандартов UMTS и CDMA2000
Телекоммуникационные системы, использующие стандарты UMTS (Universal Mobile Telecommunications System) относятся к третьему поколению систем мобильной связи [10], называемому по-колением 3G. Для мобильной связи третьего поколения используется дециметровый диапазон частот (около 2 ГГц), и обеспечивается пере-дача данных со скоростью 2 Мбит/с. Телекоммуникационные систе-мы поколения 3G используются для видеотелефонной связи, цифро-вого сотового телевидения и др. Для телекоммуникационных систем разработаны два стандарта сетей поколения 3G: стандарт UMTS и стандарт CDMA2000. Стандарт UMTS распространѐн в основном в Европе, а стандарт CDMA2000 — в Азии и США. В принципе эти два стандарта предполагают два различных подхода к организации сетей поколения 3G. В стандарте CDMA2000 подразумевается сохранение частот и постепенный переход к новым технологиям, путѐм наращи-вания технических мощностей оператора. Стандарт UMTS является совершенно новый стандартом, в то время как разновидности стан-дарта CDMA, предложенные для поколения 3G, являются развитием уже эксплуатирующейся в мире технологии второго поколения.
Всякая человеческая голова подобна желудку: одна переваривает входящую в оную пищу, а другая от нее засоряется.
Козьма Прутков
133
5.1. Механизмы обеспечения безопасности в стандарте UMTS
В стандарте UMTS определены требования обеспечения конфи-денциальности, которые обеспечивают:
 защиту от вторжений на линии радиодоступа, обеспечивают для абонентов конфиденциальный доступ к новым услугам систем связи 3-го поколения;
 защиту от определения посторонним абонентом информа-ции о номере IMSI;
 надежную аутентификацию пользователей в сети, а также конфиденциальность передаваемой шифрованной информации.
Рассмотрим подробнее процесс аутентификация в стандарте UMTS. Идентификатором мобильной станции является международ-ный идентификационный номер подвижного абонента IMSN, или временный идентификационный номер подвижного абонента TMSN, который используется при выполнении сетью процедуры аутентифи-кации абонента.
Рис. 5.1. Аутентификация в стандарте UMTS
134
При передаче идентификационного номера подвижного абонен-та IMSN или временного идентификационного номера подвижного абонента (TMSN) на базовую станцию начинается процедура аутен-тификации. Данная процедура выполняется в два этапа (рис. 5.1).
На первом осуществляется передача вектора аутентификации (ВА) от домашней среды в сеть обслуживания. Этот вектор, содержа-щий необходимые для осуществления аутентификации параметры и основные криптографические ключи, должен быть надежно защищен от перехвата и модификации. Каждый вектор аутентификации содер-жит:
 случайное число RAND;
 ожидаемый отзыв RES;
 ключ шифрования, KШ ;
 ключ целостности, KЦ;
 параметр (метка) аутентификации сети AUTN.
Конфиденциальность и целостность передачи ВА обеспечива-ются использованием протокола MAP (Mobile Application Part). Этот протокол отвечает за секретность на прикладном уровне независимо от используемых сетевых и транспортных протоколов. Для вычисле-ния параметров вектора аутентификации используются пять односто-ронних функций f1, f2, f3, f4, f5 (рис. 5.2.). На этом рисунке обозначе-но:
 SQN (Sequence Number) порядковый номер аутентифи-кации служит для защиты от угрозы «повтор»;
 АK (Anonymity Key) ключ, используемый для шифрова-ния SQN;
 AMF (Authentication Management Field) административ-ное управляющее поле аутентификации. AMF может быть использо-вано для указания многократного шифрования;
 МАС (Message Authentication Code) код аутентифика-ции сообщения. В данном случае
135
 МАС = f1(K, AMF, SQN, RAND), где f1 является алго-ритмом формирования кода аутентификации сообщения, включающе-го K, AMF, SQN, RAND.
Рис. 5.2. Формирование вектора аутентификации
Вектор аутентификации ВА имеет вид:
ВА = RAND//RES //Kш//Kц //AUTN,
AUTN ― параметр аутентификации сети, который имеет аналитиче-скую запись
AUTN = SQN⊕AK//AMF//MAC.
На втором этапе аутентификации и ключевого соглашения сеть обслуживания выполняет процедуру «вызов ― ответ» для взаимного установления подлинности между модулем идентичности абонента USIM (UMTS Subscriber Identity Module) и телекоммуникационной се-тью. Помимо аутентификации данная процедура обеспечивает гене-рирование ключей шифрования и защиты целостности. Программные модули, отвечающие за выполнение процедур аутентификации и клю-чевого соглашения, размещены в USIM и в центре аутентификации. В них используются криптографические функции f0, ..., f5. Основные определенные для UMTS криптографические функции и алгоритмы (наряду с их назначением) приведены в табл. 5.1.
Генерирование
f1
f2 f3 f4 f5
K
AMF
SQN
RAND
MAC
RES
Kш
Kц
АK
136
Таблица 5.1
Функции безопасности в стандарте UMTS
Функция
Назначение
f0
Функция генерирования случайного числа
f1
Функция аутентификации сети
f2
Функция аутентификации абонента
f3
Функция генерирования ключа шифрования KШ
f4
Функция генерирования ключа целостности KЦ
f5
Функция генерирования ключа анонимности AK
f6
Алгоритм шифрования, предназначенный для обеспе-чения конфиденциальности данных, передаваемых между домашней средой и сетью обслуживания
f7
Алгоритм целостности, предназначенный для обеспе-чения контроля целостности данных на участке «до-машняя среда — сеть обслуживания»
f8
Алгоритм шифрования, предназначенный для шифро-вания данных, передаваемых на участке «сеть обслу-живания — мобильная станция»
f9
Алгоритм целостности, предназначенный для обеспе-чения контроля целостности данных на участке «сеть обслуживания — мобильная станция»
В схеме взаимной аутентификации сети обслуживания и модуля идентичности абонента USIM используется предварительно распреде-ленный секретный ключ K длиной 128 бит, размещаемый в USIM и в центре аутентификации домашней среды. Одним из условий обеспе-
137
чения безопасности информации в системе является использование
секретного ключа на протяжении всего срока службы USIM. Функция
f0 генерирования случайного числа RAND локально размещается в
центре аутентификации домашней среды. Немаловажно, чтобы значе-
ние RAND также не повторялось в течение срока службы USIM. В
противном случае, зная значение RAND, использованное в одном из
предшествующих сеансов связи, теоретически возможно восстановить
отклик RES, что повлечет за собой нарушение конфиденциальности
передаваемой информации.
Процедура аутентификации и ключевого соглашения поначалу
инициируется сетью обслуживания, которая передает на мобильную
станцию сообщение вызова, содержащее случайное число RAND и
символ установления подлинности AUTN. Суть этой процедуры за-
ключается в установлении подлинности вызова, получаемого МS, ко-
торый в действительности можно сгенерировать, зная секретный ключ
K. С учетом имеющихся ограничений на время установления соеди-
нения выбрана процедура аутентификации и ключевого соглашения с
вызовом и ответом при использовании кодов аутентификации. Это
решение позволило минимизировать вычислительные затраты, что
важно, поскольку функции f1 и f2 выполняются в модуле идентично-
сти абонента USIM. Схема взаимной аутентификации системы UMTS
основана на процедуре, описанной в [11].
Получив вызов, модуль идентичности абонента USIM проверяет
подлинность сети. Это осуществляется путем вычисления значения
AUTN'  f (K,SQN, RAND) . Далее в модуле идентичности абонента
USIM сравниваются значения AUTN' и AUTN (последнее получено в
составе вектора аутентификации). В случае их равенства подлинность
сети считается установленной. Затем вычисляется ожидаемый отзыв
RES с использованием функции f2 в модуле идентичности абонента
USIM. В этом случае RES f 2(K,RAND) , который необходим для по-
лучения мобильной станцией доступа в сеть. Одновременно вычис-
138
ляются ключи шифрования KШ и обеспечения целостности KЦ (табл. 5.1):
KШ = f2 (K, RAND); KЦ = f4 (K, RAND).
После выполнения этих процедур в сети обслуживания сравни-ваются значения RES с RES′, которые также содержится в векторе ау-тентификации (рис. 5.1). Подлинность оборудования пользователя считается установленной, если RES = RES′. В процессе аутентифи-кации и ключевого соглашения может использоваться ключ аноним-ности АК, генерируемый с помощью функции f5:
АК = f5 (K, RAND).
Этот ключ необходим для сокрытия значения SQN, являющегося составной частью вектора аутентификации. Сокрытие SQN, услож-няющее несанкционированное отслеживание местоположения або-нента [10], реализуется суммированием по модулю 2 самого значения SQN со значением ключа АK (табл. 5.1). Очевидно, функция f5 в дан-ном случае должна выполняться раньше, чем функция f1. Конфиден-циальность информационного обмена в стандарте UMTS, обеспечива-ется на участке между мобильной станцией и базовой станцией и воз-лагается на функцию шифрования f8, описанную в [14] как симмет-ричный потоковый шифр. При этом из базовой сети передается ключ шифрования, который после аутентификации используется базовой сетью и оборудованием абонента совместно.
В архитектуре безопасности предусматривается опция выбора из 16 различных алгоритмов шифрования. Указатель на используемый алгоритм содержится в идентификаторе алгоритма шифрования (UEA). Стандартный алгоритм обозначен UEA1, а «пустой алгоритм», соответствующий отсутствию шифрования — UEA0. Криптографиче-ское ядро построено на базе шифра KASUMI [13], симметричного блочного шифра на основе конструкции Фейстеля (см. разд. 2). Раз-мер шифруемого блока данных равен 64, а длина ключа шифрования 128 бит. Шифр KASUMI функционирует в режиме обратной связи, где функция f8 используется для генерирования блоков ключевого по-
139
тока, побитно суммируемых с блоками открытого текста по модулю 2. Шифр KASUMI является модификацией алгоритма MISTY1 разрабо-танного в 1996 г. японской компанией Mitsubishi Electric, поэтому рассмотрим подробнее алгоритм MISTY1.
Рис. 5.3. Последовательность шифрования данных по алго-ритму MISTY1
На рис. 5.3 представлена последовательность операций, вы-полняемых при шифровании данных по алгоритму MISTY1. Как вид-но, алгоритм является алгоритмом Фейстеля с различными четными и нечетными раундами. В нечетных раундах, по сравнению с четными раундами выполняется дополнительно операция FL, которая также выполняется и по завершении последнего раунда. Количество раундов равно восьми.
Блок открытого текста
FLK
FLK
FOK
FOK
FLK
FLK
Блок шифртекста
+
+
раунд 1
раунд 2
140
Рис. 5.4. Алгоритм операции FL
Алгоритм операции FL представлен на рис. 5.4, где обозначение «&» соответствует выполнению операции побитого логического «и», а обозначение «» соответствует выполнению операции побитового сложения по модулю 2, KL1 и KL2 ― ключи шифрования. Таким обра-зом, при выполнении операции FL 32-битовое входное значение раз-бивается на два блока по 16 бит, над которыми выполняются опера-ции сложения по модулю 2 и побитные логические операции, причем в логических операциях участвуют определенные фрагменты расши-ренного ключа шифрования для операции KL1 и KL2. Более сложной является операция FO, алгоритм которой показан на рис. 5.5. В дан-ной операции 32-битовое входное значение также делится на два 16 битных фрагмента, один из которых обрабатывается операцией сло-жения по модулю 2 с определенным фрагментом ключа для операции FO (KOx) и операцией FI, после чего значения данных в этих блоках складываются по модулю 2 и меняются местами. Фактически, схема на рис. 5.5 является трехраундовой сетью Фейстеля с дополнительным сложением по модулю 2 после финального раунда.
Входные данные
Выходные данные
KL1
KL2
&
+
+
+
141
Рис. 5.5. Алгоритм операции FO
142
Рис. 5.6. Алгоритм операции FI
В отличие от операций FL и FO, операция FI обрабатывает 16-битные блоки входных данных (рис. 5.6). Это 3-раундовая сеть Фейстеля, обрабатывающая 7-битный и 9-битный блоки, над которы-ми выполняются следующие операции.
 Табличные замены S7 и S9 над 7- и 9-битным блоком соот-ветственно.
 Сложение блоков между собой по модулю 2, причем в первом и третьем раундах 7-битный блок дополняется нулями, и ре-
143
зультатом сложения является 9-битный блок, а во втором раунде при сложении отбрасываются два левых бита 9-битного блока и результа-том сложения является 7-битный блок.
 Сложение по модулю 2 соответствующих блоков с 7- и 9-битным фрагментами расширенного ключа шифрования KI1 и KI2, выполняемое во втором раунде.
Размерность ключа алгоритма составляет 128 бит. Перед нача-лом шифрования выполняется процедура вычисления фрагментов ключа, используемые в операциях FL, FO и FI. Рассмотренный вари-ант алгоритма MISTY1 назван алгоритмом KASUMI, является стан-дартом шифрования мобильной связи стандарта UMTS и реализован в функции шифрования f8.
Обеспечение целостности информации в телекоммуникацион-ных системах стандарта UMTS охватывает передачу данных между мобильной станцией и базовой станцией. В архитектуре безопасности UMTS выделяют 16 алгоритмов обеспечения целостности, указанные через идентификатор алгоритма целостности (UIA). Стандартный ал-горитм обозначен как UIA1. Стандартная функция целостности f9 также реализована на базе блочного шифра KASUMI. На вход f9 на-ряду с подлежащим защите сообщением поступает ключ целостности KЦ длиной 128 бит (рис. 5.7). Вычисленное значение MAC_Ц отправи-тель включает в передаваемое сообщение. На приеме принявший его абонент вычисляет MAC_Ц. Целостность переданных данных счита-ется подтвержденной, если вычисленный MAC_Ц и полученный MAC_Ц идентичны.
144
Рис. 5.7. Шифрование сообщений в стандарте UMTS
5.2. Механизмы обеспечения безопасности в стандарте CDMA2000
Обобщенная архитектура безопасности в стандарте сотовой свя-зи CDMA2000 показана на рис. 5.8. В системах стандарта CDMA2000 предусмотрено использование как несъемного (UIM), так и съемного (R_UIM) (removable) модуля идентичности, а идентификатор обору-дования пользователя носит название IMSN (TMSN).
Процедура аутентификации и ключевого соглашения в CDMA2000 подобна аналогичной процедуре UMTS с изложенными далее дополнениями и уточнениями. Используемые при этом алго-ритмы определены в [11]. Процедура реализуется в два этапа. На пер-вом этапе вектор аутентификации от домашней среды передается в сеть обслуживания. В стандарте CDMA2000 предусмотрено необяза-тельное дополнение процедуры аутентификации и ключевого согла-шения функцией f11 генерирования ключей аутентификации UIM
145
(KAU) и функцией UMAC алгоритма аутентификации UIM, преобра-зующей с помощью KAU аутентификации сообщения (рис. 5.8).
Рис. 5.8. Аутентификация в стандарте CDMA2000
В абонентских терминалах с несъемным UIM алгоритмы аутен-тификации и ключевого соглашения реализуются в виде стандартизи-рованной встроенной функции, что гарантирует возможность исполь-зования мобильной станции при смене оператора. В терминалах со съемным модулем идентичности абонента R_UIM оператор может использовать собственный набор алгоритмов аутентификации и клю-чевого соглашения. Функции и алгоритмы безопасности, имеющиеся в CDMA2000, приведены в табл. 5.2.
Рассмотрим процесс аутентификации мобильного абонента. По-сле получения вектора аутентификации в несъемном модуле идентич-ности UIM инициируется выполнение функции f5, генерирующей
146
ключ анонимности, и расшифровывается составная часть вектора ау-тентификации SQN. Значение SQN используется в качестве входа функции для f1, генерирующей параметр аутентификации сети AUTN′. После сравнения AUTN′ и AUTN с целью вычисления RES, KШ, KЦ, и KAU выполняются функции соответственно f2, f3, f4, и f11. После этого значение RES передается в сеть для подтверждения под-линности абонента. Значения KШ и KЦ передаются от UIM к термина-лу, где используются для обеспечения конфиденциальности и целост-ности информации. Первое различие двух рассматриваемых систем заключается в возможности использования в стандарте CDMA2000 как встроенного, так и съемного модуля идентичности абонента (R_UIM). Второе отличие заключается в том, что алгоритмы безопас-ности CDMA2000 полностью стандартизированы, в то время как в стандарте UMTS лишь частично. Третье отличие заключается в нали-чии алгоритма аутентификации UIM и функции генерирования ключа аутентификации UIM.
В целях обеспечения конфиденциальности информационного обмена в стандарте CDMA2000 используется стандарт шифрования AES [5] (также известный как Rijndael [7]), представляющий собой симметричный блочный шифр, зашифровывающий блоки данных длиной 128 бит под управлением 128 битового ключа. В результате шифрования формируются блоки ключевого потока, применяемые для потокового шифрования/расшифровывания данных (рис. 5.9).
Защита конфиденциальности осуществляется на участке мо-бильная станция базовая станция. Длина ключа шифрования равна 128 бит.
147
Таблица 5.2
Функции безопасности в стандарте CDMA2000
Функция
Назначение
f0
Функция генерирования случайного числа
f1
Функция аутентификации сети
f2
Функция аутентификации абонента
f3
Функция генерирования ключа шифрования KШ
f4
Функция генерирования ключа целостности KЦ
f5
Функция генерирования ключа анонимности AK
f6
Алгоритм шифрования, предназначенный для обеспе-чения конфиденциальности данных, передаваемых между домашней средой и сетью обслуживания
f7
Алгоритм целостности, предназначенный для обеспе-чения контроля целостности данных на участке «до-машняя среда — сеть обслуживания»
f8
Алгоритм шифрования, предназначенный для шифро-вания данных, передаваемых на участке «сеть обслу-живания — мобильная станция»
f9
Алгоритм целостности, предназначенный для обеспе-чения контроля целостности данных на участке «сеть обслуживания — мобильная станция»
f11
Функция генерирования ключа KAU аутентификации UIM
UMAC
Алгоритм аутентификации UIM
ESP AES
Алгоритм шифрования
EHMAC
Усовершенствованный алгоритм обеспечения целост-ности HMAC
148
В стандарте шифрования AES некоторые операции выполняют-ся над байтами, которые рассматриваются как элементы поля GF(28). В качестве неприводимого многочлена выбран многочлен f(x) = x8 + x4 + x3 + x + 1. Примитивным элементом поля является элемент  x + 1. В GF(28) справедливо 255 = 1. Соотношения между различ-ными формами представления элементов поля GF(28) приведено в табл. 5.3.
Рис. 5.9 Шифрование данных в стандарте CDMA2000
Шифр AES является итерационным блочным шифром, имею-щим переменную длину блоков и различные длины ключей. Длины ключа и длины блоков могут быть равны, независимо друг от друга, величинам 128, 192 или 256 бит. В рассматриваемом стандарте ис-пользуется шифр AES-128.
149
Таблица 5.3
Форма представления элементов поля GF(24)
Степенная форма
Полиномиальная форма
Векторная форма

1


x + 1


x


x3 + x2 + x + 1

….

…

x6 + x4 + x + 1


x7 + x6 + x5 + x4 + x2 + x 

В шифре AES-128 приняты следующие обозначения: Nb — чис-ло 32-битовых слов, содержащихся во входном блоке данных (Nb = 4), Nk — число 32-битовых слов, содержащихся в ключе шиф-рования (Nk = 4), Nr — количество раундов шифрования (Nr = 10). Промежуточные результаты преобразований, выполняемых в рамках криптографического алгоритма, называются состояниями (State). Со-стояние можно представить в виде прямоугольного массива байтов. Этот массив имеет 4 строки и 4 столбца, где каждый столбец пред-ставляет собой 32-битовое слово. Тогда обрабатываемый входной блок данных можно представит в виде четырех слов:
w0 = s00// s10// s20// s30;
w1 = s01// s11// s21// s31;
w2 = s02// s12// s22// s32;
w3 = s03// s13// s23// s33.
Этот же блок данных можно представить в виде матрицы со-стояния State размера 4 × 4 байта. Ключ шифрования также представ-лен в виде прямоугольного массива с четырьмя строками.
Каждый раунд состоит из 4 преобразований: замена байтов, сдвиг строк, перемешивание столбцов, добавление раундового ключа.
 Замена байтов (ByteSub). Данное преобразование нели-нейное и выполняется с каждым байтом состояния. Таблицы замены
150
S-блока являются инвертирумыми и построены из композиции двух преобразований.
 Преобразование сдвига строк (ShiftRow). Нулевая строка состояния не сдвигается. Последние 3 строки циклически сдвигаются на различное число байтов.
 Преобразование перемешивания столбцов (MixColumn). В этом преобразовании столбцы состояния рассматриваются как мно-гочлены над GF(28) и умножаются по модулю x4 + 1.
 Добавление раундового ключа (AddRoundKey). В дан-ной операции раундовый ключ добавляется к состоянию посредством простой поразрядной операции логического побитового сложения по модулю 2.
 Раундовый ключ формируется из ключа шифрования посредством алгоритма получения ключей (Key Schedule).
Для достижения целостности передаваемой информации в стан-дарте CDMA2000 вычисляется код аутентификации сообщения MAC (Message Authentication Code), отвечающий также за защиту сведений от преднамеренной модификации. Размер кода аутентификации со-общения MAC определяется важностью сообщения и при необходи-мости усекается к требуемому значению, но не может быть меньше 32 бит. Для сообщений приоритетной значимости взамен кода аутенти-фикации сообщения MAC используется алгоритм аутентификации UIM (UMAC), при вычислении которого необходимо использовать не только ключ целостности KЦ, но и ключ аутентификации KAU. Вычис-ление значения UMAC может быть осуществлено только непосредст-венно самим модулем идентичности абонента UIM (рис. 5.9). В случае предоставления домашней средой ключа аутентификации KAU в виде составной части вектора аутентификации и при готовности сети об-служивания к его приему мобильная станция определяет значение UMAC и помещает его в соответствующий пакет данных.
151
Вопросы и задания
1. В чем отличие механизма аутентификации в стандартах UMTS и CDMA?
2. Какой шифр используется в телекоммуникационной сис-теме стандарта GSM?
3. Какая хеш-функция применяется в стандарте GSM?
4. Какой шифр для защиты информации используется в теле-коммуникационной системе стандарта UMTS?
5. Как обеспечивается целостность передаваемых данных в стандарте UMTS?
6. Как обеспечивается целостность передаваемых данных в стандарте CDMA2000?
7. Какова длина блока шифруемых данных в телекоммуника-ционной системы передачи информации стандарта UMTS?
8. Какова длина блока шифруемых данных в стандарте CDMA2000?
9. Напишите программу вычислений в поле GF(28).
10. Напишите программу деления на образующий многочлен x8 + x4 + x3 + x + 1.
11. Напишите программу преобразования замена байтов (By-teSub).
12. Напишите программу шифра AES.
13. Разработайте программу шифра KASUMI.
152
6. Лабораторная работа «Криптографические
методы защиты информации»
Лабораторная работа «Криптографические методы защиты ин-формации» предназначена для практического закрепления знаний по основным разделам данного учебного пособия.
При выполнении лабораторной работы студент должен:
уметь проектировать устройства криптографической защиты инфор-мации в телекоммуникационных системах; моделировать с помощью современных программных продуктов функциональные узлы генера-торов псевдослучайных последовательностей, генераторов поточных шифров на базе регистров с обратными связями, блоков формирова-ния CRC кодов; осуществлять экспериментальные исследования криптографических методов защиты информации;
представлять пути обеспечения заданных характеристик защиты информации в телекоммуникационных системах; выбирать требуе-мые характеристики многочленов для обеспечения требуемой степени защиты информации в генераторах поточных шифров; а также тен-денции, перспективы и проблемы развития техники защиты инфор-мации.
Выполнение лабораторной работы должно дать студентам прак-тические навыки исследования методов защиты информации в теле-коммуникационных системах; навыки статистической обработки ре-зультатов измерений и оценки точности проводимых эксперимен-тальных исследований.
Основные экспериментальные исследования, проводимые в ла-бораторной работе, подкреплены методическим и теоретически мате-риалом раздела 1 настоящего учебного пособия.
Перед выполнением лабораторной работы требуется знать ма-териал раздела 1, уметь производить умножение и деление много-членов, иметь представление о работе регистров с линейными обрат-ными связями, уметь проектировать генераторы псевдослучайных по-следовательностей с заданными криптографическими свойствами.
153
Цель лабораторной работы: Исследование свойств алгоритмов защиты информации на базе CRC кода и поточного шифра.
Содержание работы:
Исследование методов умножения и деления многочленов, опи-сание которых приведено в настоящем учебном пособии (см. рис.1.20 и 1.21).
Исследование принципов работы регистров с линейными об-ратными связями (раздел 1.4.2).
Исследование свойств алгоритма защиты информации на базе CRC-кода, описанного в разделе 1.4.5.
Исследование статистических свойств генераторов псевдослу-чайных последовательностей (разделы 1.4.3 и 1.4.4).
Исследование свойств поточного шифра на базе регистра с об-ратными связями (раздел 1.4.6).
Лабораторное оборудование состоит из лабораторного макета, имеющего встроенный микроконтроллем и панель визуализации ре-зультатов эксперимента; персональный компьютер, необходимый для выполнения теоретических расчетов умножения и деления многочле-нов, а также для выбора образующего полинома при построении ге-нераторов псевдослучайной последовательности чисел.
Описание лабораторной установки Лабораторная установка предназначена для изучения операций умножения и деления в полях многочленов, лежащих в основе крип-тографической защиты информации с помощью CRC кода и исследо-вания статистических свойств генераторов псевдослучайных чисел. На установке выполняются следующие разделы лабораторной рабо-ты:  Умножение и деление многочленов.  Регистры с линейными обратными связями.
154
 Свойства алгоритма защиты информации на базе CRC-кода  Статистические свойства генераторов псевдослучайной по-следовательности.  Свойства поточного шифра на базе регистра с обратными связями.
Вид лицевой панели представлен на рис. 6.1. В правом верхнем углу лицевой панели лабораторной установки расположен цифробук-венный дисплей, на котором отображаются пункты выполнения лабо-раторной работы и результаты экспериментальных исследований. В левом нижнем углу лицевой панели, в поле «Многочлен», расположе-ны светодиоды, состояние которых отражает в режиме программиро-вания значение двоичных коэффициентов многочлена. Нумерация двоичных коэффициентов многочлена осуществляется, начиная с младшего разряда. Например, многочлену x16 + x12 + x3 + x + 1 соот-ветствует запись в двоичном коде 10001000000001011, которая соот-ветствует включенным светодиодам с номерами 17, 13, 4, 2, 1. Допол-нительно коэффициенты многочлена выводятся в шестнадцатеричной системе на дисплей, дублируя двоичное представление. Таким обра-зом, на дисплее будет высвечено значение 1100В. В правом нижнем углу лицевой панели расположено поле «Управление меню». Пере-мещение по меню осуществляется с помощью кнопок управления в этом поле. В табл. 6.1 приведено описание кнопок управления.
При включении лабораторной установки на цифробуквенном дисплее высвечивается слово «Меню». Схема основного меню «Ме-ню» представлена на рис. 6.2, где запись x16 + x12 + x3 + x + 1 соот-ветствует многочлену x16 + x12 + x3 + x + 1.
155
Рис. 6.1. Вид лицевой панели
Выполнение работы начинается с пункта «Поля многочленов», переход к которому осуществляется кнопкой «\/». На этом первом уровне доступны для выбора пункты меню: «Поля многочленов», «Регистр с линейными обратными связями «РСЛОС», «CRC-код», «Генератор псевдослучайной последовательности «ГПСП», «Поточ-ный шифр». С первого уровня каждого пункта меню имеется переход на второй и последующие уровни.
Выбор выполняемого пункта осуществляется путем нажатия управляющих кнопок «>» и «<». Запись многочленов осуществляется в режиме программирования. Переход в режим программирования многочлена осуществляется с помощью кнопки «Пр», находящейся в правом нижнем поле лицевой панели. При этом над ней загорается светодиод, подтверждающий переход в режим программирования.
156
Таблица 6.1
Назначение управляющих кнопок
<
Перемещение по меню влево
>
Перемещение по меню вправо
/\
Перемещение по меню вверх
\/
Перемещение по меню вниз
Пр
Включение/выключение режима программирования
◄
Перемещение на позицию влево
►
Перемещение на позицию вправо
▲
Перемещение на позицию вверх (влево на 16)
▼
Перемещение на позицию вниз (вправо на 16)
0/1
Изменение значения многочлена на текущей позиции в режиме программирования
►|
Установка нулей на всех позициях, правее текущей позиции
Программирование значений двоичных коэффициентов много-члена осуществляется с помощью кнопки «0/1». Переход к набору следующего коэффициента выполняется кнопкой «◄», причем, после набора очередного двоичного символа, результат отображается на эк-ране дисплея.
Заметим, что на экране жидкокристаллического дисплея вместо надписи «Ваш выбор: x16 + x12 + x3 + x + 1» будет выведено «Ваш вы-бор: x16 + x12 + x3 + x + 1».
157
Энтропия
Результат
Кодировать Кодирование выполнено
Исходный текст 4
hi2
Исходный текст
Исходный текст 1
Ваш выбор : Исходный текст 4
Ваш выбор : Исходный текст 1
Ваш выбор : Х16 +Х12 + Х 3+ Х+1
Поточный шифр Образующий многочлен
Х2+Х +1 Ваш выбор :Х2 +Х+1
Вычислить
10000 Ваш выбор :10000
1000 Ваш выбор :1000
100 Ваш выбор : 100
Объем выборки
0,99 Ваш выбор : 0,99
0,95 Ваш выбор : 0,95
0,9 Ваш выбор : 0,9
Дов. вероятность
Х16+ Х12+ Х 3 +Х+1 Ваш выбор : Х16 +Х12 +Х3+ Х+1
ГПСП Образующий многочлен
Х 2+ Х+1 Ваш выбор : Х2 + Х+1
Ваш выбор : CRС32
Ваш выбор : CRС16
Ваш выбор : CRC8
Ваш выбор : CRC4
CRC 16
CRC8
CRC4
Вычислить
Инф.
многочлен
CRСкод ВыборCRC
CRС32
Сдвиг
Регистр
Обратные связи
РСЛОС
Делимое
Вычислить
Множимое
Множитель
Делитель
Вычислить
Деление
Умножение
Поля
многочленов
М
е
н
ю
Х16 + Х12+ Х3 + Х+1
Сравнить тексты
hi2 (байт)
hi2 (бит)
hi2
hi2 (байт)
hi2 (бит)
Остаток
Частное
Рис. 6.2. Схема основного меню
158
Умножение и деление многочленов
На рис. 6.3 приведена схема передвижения по меню с помощью
кнопок управления.
Множитель Множимое Вычислить Делимое Делитель Вычислить
Умножение Деление
Меню
Поля многочленов
Частное
Остаток
Делитель
Рис. 6.3. Схема пункта меню «Умножение и деление многочленов»
Переход на следующий уровень происходит с помощью управ-
ляющей кнопки «\/». На этом уровне доступны для выбора пункты
меню: «Умножение» и «Деление». Выбор осуществляется кнопками
«>» и «<». Переход к выполнению подпункта «Множитель», соответ-
ствующего режиму программирования множителя, выполняется с
помощью управляющей кнопки «\/». Режим программирования мно-
жителя задается кнопкой «Пр», находящейся в правом нижнем поле
лицевой панели. При этом над кнопкой загорается светодиод, под-
тверждающий переход в режим программирования. Программирова-
ние значений двоичных коэффициентов многочлена осуществляется с
помощью кнопки «0/1». Для перехода к набору следующего коэффи-
циента необходимо использовать кнопку «◄». После набора очеред-
ного двоичного символа результат отображается на экране дисплея.
При этом в левом нижнем поле лицевой панели «Многочлен» с по-
мощью светодиодов будет представлена запись в двоичном коде, а
его шестнадцатеричный эквивалент ― на экране дисплея в нижней
159
строчке. Шестнадцатеричный эквивалент на экране дисплея появля-ется после набора каждого двоичного символа. При неправильном наборе одного двоичного символа можно с помощью кнопок «◄» и «►» вернуться к соответствующему разряду и повторным использо-ванием кнопки «0/1» исправить значение набранного разряда. Кноп-кой «►|» происходит установка нулей на всех позициях, правее те-кущей позиции. Выход из режима программирования осуществляется путем повторного нажатия на кнопку «Пр». При этом гаснет светоди-од, расположенный над данной кнопкой.
Переход к подпункту «множимое» происходит с помощью кнопки «>» Для перехода в режим программирования множителя не-обходимо использовать кнопку «Пр», находящуюся в правом нижнем поле лицевой панели. Программирование множимого осуществляется аналогично программированию множителя. Для перехода к выполне-нию подпункта меню «вычислить» необходимо выйти из режима программирования, повторно нажав кнопку «Пр».
С помощью кнопки «>» необходимо добиться появления надпи-си «Вычислить». При этом в поле «Многочлен» на светодиодах и эк-ране дисплея появляется результат операции.
Аналогичным образом осуществляется выполнение операции деление многочленов.
Выбрав в качестве делителя примитивный многочлен из табли-цы примитивных многочленов, и несколько раз изменив значение де-лимого можно убедиться, что остаток от деления каждый раз соответ-ствует одному из элементов конечной мультипликативной группе в поле GF(2m), где m ― степень делителя.
Переход к выполнению следующего пункта осуществляется с помощью кнопки «/\», что соответствует перемещению по меню на один уровень вверх. Повторное нажатие кнопки «/\», соответствует перемещению по меню еще на один уровень вверх, при этом появле-ние надписи «поля многочленов» подтверждает, что мы находимся на верхнем уровне меню.
160
Регистры с линейными обратными связями (РСЛОС)
Кнопкой «>» выбирается пункт меню: «Исследование регистров
с линейными обратными связями», что соответствует появлению на
дисплее надписи «РСЛОС». Кнопкой «\/» осуществляется переход к
выполнению этого пункта. На рис. 6.4 приведена схема передвиже-
ния по меню с помощью кнопок управления.
Обратные связи Регистр Сдвиг
РСЛОС
Меню
Рис. 6.4. Схема пункта меню «РСЛОС»
Из таблицы примитивных многочленов (табл. 6.2) выбирается
примитивный многочлен небольшой степени (например, 4), который
будет задавать вид обратной связи.
Переход в режим программирования обратных связей осуществ-
ляется кнопкой «Пр», находящейся в правом нижнем поле лицевой
панели, при этом над ней загорается светодиод, подтверждающий пе-
реход в режим программирования двоичных коэффициентов много-
члена, соответствующего регистру обратных связей. Программирова-
ние осуществляется аналогично пункту «Поля многочленов». Выход
из режима программирования осуществляется повторным нажатием
кнопки «Пр». При этом светодиод, расположенный над кнопкой, гас-
нет.
Переход к выполнению подпункта меню «регистр» осуществля-
ется кнопкой «>». Для перехода в режим программирования состоя-
ния регистра необходимо использовать кнопку «Пр», находящуюся в
правом нижнем поле лицевой панели. Программирование регистра
161
осуществляется аналогично пункту умножение и деление многочле-нов. Таблица 6.2 Примитивные многочлены
Степень 2
x2 + x + 1
Степень 3
x 3 + x + 1
x 3 + x 2 + 1
Степень 4
x 4 + x + 1
x 4 + x 3 + 1
Степень 5
x 5 + x 2 + 1
x 5 + x 3 + 1
Степень 6
x 6 + x + 1
x 6 + x 4 + x 3 + x + 1
x 6 + x 5 + 1
Степень 7
x 7 + x + 1
x 7 + x 3 + 1
x 7 + x 3 + x 2 + x + 1
Степень 8
x 8 + x 4 + x 3 + x 2 + 1
x 8 + x 5 + x 3 + x + 1
x 8 + x 5 + x 3 + x 2 + 1
Степень 9
x 9 + x 4 + 1
x 9 + x 4 + x 3 + x + 1
x 9 + x 5 + 1
Степень 10
x 10 + x 3 + 1
x 10 + x 4 + x 3 + x + 1
x 10 + x 5 + x 2 + x + 1
Степень 11
x 11 + x 2 + 1
x 11 + x 4 + x 2 + x + 1
x 11 + x 5 + x 3 + x + 1
Степень 12
x 12 + x 6 + x 4 + x + 1
x 12 + x 6 + x 5 + x 3 + 1
x 12 + x 6 + x 5 + +x4 + x3 + x + 1
Степень 13
x 13 + x 4 + x 3 + x + 1
x 13 + x 5 + x 2 + x + 1
x 13 + x 5 + x 4 + x 2 + 1
Переход к выполнению подпункта меню «сдвиг» происходит с помощью кнопок «>» и «\/».
При выключенном режиме программирования, последователь-ным нажатием на кнопки «◄» и «►» можно осуществить пошаговый сдвиг содержимого регистра влево и вправо. При этом как на свето-диодах, так и на дисплее отображается значение содержимого регист-ра. Переход к выполнению следующего пункта осуществляется по-вторным нажатием кнопки «/\». При этом появление надписи «РСЛОС» подтвердит нахождение в верхнем уровне меню.
162
Свойства алгоритма защиты информации на базе
CRC-кода
С помощью управляющей кнопки «>» выбирается пункт меню
«CRC-код». На рис. 6.5 приведена схема передвижения по меню с по-
мощью кнопок управления.
Ваш
выбор:
CRC-32
Ваш
выбор:
CRC-16
CRC-16
Выбор CRC Инф. многочлен Вычислить
CRC-код
CRC-32
Ваш
выбор:
CRC-8
Ваш
выбор:
CRC-4
CRC-4 CRC-8
Меню
Рис. 6.5. Схема меню «CRC-код»
Кнопкой «\/» необходимо добиться появления надписи «Выбор
CRC». Повторным нажатием кнопки «\/» и с помощью управляющих
кнопок «>» и «<» выбирается соответствующий CRC-код (CRC-4,
CRC-8, CRC-16, CRC-32). Надписи будут последовательно появляться
на экране дисплея. Повторным нажатием кнопки «\/» подтверждается
выбор. При этом на дисплее появляется надпись «Ваш выбор:
CRC-N». Двукратное нажатие кнопки «/\» возвращает на два уровня
вверх, что соответствует надписи «Выбор CRC».
Переход к пункту меню «Информационный многочлен» осуще-
ствляется кнопкой «>». Для перехода в режим программирования ин-
формационного многочлена необходимо использовать кнопку «Пр»,
находящуюся в правом нижнем поле лицевой панели. При этом над
ней загорается светодиод, подтверждающий переход в режим про-
163
граммирования. Набор информационного многочлена осуществляется в соответствии с рассмотренной ранее методикой. Переход к выполнению подпункта меню «Вычислить» осущест-вляется кнопкой «>». При этом на светодиодах и на дисплее высвечи-вается значение CRC-кода. Изменяя информационную последова-тельность необходимо убедиться, что при этом изменяется и значение CRC-кода. Выполнение следующего пункта осуществляется повторным нажатием кнопки «/\». При этом появление надписи «CRC-кода» под-тверждает нахождение на верхнем уровне меню.
Статистические свойства генераторов псевдослучай-ной последовательности Кнопкой «>» выбирается режим «Генератор псевдослучайной по-следовательности», которому соответствует надпись на экране дис-плея «ГПСП». На рис. 6.6 приведена схема передвижения по меню с помощью кнопок управления. Кнопкой «\/» необходимо добиться появления надписи «Обра-зующий многочлен». Переход в режим выбора образующего много-члена осуществляется кнопкой «\/». Выбор образующего многочлена происходит с помощью управляющих кнопок «<» и «>». Нажатие кнопки «\/» подтверждает выбор многочлена. При этом на дисплее появляется надпись, например, «Ваш выбор: x16 + x12 + x3 + x + 1», что соответствует многочлену x16 + x12 + x3 + x + 1. Переход к выполнению подпункта меню «Доверительная веро-ятность» осуществляется двукратным нажатием кнопки «/\», что со-ответствует возврату по меню на два уровня вверх. Появление надпи-си «Образующий многочлен» свидетельствует о возврате к предыду-щему пункту меню. Кнопкой «>» необходимо добиться появления надписи «Доверительная вероятность» и с помощью кнопки «\/» пе-рейти в режим выбора численного значения доверительной вероятно-сти.
164
Меню
Вычислить
10000
Ваш
выбор:
10000
1000
Ваш
выбор:
1000
100
Ваш
выбор:
100
Объем выборки
hi 2
hi2 (бит) hi2 (байт)
0,
99Ваш
выбор :
0,99
95 0,
Ваш
выбор :
0,95
0,9
Ваш
выбор :
0,9
Дов. вероятность
Х2+Х+1
Ваш выбо:р
Х2+Х+1
Х16+ Х12 + Х3+ Х+1
Ваш выбор::
Х16+ Х12 +Х 3+ Х+1
Обр. многочлен
ГПСП
99
Рис. 6.6 Схема пункта меню «ГПСП»
Кнопкой «>» необходимо добиться появления требуемого зна-
чения доверительной вероятности {0,9, 0,95, 0,99} и кнопкой «\/» под-
твердить выбор. При этом появляется надпись «Ваш выбор: 0.9х».
Переход к выполнению следующего пункта меню осуществля-
ется двукратным нажатием кнопки «/\», что соответствует возврату по
меню на два уровня вверх. При этом появляется надпись «Довери-
тельная вероятность», нажатием кнопки «>» добиться появления над-
писи «Объем выборки» и кнопкой «\/» перейти в режим выбора зна-
чения.
С помощью кнопки «>» необходимо добиться появления тре-
буемого значения объема выборки {100, 1000, 10000} и кнопкой «\/»
подтвердить выбор. При этом появляется надпись «Ваш выбор:
1хххх».
165
Переход к выполнению следующего пункта меню «Вычислить» осуществляется двукратным нажатием кнопки «/\». При этом появля-ется надпись «Объем выборки». Кнопкой «>» необходимо добиться появления надписи «Вычислить». После этого кнопкой «\/» необхо-димо добиться появления надписи «hi2» и кнопкой «\/» подтвердить переход в режим расчета по битам или байтам. Переключение между этими режимами осуществляется кнопками «>» и «<». При этом на экране дисплея появляется в верхней строке граничное значение кри-терия 2 соответствующего выбранной доверительной вероятности, а в нижней строке вычисленное значение, соответствующее выбранной доверительной вероятности. Переход к выполнению следующего пункта осуществляется дву-кратным нажатием кнопки «/\», при этом появление надписи «ГПСП» подтверждает нахождение в верхнем уровне меню.
Свойства поточного шифра на базе регистра с обратными связями Кнопкой «>» выбирается пункт меню «Поточный шифр» и кнопкой «\/» подтверждается этот выбор. На экране дисплея появля-ется надпись «Образующий многочлен». Кнопкой «\/» подтверждает-ся этот выбор. На рис. 6.7 приведена схема передвижения по меню. Кнопками «>» и «<» выбирается образующий многочлен из тех, которые последовательно появляются на дисплее. Повторное нажатие кнопки «\/» подтверждает выбор. При этом на дисплее появляется надпись «Ваш выбор: x16 + x2 + 1». Переход к выполнению подпунк-та меню «Исходный текст» осуществляется двукратным нажатием кнопки «/\». При этом появляется надпись «Образующий многочлен». Кнопка «>» обеспечивает появления на экране дисплея надписи «Ис-ходный текст».
166
Кодировать Результат
Кодирование выполнено
Исходный текст 4
hi2
Исходный текст
Исходный текст1
Ваш выбо:р
Исходный текст4
Ваш выбор:
Исходный текст1
Х16+Х12 +Х3 + Х+1
Ваш выбо:р
Х16+ Х12+Х3+ Х+1
Поточный шифр
Обр. многочлен
Х2 + Х+1
Ваш выбор:
Х2 + Х+1
hi2 ( байт) hi2 ( бит )
Меню
Энтропия Сравнить тексты
Рис. 6.7. Схема меню «Поточный шифр»
С помощью кнопки «\/» необходимо установить режим выбора
конкретного текста. Выбор номера текста осуществляется кнопками
«>» и «<» и кнопкой «\/» подтверждается выбор. При этом на дисплее
появляется надпись «Ваш выбор: Текст № х».
Для перехода к выполнению подпункта меню «Кодировать» не-
обходимо два раза нажать кнопку «/\» и кнопкой «>» добиться появ-
ления надписи «Кодировать». Подтверждение выбора осуществляется
кнопкой «\/». При этом на дисплее высвечивается надпись «Кодиро-
вание выполнено».
После выполнения предыдущего подпункта, с помощью кнопки
«/\», необходимо вернуться на один уровень вверх. При этом появля-
ется надпись «Кодировать». Кнопкой «>» добиться появления надпи-
си «Результат» и кнопкой «\/» подтвердить выбор.
Повторным нажатием кнопки «\/» осуществляется выбор режи-
ма отображения вычисленного значения 2. Кнопками «>» и «<» осу-
ществляется выбор между расчѐтом по байтам или по битам.
С помощью кнопки «/\» осуществляется возврат по меню на
один уровень вверх. Кнопкой «>» необходимо добиться появления
167
надписи «Энтропия». На верхней строке дисплея отображается в скобках значение энтропии открытого текста, а на нижней строке — значение энтропии кодированного текста. Кнопкой «>» необходимо добиться появления надписи «Срав-нить тексты». После нажатия кнопки «\/» осуществляется просмотр исходного и кодированного текста кнопками «◄», «►», «▲» и «▼». Исходный текст отображается в верхней строке, а кодированный текст — в нижней. Кнопками «◄» и «►» осуществляется сдвиг на один символ. Кнопками «▲» и «▼» осуществляется сдвиг на 16 сим-волов.
Подготовка к выполнению лабораторной работы Перед выполнением лабораторной работы необходимо иметь представление о правилах умножения и деления многочленов. Уметь проводить все вычисления в двоичной и шестнадцатеричной систе-мах счисления.
Программа и порядок выполнения работы. Ознакомившись с описанием лабораторной установки, включить установку нажатием кнопки «Сеть». После этого провести следующие измерения.
Умножение и деление многочленов.
Провести три процедуры умножения многочленов степени не ниже пятой. Множимое, множитель и результат, считываются с экра-на дисплея и заносятся в табл 6.3. Запись многочленов в таблицу про-изводится в шестнадцатеричной системе счисления. Так, например, представленная на языке СИ запись 0x51, означает, что число 51 за-писано в шестнадцатеричной системе счисления и соответствует дво-ичной записи многочлена 1010001 или x5 + x3 + 1.
168
Таблица 6.3
Тестовый пример умножения
Умножение многочленов
Множимое
Множитель
Результат
0x5
0x3
0xf
0x51
0x39
0xDE9
0x5207
0x3243B
0xFD0CFAA1
Провести три процедуры деления многочленов степени не ниже пятой. Множимое, множитель и результат, считываются с экрана дис-плея и заносятся в табл. 6.4.
Таблица 6.4
Тестовый пример деления
Деление многочленов
Делимое
Делитель
Результат
Частное
Остаток
0x654
0x9A
0xD
0x76
0x952497
0x3289A
0x4F
0x9D01
0x32000860000
0x16161BE
0x3BACA
0x58D20C
Регистры с линейными обратными связями
Из таблицы примитивных многочленов (табл. 6.2) выбрать три примитивных многочлена, которые будут задавать вид обратной свя-зи. Начальное состояние регистра выбирается произвольно в интерва-ле от 1 до 2n – 1, где n ― длина регистра, равная порядку многочлена в цепи обратной связи. Результаты выполнения приводятся в отчете в виде таблицы (пример ― табл. 6.5 для n = 2), состоящей из 2n – 1 строк и четырех столбцов. В первом столбце записывается количество сдвигов влево, во втором ― содержимое регистра в шестнадцатерич-
169
ной системе. Аналогично оформляются третий и четвертый столбцы
таблицы 5 для сдвига содержимого регистра вправо.
Таблица 6.5
Тестовый пример исследования состояния регистра сдвига
Обратные связи — 0x43
Номер сдвига
влево
Регистр Номер сдвига
вправо
Регистр
Начальное состояние сдвигового
регистра – 0x1
Начальное состояние сдвигово-
го регистра – 0x10
1 0x2 1 0x8
2 0x4 2 0x4
3 0x8 3 0x2
Количество сдвигов и вправо и влево должно быть равно 2n 1.
При этом необходимо убедиться, что в таблице приведены все воз-
можные состояния регистра соответствующие данному примитивно-
му многочлену.
Свойства алгоритма защиты информации на базе
CRC-кода
Выбрать два из возможных CRC-кодов (CRC-4, CRC-8, CRC-16,
CRC-32). Выбираются три произвольных информационных много-
члена. Для многочлена определить соответствующий ему CRC код.
Результаты исследований занести в табл. 6.6.
170
Таблица 6.6 Вычисление CRC-кода
CRC-код
Информационный многочлен
CRC-сумма
CRC-4
0xDF1
0x1
0xCF1
0x5
0x3124
0xF
0x74C00A4
0x7
CRC-8
0xDF1
0x2E
0x3124
0x54
0x74C00A4
0x4A
Статистические свойства генераторов псевдослучай-ной последовательности. Таблица 6.7 Исследование генератора ПСП
Объем выборки = 100
Степень образующего многочлена
hi2 (байт)
hi2 (бит)
12
257,99
0,22
16
234,96
0,16
Объем выборки = 10000
Степень образующего многочлена
hi2 (байт)
hi2 (бит)
12
193,99
0,02
16
232,96
0,77
Выбрать два образующих многочлена разной степени. Для двух разных объемов выборки рассчитать значения , которые сравнить с пороговым значением. Определить соответствие экспериментальных данных гипотезе о равномерном распределении. Результаты вычисле-ний занести в табл. 6.7.
171
Вычисленные значения , сравнить с пороговыми значениями (табл. 6.8). Если в результате измерения вычисленное значение пре-вышает пороговое, то гипотеза о равномерном значении отклоняется.
Таблица 6.8
Пороговые значения для принятия решения о равномерно-сти распределения
Доверительная вероят-ность
Пороговое значение hi2 (байт)
Пороговое значение hi2 (бит)
0.9
285
4
0.95
294
6
0.99
311
9
Свойства поточного шифра на базе регистра с обратными связями
Таблица 6.9
Результаты исследования текстовых примеров
Исходный текст №1
Степень образующего многочлена
hi2 (байт)
hi2 (бит)
Энтропия
8
237,97
0,49
4,39
7,10
10
257,99
0,22
4,39
7,14
12
269,96
0,77
4,39
7,20
Исходный текст №2
Степень образующего многочлена
hi2 (байт)
hi2 (бит)
Энтропия
8
215,99
1,52
4,47
7,21
10
233,99
0,69
4,47
7,25
12
229,99
0,02
4,47
7,24
Определить значение энтропии открытого текста и значение эн-тропии после выполнения процедуры шифрования поточным шиф-
172
ром. Для этого выбрать три образующих многочлена. Выбрать два из четырех возможных открытых текстов. Результаты анализа свести в табл. 6.9.
Содержание отчета
Наименование и цель работы.
 Таблица выполнения пункта «Умножение и деление мно-гочленов», сопровождаемая проверочным вычислением «вручную».
 Таблица выполнения пункта «Регистры с линейными об-ратными связями», сопровождаемая выводами о подтверждении мультипликативной структуре поля многочленов.
 Таблица выполнения пункта «Свойства алгоритма защиты информации на базе CRC кода», сопровождаемая проверочным вы-числением «вручную» и выводами о том, какие изменения в инфор-мационном многочлене обнаруживает CRC код.
 Таблица выполнения пункта «Статистические свойства ге-нератора псевдослучайной последовательности» с выводами о ре-зультатах тестирования.
 Таблица выполнения пункта «Свойства поточного шифра на базе регистра с обратными связями» и результаты тестирования открытого и шифрованного текстов, с выводами. Кроме того, должны быть приведены начальные последовательности символов открытого и шифрованного текстов, сопровождаемые проверочным вычислени-ем «вручную».
 Выводы по работе.
173
Задания к лабораторной работе
Задание 1. Выбрать два многочлена степени не ниже пятой с коэффициентами из поля GF(2), перемножить их, привести подобные и сравнить полученный результат с результатом вычислений на лабо-раторной установке.
Задание 2. Выбрать первый многочлен степени не ниже вось-мой с коэффициентами из поля GF(2), выбрать второй многочлен сте-пени не ниже пятой из таблицы примитивных многочленов, разделить первый многочлен на второй и сравнить полученный результат с ре-зультатом вычислений на лабораторной установке.
Задание 3. Сформировать случайный информационный много-член с коэффициентами из поля GF(2) степени не ниже десятой и вы-числить для него контрольный код CRC-16 путем деления информа-ционного многочлена на порождающий. Сравнить полученный ре-зультат с результатом экспериментальных исследований, полученных на лабораторной установке.
Задание 4. Взять в качестве образующего многочлен степени не ниже пятой из таблицы примитивных мночленов и заполнив регистр случайным набором нулей и единиц, выписать все возможные после-довательные состояния при последовательном сдвиге регистра. Срав-нить полученные состояния с результатами, полученными на лабора-торной установке.
Задание 5. Последовательно сосчитать с индикатора лаборатор-ной установки один из текстов, записанных в памяти и рассчитать для него энропию. Сравнить полученный результат с результатом, полу-ченным на лабораторной установке.
174
БИБЛИОГРАФИЧЕСКИЙ СПИСОК
1. Саймон С. Книга кодов. — М.: АСТ, 2007. — 448 c.
2. Смарт Н. Криптография М.: Техносфера 2005. — 528 c.
3. Асосков А. В. Поточные шифры. / А. В. Асосков, М. А. Иванов, А. А. Мирский, А. В. Рузин. — М.: Кудиц – Образ, 2003. — 336 c.
4. Иванов М. А. Теория, применение и оценка качества гене-раторов псевдослучайных последовательностей. / И. В. Чугунков. — М.: Кудиц – Образ, 2003. — 240 c.
5. Шнайер Б. Прикладная криптография. М.: Триумф, 2002. — 815 с.
6. Макаров С. Б. Телекоммуникационные технологии: введе-ние в технологии GSM: учебное пособие для высш. учеб. заведений. / С. Б. Макаров, Н. В. Певцов, Е. А. Попов, М. А. Сиверс. — М.: Изда-тельский центр «Академия», 2006. — 256 с.
7. Рябко Б. Я. Криптографические методы защиты информа-ции: учебное пособие для вузов. / Б. Я Рябко, А. Н. Фионов. — М.: Горячая Линия — Телеком, 2005. — 229 с.
8. Нечаев В. И. Элементы криптографии (Основы теории за-щиты информации): Учебное пособие для университетов и педагоги-ческих вузов. — М.: Высшая школа 1999. — 109 с.
9. Баричев С. Г. Основы современной криптографии. Учеб-ное пособие для высших учебных заведений. / С. Г. Баричев, В. В. Гончаров, Р. Е. Серов. — М.: Горячая линия — Телеком, 2001. — 175 с.
10. Волков А. Н. UMTS. Стандарт сотовой связи третьего по-коления. / А. Н. Волков, А. Е. Рыжков, М. А. Сиверс. — СПб.: Изд-во «Линк», 2008. — 224 с.
175
Ветров Юрий Викторович
Макаров Сергей Борисович
Криптографические методы защиты
информации в телекоммуникационных
системах
Учебное пособие
Лицензия ЛР № 020593 от 07 09 97
Налоговая льгота – Общероссийский классификатор продукции
ОК 005-93, т 2, 953005 – учебная литература
____________________________________________________________
Подготовлено к печати Формат 80х64/16 Печать цифровая
Усл. печ. л. 10,94 Уч.–изд. л. Тираж экз. Заказ
____________________________________________________________ Отпечатано с готового оригинал-макета, предоставленного авторами
в Цифровом типографическом центре
Издательства Политехнического университета
195251, Санкт-Петербург, Политехническая ул., 29
Тел. (812) 550-40-14
Тел./факс. (812) 297-547-76