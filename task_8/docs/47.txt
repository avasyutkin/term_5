А.В. Яковлев, А.А. Безбогов, В.В. Родин, В.Н.
Шамкин
КРИПТОГРАФИЧЕСКАЯ
ЗАЩИТА ИНФОРМАЦИИ
• ИЗДАТЕЛЬСТВО ТГТУ •
А.В. ЯКОВЛЕВ КРИПТОГРАФИЧЕСКАЯ ЗАЩИТА ИНФОРМАЦИИ
Министерство образования и науки Российской Федерации
ГОУ ВПО "Тамбовский государственный технический университет"
А.В. Яковлев, А.А. Безбогов, В.В. Родин, В.Н. Шамкин
КРИПТОГРАФИЧЕСКАЯ ЗАЩИТА
ИНФОРМАЦИИ
Утверждено Ученым советом университета в качестве учебного пособия
Тамбов
Издательство ТГТУ
2006
УДК 681.322.067
ББК z973.26-018.2я73
К824
Рецензенты:
Заведующий кафедрой КРЭМС Заслуженный деятель науки и техники
РФдоктор технических наук, профессор
Ю.Л. Муромцев
Директор РУНЦ по ИБ
Заслуженный работник высшей школы, профессор
Ю.Ф. Мартемьянов
К824 Криптографическая защита информации : учебное пособие / А.В.
Яковлев, А.А. Безбогов, В.В. Родин, В.Н. Шамкин. – Тамбов : Изд-во
Тамб. гос. техн. ун-та, 2006. – 140 с. – 100 экз. – ISBN 5-8265-0503-6.
Содержит материал в соответствии с Государственным образовательным
стандартом по специальности 090105 "Комплексное обеспечение информаци-
онной безопасности автоматизированных систем".
Рассматриваются, классифицируются и анализируются основные алгорит-
мы шифрования, оценивается их эффективность, надежность и особенности
реализации.
Пособие может быть полезно при курсовом и дипломном проектировании,
аспирантам, а также кругу читателей, интересующихся современными про-
блемами криптографической защиты информации.
УДК 681.322.067
ББК z973.26-018.2я73
ISBN 5-8265-0503-6  Яковлев А.В., Безбогов А.А., Родин В.В.,
Шамкин В.Н., 2006
 ГОУ ВПО "Тамбовский государственный
технический университет" (ТГТУ), 2006
Учебное издание
ЯКОВЛЕВ Алексей Вячеславович
БЕЗБОГОВ Александр Александрович
РОДИН Владимир Валентинович,
ШАМКИН Валерий Николаевич
КРИПТОГРАФИЧЕСКАЯ ЗАЩИТА ИН-
ФОРМАЦИИ
Учебное пособие
Редактор З.Г. Чернова
Компьютерное макетирование Е.В. Кораблевой
Подписано в печать 25.09.2006
Формат 60 × 84/16. Бумага офсетная. Гарнитура Тimes New Roman.
8,0 уч.-изд. л. Тираж 100 экз. Заказ № 413
Издательско-полиграфический центр ТГТУ
392000, Тамбов, Советская, 106, к. 14
СОДЕРЖАНИЕ
Введение …………………………………………………………. 5
1. Криптографические системы ………………………. 6
1.1. ИСТОРИЯ КРИПТОГРАФИИ
……………………………...........
6
1.2. ОСНОВНЫЕ ПОНЯТИЯ И ОПРЕДЕЛЕНИЯ
………………………
10
1.3. ТРЕБОВАНИЯ К КРИПТОГРАФИЧЕСКИМ СИСТЕ-
МАМ …………...
13
1.4. КРАТКИЕ СВЕДЕНИЯ О КРИПТОАНАЛИЗЕ
……………………...
14
1.5. КЛАССИФИКАЦИЯ МЕТОДОВ КРИПТОГРАФИЧЕ-
СКОГО ЗАКРЫТИЯ ИНФОРМАЦИИ
………………………………………………. 17
КОНТРОЛЬНЫЕ ВОПРОСЫ
…………………………………………
17
2. СИММЕТРИЧНЫЕ КРИПТОСИСТЕМЫ ………………….... 18
2.1. ОСНОВЫ ТЕОРИИ К. ШЕННОНА
…………………………..…
18
2.2. СИММЕТРИЧНЫЕ МЕТОДЫ ШИФРОВАНИЯ
……………………
19
2.3. АЛГОРИТМЫ БЛОЧНОГО ШИФРОВАНИЯ
………………………
26
2.4. РЕЖИМЫ ПРИМЕНЕНИЯ БЛОЧНЫХ ШИФРОВ
…………………
47
2.5. ПОТОКОВЫЕ ШИФРЫ
……………………………………......
50
2.6. ПРИМЕРЫ ПОТОКОВЫХ ШИФРОВ
…………………………….
61
2.7. КОМБИНИРОВАННЫЕ МЕТОДЫ
……………………………….
64
КОНТРОЛЬНЫЕ ВОПРОСЫ
…………………………………………
71
3. АСИММЕТРИЧНЫЕ КРИПТОСИСТЕМЫ ………………… 72
3.1. ОБЩИЕ ПОЛОЖЕНИЯ
………………………………………..
72
3.2. ОДНОСТОРОННИЕ ФУНКЦИИ И ФУНКЦИИ-
ЛОВУШКИ …………
75
3.3. АСИММЕТРИЧНЫЕ СИСТЕМЫ ШИФРОВАНИЯ
………………….
76
3.4. ПРИМЕНЕНИЕ АСИММЕТРИЧНЫХ АЛГОРИТМОВ
………………
88
КОНТРОЛЬНЫЕ ВОПРОСЫ
…………………………………………
90
4. ЭЛЕКТРОННЫЕ ЦИФРОВЫЕ ПОДПИСИ ………………… 91
4.1. ПОСТАНОВКА ЗАДАЧИ
………………………………………..
91
4.2. АЛГОРИТМЫ ЭЛЕКТРОННОЙ ЦИФРОВОЙ ПОД-
ПИСИ …………...
95
4.3. ФУНКЦИИ ХЭШИРОВАНИЯ
…………………………………...
108
КОНТРОЛЬНЫЕ ВОПРОСЫ
…………………………………………
114
5. УПРАВЛЕНИЕ КРИПТОГРАФИЧЕСКИМИ КЛЮЧАМИ … 115
5.1. ОБЫЧНАЯ СИСТЕМА УПРАВЛЕНИЯ КЛЮЧАМИ
…………………
115
5.2. УПРАВЛЕНИЕ КЛЮЧАМИ, ОСНОВАННОЕ НА
СИСТЕМАХ С ОТКРЫТЫМ КЛЮЧОМ
………………………………………….. 117
5.3. ПРОТОКОЛ ОБМЕНА СЕКРЕТНЫМ КЛЮЧОМ
…………………... 118
5.4. ИСПОЛЬЗОВАНИЕ СЕРТИФИКАТОВ
…………………………… 119
5.5. ПРОТОКОЛЫ АУТЕНТИФИКАЦИИ
…………………………...... 120
5.6. АНОНИМНОЕ РАСПРЕДЕЛЕНИЕ КЛЮЧЕЙ
……………………... 122
КОНТРОЛЬНЫЕ ВОПРОСЫ
………………………………………… 123
6. АППАРАТНО-ПРОГРАММНЫЕ СРЕДСТВА
КРИПТОГРАФИЧЕСКОЙ ЗАЩИТЫ ИНФОРМАЦИИ
……………… 124
6.1. УСТРОЙСТВА КРИПТОГРАФИЧЕСКОЙ ЗАЩИТЫ
ДАННЫХ СЕРИИ "КРИПТОН"
………………………………………………. 124
6.2. СРЕДСТВА КРИПТОГРАФИЧЕСКОЙ ЗАЩИТЫ ИН-
ФОРМАЦИИ "ВЕРБА-О", "ВЕРБА-ОW"
…………………………………. 127
6.3. ПРОГРАММНЫЙ КОМПЛЕКС VCERT PKI
………………… 128
6.4. СРЕДСТВО КРИПТОГРАФИЧЕСКОЙ ЗАЩИТЫ
ИНФОРМАЦИИ КРИПТОПРО CSP
…………………………………..…… 130
6.5. ТЕЛЕФОННЫЙ СКРЕМБЛЕР "ГРОТ"
………………………….. 133
6.6. АППАРАТУРА КРИПТОГРАФИЧЕСКОЙ ЗАЩИТЫ
ИНФОРМАЦИИ Е-20
………………………………………………………... 134
КОНТРОЛЬНЫЕ ВОПРОСЫ
………………………………………… 136
Заключение …………………………………………………….. 135
список Литературы …………………………………………. 138
ВВЕДЕНИЕ
В течение многих лет криптография служила исключительно военным
целям. Сегодня обычные пользователи получают возможность обращаться
к средствам, позволяющим им обезопасить себя от несанкционированного
доступа к конфиденциальной информации, применяя методы компьютер-
ной криптографии.
В настоящем учебном пособии последовательно рассматриваются,
классифицируются и анализируются основные алгоритмы шифрования, их
эффективность, надежность и особенности реализации.
Вначале рассмотрены криптографические системы, приведена краткая
история криптографии, введены основные понятия и определения, указаны
требования к криптографическим системам, представлены сведения о
криптоанализе и рассмотрена классификация методов криптографического
закрытия информации.
Далее описана наиболее распространенная в настоящее время симмет-
ричная криптосистема. Приведены элементы теории, а также методы и ал-
горитмы шифрования. Для алгоритмов блочного шифрования представле-
ны способы генерирования блочного ключа и режимы применения блоч-
ных шифров. Для потоковых шифров приведены методы и алгоритмы
шифрования. Рассмотрены также комбинированные методы симметрично-
го шифрования.
Асимметричные алгоритмы шифрования, получающие все более ши-
рокое распространение, представлены краткими теоретическими сведения-
ми об асимметричном шифровании, обсуждением некоторых распростра-
ненных криптосистем с асимметричным шифрованием, примерами приме-
нения асимметричных алгоритмов шифрования.
Обсуждены вопросы, относящиеся к электронной цифровой подписи,
как к эффективному средству криптозащиты. Рассмотрена постановка за-
дачи верификации сообщений с помощью электронной цифровой подписи,
приведены алгоритмы электронной цифровой подписи, основанные как на
симметричных, так и на асимметричных криптосистемах, представлены
алгоритмы формирования функций хэширования, удовлетворяющих усло-
виям использования в процессе аутентификации сообщений.
Представлена методика управления криптографическими ключами.
Рассмотрены обычная система управления ключами, управление ключами,
основанное на системах с открытым ключом, протокол обмена секретным
ключом, использование сертификатов, протоколы аутентификации и ано-
нимное распределение ключей.
В пособии содержатся сведения по технической реализации алгорит-
мов.
В конце каждой главы приведены контрольные вопросы.
1. КРИПТОГРАФИЧЕСКИЕ СИСТЕМЫ
1.1. ИСТОРИЯ КРИПТОГРАФИИ
С распространением письменности в человеческом обществе появи-
лась потребность в обмене письмами и сообщениями, что вызвало необхо-
димость сокрытия содержимого письменных сообщений от посторонних.
Методы сокрытия содержимого письменных сообщений можно разделить
на три группы. К первой группе относятся методы маскировки или стега-
нографии, которые осуществляют сокрытие самого факта наличия сообще-
ния; вторую группу составляют различные методы тайнописи или крипто-
графии (от греческих слов ktyptos – тайный и grapho – пишу); методы треть-
ей группы ориентированы на создание специальных технических устройств,
засекречивания информации.
История криптографии – ровесница истории человеческого языка. Бо-
лее того, первоначально письменность сама по себе была своеобразной
криптографической системой, так как в древних обществах ею владели
только избранные.
Развитию тайнописи способствовали войны. Письменные приказы и
донесения обязательно шифровались, чтобы пленение курьеров не позво-
лило противнику получить важную информацию. Например, римский им-
ператор Цезарь пользовался в своей военной и личной переписке шифром,
сущность которого состояла в замене каждой буквы латинского языка на
следующую букву алфавита. Тогда знаменитая фраза: "VENI, VIDI, VICI"
("Пришел, увидел, победил"), которой Цезарь, известил одного из своих
друзей в Риме о быстро одержанной им победе, в зашифрованном виде бу-
дет иметь следующий вид: "XFOJ, XJEJ, XJDJ".
Практически одновременно с криптографией стал развиваться и крип-
тоанализ – наука о раскрытии шифров (ключей) по шифртексту.
В истории криптографии условно можно выделить четыре этапа: на-
ивный, формальный, научный; компьютерный.
Для наивной криптографии (до начала XVI в.) характерно использо-
вание любых, обычно примитивных, способов запутывания противника
относительно содержания шифруемых текстов. На начальном этапе для
защиты информации использовались методы кодирования и стеганографии,
которые родственны, но не тождественны криптографии.
Большинство из используемых шифров сводились к перестановке или
моноалфавитной подстановке. Одним из первых зафиксированных приме-
ров является шифр Цезаря, состоящий в замене каждой буквы исходного
текста на другую, отстоящую от нее в алфавите на определенное число по-
зиций. Другой шифр, полибианский квадрат, авторство которого приписы-
вается греческому писателю Полибию, является общей моноалфавитной
подстановкой, которая проводится с помощью случайно заполненной ал-
фавитом квадратной таблицей (для греческого алфавита размер составляет
5 × 5). Каждая буква исходного текста заменяется на букву, стоящую в
квадрате снизу от нее.
Этап формальной криптографии (конец XV – начало XX вв.) связан
с появлением формализованных и относительно стойких к ручному крип-
тоанализу шифров. В европейских странах это произошло в эпоху Возрож-
дения, когда развитие науки и торговли вызвало спрос на надежные спосо-
бы защиты информации. Важная роль на этом этапе принадлежит Леону
Батисте Альберти, итальянскому архитектору, который одним из первых
предложил многоалфавитную подстановку. Данный шифр, получивший
имя дипломата XVI в. Блеза Вижинера, состоял в последовательном "сло-
жении" букв исходного текста с ключом (процедуру можно облегчить с
помощью специальной таблицы). Его работа "Трактат о шифре" (1466 г.)
считается первой научной работой по криптологии.
Одной из первых печатных работ, в которой обобщены и сформулиро-
ваны известные на тот момент алгоритмы шифрования, является труд "По-
лиграфия" (1508 г.) немецкого аббата Иоганна Трисемуса. Ему принадле-
жат два небольших, но важных открытия: способ заполнения полибианско-
го квадрата (первые позиции заполняются с помощью легко запоминаемого
ключевого слова, остальные – оставшимися буквами алфавита) и шифрова-
ние пар букв (биграмм).
Простым, но стойким способом многоалфавитной замены (подстанов-
ки биграмм) является шифр Плейфера, который был открыт в начале XIX в.
Чарльзом Уитстоном. Уитстону принадлежит и важное усовершенствова-
ние – шифрование "двойным квадратом". Шифры Плейфера и Уитстона
использовались вплоть до первой мировой войны, так как с трудом подда-
вались ручному криптоанализу.
В XIX в. голландец Керкхофф сформулировал главное требование к
криптографическим системам, которое остается актуальным и поныне: сек-
ретность шифров должна быть основана на секретности ключа, но не
алгоритма.
Наконец, последним словом в донаучной криптографии, которое
обеспечило еще более высокую криптостойкость, а также позволило авто-
матизировать (в смысле механизировать) процесс шифрования стали ро-
торные криптосистемы.
Одной из первых подобных систем стала изобретенная в 1790 г. Тома-
сом Джефферсоном, будущим президентом США, механическая машина.
Многоалфавитная подстановка с помощью роторной машины реализуется
вариацией взаимного положения вращающихся роторов, каждый из кото-
рых осуществляет "прошитую" в нем подстановку.
Практическое распространение роторные машины получили только в
начале XX в. Одной из первых практически используемых машин, стала
немецкая Enigma, разработанная в 1917 г. Эдвардом Хеберном и усовер-
шенствованная Артуром Кирхом. Роторные машины активно использова-
лись во время второй мировой войны. Помимо немецкой машины Enigma
использовались также устройства Sigaba (США), Турех (Великобритания),
Red, Orange и Purple (Япония). Роторные системы – вершина формальной
криптографии, так как относительно просто реализовывали очень стойкие
шифры. Успешные криптоатаки на роторные системы стали возможны
только с появлением ЭВМ в начале 40-х гг.
Главная отличительная черта научной криптографии (1930 – 60-е гг.)
– появление криптосистем со строгим математическим обоснованием
криптостойкости. К началу 30-х гг. окончательно сформировались разделы
математики, являющиеся научной основой криптологии: теория вероятно-
стей и математическая статистика, общая алгебра, теория чисел, начали
активно развиваться теория алгоритмов, теория информации, кибернетика.
Своеобразным водоразделом стала работа Клода Шеннона "Теория связи в
секретных системах" (1949), которая подвела научную базу под криптогра-
фию и криптоанализ. С этого времени стали говорить о КРИПТОЛОГИИ
(от греческого kryptos – тайный и logos – сообщение) – науке о преобразо-
вании информации для обеспечения ее секретности. Этап развития крипто-
графии и криптоанализа до 1949 г. стали называть донаучной криптологией.
Шеннон ввел понятия "рассеивание" и "перемешивание", обосновал воз-
можность создания сколь угодно стойких криптосистем.
В 1960-х гг. ведущие криптографические школы подошли к созданию
блочных шифров, еще более стойких по сравнению с роторными криптоси-
стемами, однако допускающих практическую реализацию только в виде
цифровых электронных устройств.
Компьютерная криптография (с 1970-х гг.) обязана своим появле-
нием вычислительным средствам с производительностью, достаточной для
реализации криптосистем, обеспечивающих при большой скорости шифро-
вания на несколько порядков более высокую криптостойкость, чем "руч-
ные" и "механические" шифры.
Первым классом криптосистем, практическое применение которых
стало возможно с появлением мощных и компактных вычислительных
средств, стали блочные шифры. В 70-е гг. был разработан американский
стандарт шифрования DES (принят в 1978 г.). Один из его авторов, Хорст
Фейстель (сотрудник IBM), описал модель блочных шифров, на основе ко-
торой были построены другие, более стойкие симметричные криптосисте-
мы, в том числе отечественный стандарт шифрования ГОСТ 28147–89.
С появлением DES обогатился и криптоанализ, для атак на американ-
ский алгоритм был создано несколько новых видов криптоанализа (линей-
ный, дифференциальный и т.д.), практическая реализация которых опять
же была возможна только с появлением мощных вычислительных систем.
В середине 70-х гг. ХХ столетия произошел настоящий прорыв в со-
временной криптографии – появление асимметричных криптосистем, ко-
торые не требовали передачи секретного ключа между сторонами. Здесь
отправной точкой принято считать работу, опубликованную Уитфилдом
Диффи и Мартином Хеллманом в 1976 г. под названием "Новые направле-
ния в современной криптографии". В ней впервые сформулированы прин-
ципы обмена шифрованной информацией без обмена секретным ключом.
Независимо к идее асимметричных криптосистем подошел Ральф Меркли.
Несколькими годами позже Рон Ривест, Ади Шамир и Леонард Адлеман
открыли систему RSA, первую практическую асимметричную криптоси-
стему, стойкость которой была основана на проблеме факторизации боль-
ших простых чисел. Асимметричная криптография открыла сразу несколь-
ко новых прикладных направлений, в частности системы электронной
цифровой подписи (ЭЦП) и электронных денег.
В 1980–90-е гг. появились совершенно новые направления криптогра-
фии: вероятностное шифрование, квантовая криптография и другие. Осоз-
нание их практической ценности еще впереди. Актуальной остается и зада-
ча совершенствования симметричных криптосистем. В этот же период бы-
ли разработаны нефейстелевские шифры (SAFER, RC6 и др.), а в 2000 г.
после открытого международного конкурса был принят новый националь-
ный стандарт шифрования США – AES.
Криптография является одним из наиболее мощных средств обеспече-
ния конфиденциальности и контроля целостности информации. Во многих
отношениях она занимает центральное место среди программно-
технических регуляторов безопасности. Например, для портативных ком-
пьютеров, физически защитить которые крайне трудно, только криптогра-
фия позволяет гарантировать конфиденциальность информации даже в
случае кражи.
Подробнее об увлекательной истории криптографии можно прочитать
в литературе [1, 10, 14].
1.2. ОСНОВНЫЕ ПОНЯТИЯ И ОПРЕДЕЛЕНИЯ
Защита данных с помощью шифрования – одно из возможных реше-
ний проблемы безопасности. Зашифрованные данные становятся доступ-
ными только тем, кто знает, как их расшифровать, и поэтому похищение
зашифрованных данных абсолютно бессмысленно для несанкционирован-
ных пользователей.
Наукой, изучающей математические методы защиты информации пу-
тем ее преобразования, является криптология. Криптология разделяется на
два направления – криптографию и криптоанализ.
Криптография изучает методы преобразования информации, обеспе-
чивающие ее конфиденциальность и аутентичность.
Под конфиденциальностью понимают невозможность получения ин-
формации из преобразованного массива без знания дополнительной ин-
формации (ключа).
Аутентичность информации состоит в подлинности авторства и
целостности.
Криптоанализ объединяет математические методы нарушения кон-
фиденциальности и аутентичности информации без знания ключей.
Существует ряд смежных, но не входящих в криптологию отраслей
знания. Так обеспечением скрытности информации в информационных
массивах занимается стеганография. Обеспечение целостности информа-
ции в условиях случайного воздействия находится в ведении теории поме-
хоустойчивого кодирования. Наконец, смежной областью по отношению к
криптологии являются математические методы сжатия информации.
Современная криптография включает в себя четыре крупных раздела:
симметричные криптосистемы, криптосистемы с открытым ключом, сис-
темы электронной подписи, управление ключами.
Основные направления использования криптографических методов –
передача конфиденциальной информации по каналам связи (например,
электронная почта), установление подлинности передаваемых сообщений,
хранение информации (документов, баз данных) на носителях в зашифро-
ванном виде.
В качестве информации, подлежащей шифрованию и расшифрованию,
а также электронной подписи будут рассматриваться тексты (сообщения),
построенные на некотором алфавите. Под этими терминами понимается
следующее.
Алфавит – конечное множество используемых для кодирования ин-
формации знаков.
Текст (сообщение) – упорядоченный набор из элементов алфавита. В
качестве примеров алфавитов, используемых в современных ИС, можно
привести следующие:
− алфавит Z33 – 32 буквы русского алфавита (исключая "ё") и пробел;
− алфавит Z256 – символы, входящие в стандартные коды ASCII и
КОИ-8;
− двоичный алфавит – Z2 = {0, 1};
− восьмеричный или шестнадцатеричный алфавит.
Коды и шифры использовались задолго до появления ЭВМ. С теоре-
тической точки зрения не существует четкого различия между кодами и
шифрами. Однако в современной практике различие между ними является
достаточно четким. Коды оперируют лингвистическими элементами, раз-
деляя шифруемый текст на такие смысловые элементы, как слова и слоги.
В шифре всегда различают два элемента: алгоритм и ключ.
Алгоритм позволяет использовать сравнительно короткий ключ для
шифрования сколь угодно большого текста.
Определим ряд терминов, используемых в криптологии.
Под шифром понимается совокупность обратимых преобразований
множества открытых данных на множество зашифрованных данных, за-
данных алгоритмом криптографического преобразования.
Шифр – это совокупность инъективных отображений множества от-
крытых текстов во множество шифрованных текстов, проиндексированная
элементами из множества ключей: {Fk : X → S, K ∈ K}.
Криптографическая система, или шифр представляет собой семей-
ство Т обратимых преобразований открытого текста в шифрованный. Чле-
нам этого семейства можно взаимно однозначно сопоставить число k, на-
зываемое ключом. Преобразование Тk определяется соответствующим алго-
ритмом и значением ключа k.
Ключ – конкретное секретное состояние некоторых параметров алго-
ритма криптографического преобразования данных, обеспечивающее вы-
бор одного варианта из совокупности всевозможных для данного алгорит-
ма. Секретность ключа должна обеспечивать невозможность восстановле-
ния исходного текста по шифрованному.
Пространство ключей K – это набор возможных значений ключа.
Обычно ключ представляет собой последовательный ряд букв алфавита.
Следует отличать понятия "ключ" и "пароль". Пароль также является сек-
ретной последовательностью букв алфавита, однако используется не для
шифрования (как ключ), а для аутентификации субъектов.
Криптосистемы подразделяются на симметричные и асимметричные
[или с открытым (публичным) ключом].
В симметричных криптосистемах для зашифрования и для расшифро-
вания используется один и тот же ключ.
В системах с открытым ключом используются два ключа открытый
(публичный) и закрытый (секретный), которые математически связаны
друг с другом. Информация зашифровывается с помощью открытого клю-
ча, который доступен всем желающим, а расшифровывается с помощью
закрытого ключа, известного только получателю сообщения.
Термины распределение ключей и управление ключами относятся к
процессам системы обработки информации, содержанием которых являет-
ся выработка и распределение ключей между пользователями.
Электронной (цифровой) подписью называется присоединяемое к
тексту его криптографическое преобразование, которое позволяет при по-
лучении текста другим пользователем проверить авторство и целостность
сообщения.
Зашифрованием данных называется процесс преобразования откры-
тых данных в зашифрованные с помощью шифра, а расшифрованием дан-
ных – процесс преобразования закрытых данных в открытые с помощью
шифра. Вместо термина "открытые данные" часто употребляются термины
"открытый текст" и "исходный текст", а вместо "зашифрованные дан-
ные" – "шифрованный текст".
Дешифрованием называется процесс преобразования закрытых дан-
ных в открытые при неизвестном ключе и, возможно, неизвестном алго-
ритме, т.е. методами криптоанализа.
Шифрованием называется процесс зашифрования или расшифрова-
ния данных. Также термин шифрование используется как синоним зашиф-
рования. Однако неверно в качестве синонима шифрования использовать
термин "кодирование" (а вместо "шифра" – "код"), так как под кодировани-
ем обычно понимают представление информации в виде знаков (букв ал-
фавита).
Криптостойкостью называется характеристика шифра, определяю-
щая его стойкость к дешифрованию. Обычно эта характеристика определя-
ется периодом времени, необходимым для дешифрования.
Гаммирование – процесс наложения по определенному закону гаммы
шифра на открытые данные.
Гамма шифра – псевдослучайная двоичная последовательность, вы-
рабатываемая по заданному алгоритму, для зашифрования открытых дан-
ных и расшифрования зашифрованных данных.
Имитозащита – защита от навязывания ложных данных. Для обес-
печения имитозащиты к зашифрованным данным добавляется имитовстав-
ка, представляющая собой последовательность данных фиксированной
длины, полученную по определенному правилу из открытых данных и клю-
ча.
Криптографическая защита – это защита данных с помощью крип-
тографического преобразования, под которым понимается преобразование
данных шифрованием и (или) выработкой имитовставки.
Синхропосылка – исходные открытые параметры алгоритма крипто-
графического преобразования.
Уравнение зашифрования (расшифрования) – соотношение, описы-
вающее процесс образования зашифрованных (открытых) данных из от-
крытых (зашифрованных) данных в результате преобразований, заданных
алгоритмом криптографического преобразования.
1.3. ТРЕБОВАНИЯ К КРИПТОГРАФИЧЕСКИМ СИСТЕМАМ
Процесс криптографического закрытия данных может осуществляться
как программно, так и аппаратно. Аппаратная реализация отличается суще-
ственно большей стоимостью, однако ей присущи и преимущества: высокая
производительность, простота, защищенность и т.д. Программная реализация
более практична, допускает известную гибкость в использовании.
Независимо от способа реализации для современных криптографиче-
ских систем защиты информации сформулированы следующие общеприня-
тые требования:
− стойкость шифра противостоять криптоанализу должна быть та-
кой, чтобы вскрытие его могло быть осуществлено только решением зада-
чи полного перебора ключей и должно либо выходить за пределы возмож-
ностей современных компьютеров (с учетом возможности организации
сетевых вычислений) или требовать создания использования дорогих вы-
числительных систем;
− криптостойкость обеспечивается не секретностью алгоритма, а
секретностью ключа (разделяет криптосистемы общего использования (ал-
горитм доступен потенциальному нарушителю) и ограниченного использо-
вания (алгоритм держится в секрете));
− зашифрованное сообщение должно поддаваться чтению только при
наличии ключа;
− шифр должен быть стойким даже в случае, если нарушителю из-
вестно достаточно большое количество исходных данных и соответствую-
щих им зашифрованных данных;
− незначительное изменение ключа или исходного текста должно
приводить к существенному изменению вида зашифрованного текста;
− структурные элементы алгоритма шифрования должны быть неиз-
менными;
− шифртекст не должен существенно превосходить по объему ис-
ходную информацию; дополнительные биты, вводимые в сообщение в
процессе шифрования, должны быть полностью и надежно скрыты в шиф-
рованном тексте;
− ошибки, возникающие при шифровании, не должны приводить к
искажениям и потерям информации;
− не должно быть простых и легко устанавливаемых зависимостей
между ключами, последовательно используемыми в процессе шифрования;
− любой ключ из множества возможных должен обеспечивать рав-
ную криптостойкость (обеспечение линейного (однородного) пространства
ключей);
− время шифрования не должно быть большим;
− стоимость шифрования должна быть согласована со стоимостью
закрываемой информации.
1.4. КРАТКИЕ СВЕДЕНИЯ О КРИПТОАНАЛИЗЕ
Знание некоторых положений криптоанализа необходимо для глубо-
кого понимания криптографии.
Главным действующим лицом в криптоанализе выступает нарушитель
(или криптоаналитик). Под ним понимают лицо (группу лиц), целью кото-
рых является прочтение или подделка защищенных криптографическими
методами сообщений.
В отношении нарушителя принимается ряд допущений, которые, как
правило, кладутся в основу математических или иных моделей:
1. Нарушитель знает алгоритм шифрования (или выработки ЭЦП) и
особенности его реализации в конкретном случае, но не знает секретного
ключа.
2. Нарушителю доступны все зашифрованные тексты. Нарушитель
может иметь доступ к некоторым исходным текстам, для которых известны
соответствующие им зашифрованные тексты.
3. Нарушитель имеет в своем распоряжении вычислительные, люд-
ские, временные и иные ресурсы, объем которых оправдан потенциальной
ценностью информации, которая будет добыта в результате криптоанализа.
Попытку прочтения или подделки зашифрованного сообщения, вы-
числения ключа методами криптоанализа называют криптоатакой или
атакой на шифр. Удачную криптоатаку называют взломом.
Криптостойкостью называется характеристика шифра, определяю-
щая его стойкость к расшифрованию без знания ключа (т.е. криптоатаке).
Показатель криптостойкости – главный параметр любой криптосистемы. В
качестве показателя криптостойкости можно выбрать:
− количество всех возможных ключей или вероятность подбора клю-
ча за заданное время с заданными ресурсами;
− количество операций или время (с заданными ресурсами), необхо-
димое для взлома шифра с заданной вероятностью;
− стоимость вычисления ключевой информации или исходного тек-
ста.
Все эти показатели должны учитывать также уровень возможной
криптоатаки.
Однако следует понимать, что эффективность защиты информации
криптографическими методами зависит не только от криптостойкости
шифра, но и от множества других факторов, включая вопросы реализации
криптосистем в виде устройств или программ. При анализе криптостойко-
сти шифра необходимо учитывать и человеческий фактор. Например, под-
куп конкретного человека, в руках которого сосредоточена необходимая
информация, может стоить на несколько порядков дешевле, чем создание
суперкомпьютера для взлома шифра
Современный криптоанализ опирается на такие математические науки
как теория вероятностей и математическая статистика, алгебра, теория чи-
сел, теория алгоритмов и ряд других. Все методы криптоанализа в целом
укладываются в четыре направления.
1. Статистический криптоанализ – исследует возможности взлома
криптосистем на основе изучения статистических закономерностей исход-
ных и зашифрованных сообщений. Его применение осложнено тем, что в
реальных криптосистемах информация перед шифрованием подвергается
сжатию (превращая исходный текст в случайную последовательность сим-
волов), или в случае гаммирования используются псевдослучайные после-
довательности большой длины.
2. Алгебраический криптоанализ – занимается поиском математически
слабых звеньев криптоалгоритмов. Например, в 1997 г. в эллиптических
системах был выявлен класс ключей, существенно упрощавший криптоа-
нализ.
3. Дифференциальный (или разностный) криптоанализ – основан на
анализе зависимости изменения шифрованного текста от изменения исход-
ного текста. Впервые использован Мерфи, улучшен Бихэмом и Шамиром
для атаки на DES.
4. Линейный криптоанализ – метод, основанный на поиске линейной
аппроксимации между исходным и шифрованным текстом. Предложенный
Мацуи, также впервые был применен при взломе DES. Как и дифференци-
альный анализ в реальных криптосистемах может быть применен только для
анализа отдельных блоков криптопреобразований.
Опыт взломов криптосистем (в частности, конкурсов, которые регу-
лярно устраивает RSA Data Security) показывает, что главным методом ос-
тается "лобовая" атака – проба на ключ. Также как показывает опыт крип-
тосистемы больше страдают от небрежности в реализации.
Принято различать несколько уровней криптоатаки в зависимости от
объем информации, доступной криптоаналитику. Можно выделить три
уровня криптоатаки по нарастанию сложности.
1. Атака по шифрованному тексту (Уровень КА1) – нарушителю дос-
тупны все или некоторые зашифрованные сообщения.
2. Атака по паре "исходный текст – шифрованный текст" (Уровень
КА2) – нарушителю доступны все или некоторые зашифрованные сообще-
ния и соответствующие им исходные сообщения.
3. Атака по выбранной паре "исходный текст – шифрованный текст"
(Уровень КА3) – нарушитель имеет возможность выбирать исходный текст,
получать для него шифрованный текст и на основе анализа зависимостей
между ними вычислять ключ.
Все современные криптосистемы обладают достаточной стойкостью
даже к атакам уровня КА3, т.е. когда нарушителю доступно по сути шиф-
рующее устройство.
1.5. КЛАССИФИКАЦИЯ МЕТОДОВ КРИПТОГРАФИЧЕСКОГО ЗА-
КРЫТИЯ ИНФОРМАЦИИ
В настоящее время известно большое число методов криптографиче-
ского закрытия информации. Классификация методов шифрования (крип-
тоалгоритмов) может быть осуществлена по следующим признакам:
• по типу ключей: симметричные криптоалгоритмы; асимметричные
криптоалгоритмы;
• по размеру блока информации: потоковые шифры; блочные шифры;
• по характеру воздействий, производимых над данными: метод заме-
ны (перестановки), метод подстановки; аналитические методы, аддитивные
методы (гаммирование), комбинированные методы.
Кодирование может быть смысловое, символьное, комбинированное.
Закрытие информации другими способами может достигаться с по-
мощью стеганографии, сжатия/расширения, рассечения/разнесения.
Одна из схем классификации методов криптографического закрытия
информации приведена на рис. 1.1.
Контрольные вопросы
1. Назовите и охарактеризуйте основные этапы развития криптогра-
фии.
2. Дайте определение криптологии, криптографии и криптоанализа.
3. Сформулируйте основные направления в современной криптогра-
фии.
4. Дайте определение основных понятий криптографической защиты
информации.
5. Сформулируйте основные требования к криптосистемам.
6. Приведите классификацию методов криптографического пре-
образования информации.
7. Каковы перспективы криптозащиты информации в КС.
2. СИММЕТРИЧНЫЕ КРИПТОСИСТЕМЫ
2.1. ОСНОВЫ ТЕОРИИ К. ШЕННОНА
Клод Шеннон рассмотрел модель (рис. 2.1), в которой источник сооб-
щений порождает открытый текст X. Источник ключей генерирует ключ Z.
Шифратор преобразовывает открытый текст X с помощью ключа Z в
шифртекст Y: Y = TzX.
Дешифратор, получив зашифрованное сообщение Y, выполняет обрат-
ную операцию: X = Tx(–1) Y.
Задачей криптоаналитика противника является получение открытого
текста и ключа на основе анализа шифртекста.
Шеннон рассмотрел вопросы теоретической и практической секретно-
сти. Для определения теоретической секретности Шеннон сформулировал
следующие вопросы:
1. Насколько устойчива система, если криптоаналитик противника не
ограничен временем и обладает всеми необходимыми средствами для ана-
лиза криптограмм?
2. Имеет ли криптограмма единственное решение?
3. Какой объем шифртекста необходимо перехватить криптоаналити-
ку, чтобы решение стало единственным?
Для ответа на эти вопросы Шеннон ввел понятие совершенной сек-
ретности с помощью следующего условия: для всех Y апостериорные веро-
ятности равны априорным вероятностям, т.е. перехват зашифрованного
сообщения не дает криптоаналитику противника никакой информации. По
теореме Байеса
Py(X) = P(X)Px(Y)/P(Y),
где P(X) – априорная вероятность сообщения Х; Рx(Y) – условная вероят-
ность криптограммы Y при условии, что выбрано сообщение X, т.е. сумма
вероятностей всех тех ключей, которые переводят сообщение X в крипто-
грамму Y; P(Y) – вероятность получения криптограммы Y; Рy(Х) – апосте-
риорная вероятность сообщения X при условии, что перехвачена крипто-
грамма Y. Для совершенной секретности значения Рy(Х) и Р(Х) должны
быть равны для всех X и Y.
Для противодействия методам статистического анализа криптограмм
Шеннон предложил использовать два метода: рассеивание и перемешива-
ние.
2.2. СИММЕТРИЧНЫЕ МЕТОДЫ ШИФРОВАНИЯ
2.2.1. ОСНОВНЫЕ КЛАССЫ СИММЕТРИЧНЫХ КРИПТОСИСТЕМ
Под симметричными криптографическими системами понимаются та-
кие криптосистемы, в которых для шифрования и расшифрования исполь-
зуется один и тот же ключ, хранящийся в секрете (рис. 2.2).
Для пользователей это означает, что прежде, чем начать использовать
систему, необходимо получить общий секретный ключ так, чтобы исклю-
Источник
ключей
Источник
сообщений
Приемник
сообщений
Шифратор
Дешифра-
тор
Защищенный
канал
X Y
Z
Z
Y X
Криптоана-
литик про-
тивника
Z’
Рис. 2.1. Общая схема передачи шифрованных сообщений
X’
чить к нему доступ потенциального злоумышленника. Все многообразие
симметричных криптосистем основывается на следующих базовых классах.
Моно- и многоалфавитные подстановки. Моноалфавитные подста-
новки – это наиболее простой вид преобразований, заключающийся в заме-
не символов исходного текста на другие (того же алфавита) по более или
менее сложному правилу. В случае моноалфавитных подстановок каждый
символ исходного текста преобразуется в символ шифрованного текста по
одному и тому же закону. При многоалфавитной подстановке закон преоб-
разования меняется от символа к символу. Один и тот же шифр может рас-
сматриваться и как моно- и как многоалфавитный в зависимости от опре-
деляемого алфавита. Например, шифр Плейфера (подстановка биграмм) с
точки зрения обычного алфавита является моноалфавитным, а с точки зре-
ния алфавита биграмм – многоалфавитным.
Перестановки – также несложный метод криптографического преоб-
разования, заключающийся в перестановке местами символов исходного
текста по некоторому правилу. Шифры перестановок в настоящее время не
используются в чистом виде, так как их криптостойкость недостаточна.
Блочные шифры – семейство обратимых преобразований блоков (час-
тей фиксированной длины) исходного текста. Фактически блочный шифр –
это система подстановки на алфавите блоков (она может быть моно- или
многоалфавитной в зависимости от режима блочного шифра). В настоя-
щее время блочные шифры наиболее распространены на практике. Рос-
сийский и американский стандарты шифрования (ГОСТ 28147–89 "Систе-
мы обработки информации. Защита криптографическая. Алгоритм крипто-
графического преобразования" и DES) относятся именно к этому классу
шифров.
Гаммирование – преобразование исходного текста, при котором сим-
волы исходного текста складываются (по модулю, равному мощности ал-
фавита) с символами псевдослучайной последовательности, вырабатывае-
мой по некоторому правилу. Собственно говоря, гаммирование нельзя це-
ликом выделить в отдельный класс криптографических преобразований,
так как эта псевдослучайная последовательность может вырабатываться,
например, с помощью блочного шифра. В случае, если последовательность
является истинно случайной (например, снятой с физического датчика) и
каждый ее фрагмент используется только один раз, то имеет место крипто-
система с одноразовым ключом.
Далее речь будет идти о защите сообщений, хотя события могут раз-
виваться не только в пространстве, но и во времени, когда шифруются и
расшифровываются никуда не перемещающиеся файлы.
Основным недостатком симметричного шифрования является то, что
секретный ключ должен быть известен и отправителю, и получателю. С од-
ной стороны, это ставит новую проблему рассылки ключей. С другой сто-
роны, получатель на основании наличия шифрованного и расшифрованно-
го сообщения не может доказать, что он получил это сообщение от кон-
кретного отправителя, поскольку такое же сообщение он мог сгенерировать
Сообщение (X)
Сообщение
(X = Ek
–1(k, Y))
Зашифрование
Зашифрованное
сообщение (Y =
Ek(X, K))
Расшифрование
Общий секретный ключ (k)
Ключ
Ключ
Генератор ключей
Рис. 2.2. Использование симметричного метода шифрования
и сам.
2.2.2. ОБЩИЕ СВЕДЕНИЯ О БЛОЧНЫХ ШИФРАХ
Под N-разрядным блоком будем понимать последовательность из ну-
лей и единиц длины N [ГОСТ Р 34.10–2001]:
x = (x0 , x1, ..., xN−1)∈Z2,N ,
где х в Z2,N можно интерпретировать как вектор и как двоичное представ-
ление целого числа:
Σ−
=
= − −
1
0
2 1
N
i
N i
x xi .
Например, если N = 4, то
(0,0,0,0)􀃖0 (0,0,0,1)􀃖1 (0,0,1,0)􀃖2 (0,0,1,1)􀃖3
(0,1,0,0)􀃖4 (0,1,0,1)􀃖5 (0,1,1,0)􀃖6 (0,1,1,1)􀃖7
(1,0,0,0)􀃖8 (1,0,0,1)􀃖9 (1,0,1,0)􀃖10 (1,0,1,1)􀃖11
(1,1,0,0)􀃖12 (1,1,0,1)􀃖13 (1,1,1,0)􀃖14 (1,1,1,1)􀃖15
Блочным шифром будем называть элемент
π∈SYM(Z2,N ); π : x → y = π(x),
где x = (x0 , x1, ..., xN−1) , y = ( y0 , y1, ..., yN−1) . Хотя блочные шифры явля-
ются частными случаями подстановок их следует рассматривать особо, так
как, во-первых, большинство симметричных шифров, используемых в сис-
темах передачи информации, являются блочными и, во-вторых, блочные
шифры удобнее всего описывать в алгоритмическом виде, а не как обыч-
ные подстановки.
Если исходный текст шифруется подстановкой π, выбранной из пол-
ной симметрической группы, то злоумышленник, изучающий соответствие
между подмножествами исходного и шифрованного текстов
хi ↔ yi , 0 ≤ i ≤ m,
не в состоянии на основе этой информации определить исходный текст,
соответствующий y∉{yi}.
Если для шифрования исходного текста используется подсистема π из
Π ∈ SYM(Z2,N), то получающуюся в результате систему подстановок Π на-
зывают системой блочных шифров или системой блочных подстановок.
Блочный шифр представляет собой частный случай моноалфавитной под-
становки с алфавитом Z N 2 = Z2,N . Если информация исходного текста не
может быть представлена N-разрядными блоками, как в случае стандартно-
го алфавитно-цифрового текста, то первое, что нужно сделать, это переко-
дировать исходный текст именно в этот формат, причем с практической
точки зрения неважно, какой из способов перекодирование был применен.
Ключевой системой блочных шифров является подмножество Π[K] сим-
метрической группы SYM(Z2,N)
П[K] = {π{k}: k ∈ K} ,
индексируемое по параметру k ∈K ; k является ключом, а K –
пространством ключей. При этом не требуется, чтобы различные ключи
соответствовали различным подстановкам Z2,N .
Ключевая система блочных шифров Π[K] используется следующим
образом. Пользователь i и пользователь j некоторым образом заключают
соглашение относительно ключа k из K, выбирая, таким образом, элемент
из Π[K] и передавая текст, зашифрованный с использованием выбранной
подстановки. Запись y = π{k, x} используется для обозначения N-
разрядного блока шифрованного текста, который получен в результате
шифрования N-разрядного блока исходного текста х с использованием под-
становки π{k} , соответствующей ключу k. Предположим, что злоумыш-
леннику:
• известно пространство ключей K;
• известен алгоритм определения подстановки π{k} по значению
ключа k;
• неизвестно, какой именно ключ k выбрал пользователь.
• Какими возможностями располагает злоумышленник? Он может:
• получить ключ вследствие небрежности пользователя i или пользова-
теля j;
• перехватить шифрованный текст у, передаваемый пользователем i
пользователю j, и производить пробы на все возможные ключи из K до по-
лучения читаемого сообщения исходного текста;
• получить соответствующие исходный и шифрованный тексты x → y
и воспользоваться методом пробы на ключ;
• получить соответствующие исходный и шифрованный тексты и ис-
следовать соотношение исходного текста х и шифрованного текста у для
определения ключа k;
• организовать каталог N-разрядных блоков с записью частот их появ-
ления в исходном или шифрованном тексте. Каталог дает возможность
производить поиск наиболее вероятных слов, используя, например, сле-
дующую информацию: листинг на языке ассемблера характеризуется силь-
но выраженным структурированным форматом, цифровое представление
графической и звуковой информации имеет ограниченный набор знаков.
Предположим, что N = 64 и каждый элемент SYM(Z2,N) может быть ис-
пользован как подстановка, так что K = SYM(Z2,N). Тогда:
• существует 264 64-разрядных блоков, но злоумышленник не может
поддерживать каталог с 264 ≈ 1,8 ⋅ 1019 строками;
• проба на ключ при числе ключей, равном (264)!, практически невоз-
можна; соответствие исходного и шифрованного текстов для некоторых N-
разрядных блоков π{k, xi} , 0 ≤ i < m, не дает злоумышленнику информа-
ции относительно значения π{k, x} для х ∉ {xi}.
Системы шифрования с блочными шифрами, алфавитом Z2,64 и про-
странством ключей K = SYM(Z2,64) являются неделимыми в том смысле, что
поддержание каталога частот появления букв для 64-разрядных блоков или
проба на ключ при числе ключей 264 выходит за пределы возможностей
злоумышленника. Следует сравнить эту проблему с той задачей, с которой
сталкивается злоумышленник в процессе криптоанализа текста, зашифро-
ванного подстановкой Цезаря с алфавитом {А, ..., Я, _}; для определения
ключа подстановки Цезаря требуется лишь log232 = 5 бит, в то время как
для пространства ключей K = SYM(Z2,64) требуется 264 бит.
К сожалению, разработчик и злоумышленник находятся в одинаковом
положении: разработчик не может создать систему, в которой были бы реа-
лизованы все 264! подстановок SYM(Z2,64), а злоумышленник не может ис-
пытать такое число ключей. Остается согласиться с тем, что не каждый
элемент из SYM(Z2,64) будет использован в качестве подстановки.
Таким образом, требования к хорошему блочному шифру формули-
руются следующим образом. Необходимы:
• достаточно большое N (64 или более) для того, чтобы затруднить со-
ставление и поддержание каталога (в новом стандарте шифрования США N
не менее 128);
• достаточно большое пространство ключей для того, чтобы исклю-
чить возможность подбора ключа;
• сложные соотношения π{k, x}: х → y = π{k, x} между исходным и
шифрованным текстами с тем, чтобы аналитические и (или) статистические
методы определения исходного текста и (или) ключа на основе соответст-
вия исходного и шифрованного текстов были бы по возможности нереали-
зуемы.
2.1. Характеристики криптографических алгоритмов
Название
алгоритма Автор Размер блока Длина ключа
IDEA Xuejia Lia and James Massey 64 бита 128 бит
CAST128 64 бита 128 бит
BlowFish Bruce Schneier 64 бита 128…448 бит
ГОСТ НИИ 64 бита 256 бит
TwoFish Bruce Schneier 128 бит 128…256 бит
MARS Корпорация IBM 128 бит 128…1048 бит
2.2.3. ГЕНЕРИРОВАНИЕ БЛОЧНЫХ ШИФРОВ
Одним из наиболее распространенных способов задания блочных
шифров является использование так называемых сетей Фейстеля. Сеть
Фейстеля представляет собой общий метод преобразования произвольной
функции (обычно называемой F-функцией) в перестановку на множестве
блоков. Эта конструкция была изобретена Хорстом Фейстелем и была ис-
пользована в большом количестве шифров, включая DES и ГОСТ 28147–
89. F-функция, представляющая собой основной строительный блок сети
Фейстеля, всегда выбирается нелинейной и практически во всех случаях
необратимой.
Формально F-функцию можно представить в виде отображения
F : Z2,N / 2Z2,k →Z2,N / 2 ,
где N – длина преобразуемого блока текста (должна быть четной); k – дли-
на используемого блока ключевой информации.
Пусть теперь X – блок текста, представим его в виде двух подблоков
одинаковой длины X = {А, В}. Тогда одна итерация (или раунд) сети Фей-
стеля определяется как
Xi+1 = B1 (F(B1, ki )⊕ Ai ) ,
где Xi = {Ai , Bi}, || операция конкатенации, а ⊕ – побитовое исключающее
ИЛИ.
Рис. 2.3. Структура итерации сети Фейстеля
Структура итерации сети Фейстеля представлена на рис. 2.3. Сеть
Фейстеля состоит из некоторого фиксированного числа итераций, определяе-
мого соображениями стойкости разрабатываемого шифра, при этом на послед-
ней итерации перестановка местами половин блока текста не производится,
так как это не влияет на стойкость шифра.
Данная структура шифров обладает рядом достоинств, а именно:
• процедуры шифрования и расшифрования совпадают, с тем ис-
ключением, что ключевая информация при расшифровании используется в
обратном порядке;
• для построения устройств шифрования можно использовать те же
блоки в цепях шифрования и расшифрования.
Недостатком является то, что на каждой итерации изменяется только
половина блока обрабатываемого текста, что приводит к необходимости
увеличивать число итераций для достижения требуемой стойкости.
В отношении выбора F-функции каких-то четких стандартов не суще-
А B
F
k
B A ⊕ F(B)
ствует, однако, как правило, эта функция представляет собой последова-
тельность зависящих от ключа нелинейных замен, перемешивающих пере-
становок и сдвигов.
Другим подходом к построению блочных шифров является использо-
вание обратимых зависящих от ключа преобразований. В этом случае на
каждой итерации изменяется весь блок и, соответственно, общее количест-
во итераций может быть сокращено. Каждая итерация представляет собой
последовательность преобразований (так называемых "слоев"), каждое из
которых выполняет свою функцию. Обычно используются слой нелиней-
ной обратимой замены, слой линейного перемешивания и один или два
слоя подмешивания ключа K недостаткам данного подхода можно отнести
то, что для процедур шифрования и расшифрования в общем случае нельзя
использовать одни и те же блоки, что увеличивает аппаратные и/или про-
граммные затраты на реализацию.
2.3. АЛГОРИТМЫ БЛОЧНОГО ШИФРОВАНИЯ
2.3.1. АЛГОРИТМ DES И ЕГО МОДИФИКАЦИИ
Американский стандарт криптографического закрытия данных DES
(Data Encryption Standard), принятый в 1978 г., является типичным пред-
ставителем семейства блочных шифров и одним из наиболее распростра-
ненных криптографических стандартов на шифрование данных, применяе-
мых в США. Этот шифр допускает эффективную аппаратную и программ-
ную реализацию, причем возможно достижение скоростей шифрования до
нескольких мегабайт в секунду.
Первоначально метод, лежащий в основе данного стандарта, был раз-
работан фирмой IBM для своих целей. Он был проверен Агентством На-
циональной Безопасности США, которое не обнаружило в нем статистиче-
ских или математических изъянов.
Стандарт DES используется федеральными департаментами и агентст-
вами для защиты всех достаточно важных данных в компьютерах (исклю-
чая некоторые данные, методы защиты которых определяются специаль-
ными актами). Его применяют многие негосударственные институты, в том
числе большинство банков и служб обращения денег. Оговоренный в стан-
дарте алгоритм криптографической защиты данных опубликован для того,
чтобы большинство пользователей могли использовать проверенный и ап-
робированный алгоритм с хорошей криптостойкостью. Однако, с одной
стороны, публикация алгоритма нежелательна, поскольку может привести
к попыткам дешифрования закрытой информации, но, с другой стороны,
это не столь существенно поскольку стандартный алгоритм шифрования
данных должен обладать такими характеристиками, чтобы его опубликова-
ние не сказалось на его криптостойкости.
DES имеет блоки по 64 бит и основан на 16-кратной перестановке
данных, также для шифрования использует ключ в 56 бит. Существует не-
сколько режимов DES: Electronic Code Book (ECB) и Cipher Block Chaining
(CBC).
56 бит – это 8 семибитовых ASCII символов, т.е. пароль не может быть
больше чем 8 букв. Если вдобавок использовать только буквы и цифры, то
количество возможных вариантов будет существенно меньше максимально
возможных 256.
Шифр DES представляет собой результат 33 отображений:
Xi+1 = B1 (F(B1, ki )⊕ Ai ) ,
где IP (Initial Permutation – исходная перестановка) представляет собой
проволочную коммутацию с инверсией IP–1:
58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,
62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3,
61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7,
композиция Θ × πТi , где Θ – перестановка местами правой и левой поло-
вин блока данных, представляет собой одну итерацию Фейстеля. В послед-
нем цикле шифрования по алгоритму DES перестановка местами половин
блока не производится.
Подстановки πТi , 1< i < 16, описываются следующим образом (см.
рис. 2.4).
Шаг 1. На i-м цикле входной блок хi длиной 64 символа
( i,0 , i,1, ..., i,63 )
хi = х х х
делится на два блока по 32 символа:
Х = (хi,0 , хi,1, ..., хi,31) и Х ′ = (хi′,0 , хi′,1, ..., хi′,31) .
Правый блок X' разбивается на восемь блоков по четыре символа:
x′i,0 x′i,1 x′i,2 x′i,3
x′i,4 x′i,5 x′i,6 x′i,7
x′i,8 x′i,9 x′i,10 x′i,11
x′i,12 x′i,13 x′i,14 x′i,15
x′i,16 x′i,17 x′i,18 x′i,19
x′i,20 x′i,21 x′i,22 x′i,23
x′i,24 x′i,25 x′i,26 x′i,27
x′i,28 x′i,29 x′i,30 x′i,31
Рис. 2.4. Схема алгоритма шифрования DES
Эти восемь блоков путем копирования крайних элементов преобразу-
ются в восемь блоков из шести символов:
x′i,31 x′i,0 x′i,1 x′i,2 x′i,3 x′i,4
x′i,3 x′i,4 x′i,5 x′i,6 x′i,7 x′i,8
x′i,7 x′i,8 x′i,9 x′i,10 x′i,11 x′i,12
x′i,11 x′i,12 x′i,13 x′i,14 x′i,15 x′i,16
x′i,15 x′i,16 x′i,17 x′i,18 x′i,19 x′i,20
x′i,19 x′i,20 x′i,21 x′i,22 x′i,23 x′i,24
x′i,23 x′i,24 x′i,25 x′i,26 x′i,27 x′i,28
x′i,27 x′i,28 x′i,29 x′i,30 x′i,31 x′i,0
Шаг 2. На i-циклической итерации 48 разрядов ключа
(ki,0 , ki,1, ..., ki,48 )
поразрядно суммируются (по модулю 2) с полученными выше 48 разряда-
ми данных.
L0 R0
P
L1 = R0
L2 = R1
L15 = R14
L16 = R15
IP–1
f
f
Ki
K16
K2
K1
f
f
R1 = L0⊕f (R0, K1)
R2 = L1⊕f (R1, K2)
R16 = L15⊕f (R15, K16)
R15 = L14⊕f (R14, K15)
Шаг 3. j-й блок из шести символов (0 < j < 8) подается на вход блока
подстановки (S-бокс) S[j], который имеет шестиразрядный вход и четырех-
разрядный выход и представляет собой четыре преобразования из Z2,4 в Z2,4;
два крайних разряда входного блока служат для выборки одного из этих
преобразований. Каждая из восьми подстановок S[0], S[l], ..., S[7] осущест-
вляется с использованием четырех строк и 16 столбцов матрицы с элемен-
тами {0, 1, ..., 15}. Каждый из массивов размерностью 4 × 16 определяет
подстановку на множестве Z2,4 следующим образом. Если входом является
блок из шести символов (z0, z1, z2, z3, z4, z5), то две крайние позиции (z0, z5)
интерпретируются как двоичное представление целых чисел из набора {0,
1, 2, 3}. Эти целые определяют номер строки (от 0 до 3). Оставшиеся четы-
ре символа (z1, z2, z3, z4) интерпретируются как двоичное представление
целых чисел из набора {0, 1, ..., 15} и служат для определения столбца в
массиве (от 0 до 15). Таким образом, входной блок (0, 0, 1, 0, 1, 1) соответ-
ствует строке 1 и столбцу 5.
Шаг 4. 32 разряда, составляющие выход S-бокса, подаются на вход
блока проволочной коммутации (Р-бокса):
16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10,
2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25
Шаг 5. Компоненты правого входного 32-разрядного блока X', преоб-
разованного в Т(Х'), поразрядно суммируются по модулю 2 с компонентами
левого входного 32-разрядного блока X.
На каждой итерации используется 48-разрядный подключ
(ki,0 , ki,1, ..., ki,48 ) . Поскольку входным ключом DES является 56-
разрядный блок k = (ki,0 , ki,1, ..., ki,56 ) , то каждый его разряд используется
многократно.
Какие именно разряды ключа используются на i-циклической итера-
ции, определяется по следующему алгоритму:
• прежде всего 64 разряда ключа преобразуются в 56 путем выбрасы-
вания каждого восьмого бита (который может использоваться для контроля
целостности ключа);
• производится начальная перестановка КР-1 56-разрядного ключа
пользователя k = (ki,0 , ki,1, ..., ki,56 ) :
57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18,
10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36,
63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22,
14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4.
Получаемый в результате 56-разрядный блок рассматривается как два
28-разрядных блока: левый – С0 и правый – D0;
• производится левый циклический сдвиг блоков С0 и D0 s[1] раз для
получения блоков С1 и D1;
• из сцепления блоков (С1 и D1) выбираются 48 разрядов с помощью
перестановки КР-2. Эти разряды используются на первой итерации;
14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10,
23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2,
41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32
используемые на i-й циклической итерации разряды ключа определяются
методом индукции. Для получения блоков Сi и Di производим левый цик-
лический сдвиг блоков Сi–1 и Di–1 на s[i] позиций:
i 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
S 1 1 2 2 2 2 2 2 1 2 2 2 2 2 2 1
и вновь применяем КР-2 для получения очередной порции ключа.
Инверсией DES (обеспечивающей расшифрование зашифрованных
посредством DES данных) является
DES = IP− × πT ×Θ× πТ × IP
1 16 1 ... .
Расшифрование зашифрованного посредством DES текста осуществ-
ляется с использованием тех же блоков благодаря обратимости преобразо-
вания.
Анализ алгоритма DES на эффективность показывает, что поскольку
длина блоков исходного текста равна 64, поддержка каталогов частот ис-
пользования блоков является для злоумышленника задачей, выходящей за
пределы современных технических возможностей.
Однако, данный алгоритм, являясь первым опытом стандарта шифро-
вания имеет ряд недостатков. За время, прошедшее после создания DES,
компьютерная техника развилась настолько быстро, что оказалось возмож-
ным осуществлять исчерпывающий перебор ключей и тем самым раскры-
вать шифр. Стоимость этой атаки постоянно снижается. В 1998 г. была по-
строена машина стоимостью около 100 000 долларов, способная по данной
паре <исходный текст, шифрованный текст> восстановить ключ за среднее
время в трое суток. Таким образом, DES, при его использовании стандарт-
ным образом, уже стал далеко не оптимальным выбором для удовлетворе-
ния требованиям скрытности данных.
Большое количество предложений по усовершенствованию DES от-
части компенсируют указанные недостатки, рассмотрим два из них.
Наиболее широко известным предложением по усилению DES являет-
ся так называемый "тройной DES", одна из версий которого определяется
формулой
3 ( ) ( ( 1( ))).
1
ЕDE k1k 2k3 x DESk3 DESk 2 DESk x
= −
To есть, ключ для EDE3 имеет длину 56 × 3 = 168 бит, и шифрование
64-битового блока осуществляется шифрованием с одним подключом,
расшифрованием с другим и затем шифрованием с третьим. (Причина, по
которой вторым шагом является 1
2
−
DESk , а не DESk 2 , является совмести-
мость с DES: если выбрать K = k, k, k , то EDE3k = DESk. Причина использо-
вания DES три раза вместо двух заключается в существовании атаки
"встреча в середине" на двойной DES).
Проблема с тройным DES состоит в том, что он гораздо медленнее, чем
сам DES, – его скорость составляет ровно одну треть исходной. При использо-
вании EDE3 в режиме сцепления блоков это замедление скажется как на аппа-
ратном, так и на программном (даже если попытаться компенсировать его
дополнительной аппаратной частью) уровнях. Во многих случаях такое
падение производительности неприемлемо.
В 1984 г. Рон Ривест предложил расширение DES, называемое DESX
(DES eXtended), свободное от недостатков тройного DES. DESX определя-
ется как
DESk,k1,k 2 = k2 ⊗ DESk (k1 ⊕ x).
Ключ DESX 1 2 K = k, k , k состоит из 54 + 64 + 64 = 184 бит и включает
три различных подключа: ключ "DES" k, предварительный "зашумляющий"
ключ k1 и завершающий "зашумляющий" ключ k2.
Для шифрования блока сообщения сложим его поразрядно по модулю
2 с k1, шифруем его алгоритмом DES с ключом k и вновь поразрядно скла-
дываем его по модулю 2 с k2. Таким образом, затраты DESX на шифрование
блока всего на две операции сложения по модулю 2 больше, чем затраты
исходного алгоритма.
В отношении DESX замечательно то, что эти две операции "исклю-
чающее ИЛИ" делают шифр гораздо менее уязвимым по отношению к пе-
ребору ключей. DESX затрудняет получение даже одной пары
〈 xi , DESK (xi ) 〉 в том случае, когда злоумышленник организует атаку на
шифр по выбранному исходному тексту, получая множество пар
, ( ) j K j < P DES P >
DESX предназначался для увеличения защищенности DES против пе-
ребора ключей и сохранения его стойкости против других возможных атак.
Но DESX в действительности также увеличивает стойкость против диффе-
ренциального и линейного криптоанализа, увеличивая требуемое количест-
во проб с выбранным исходным текстом до величины, превышающей 260.
Дальнейшее увеличение стойкости против этих атак может быть достигну-
то заменой в DESX операции "исключающее ИЛИ" на сложение, как это
〈 〉.
было сделано в
DES − PEPk ,k1,k 2 = k 2+DESk (k1 + x) ,
где сложение определяется следующим образом:
L.R + L'.R' = (L◊L').(R◊R'), L = R = L' = R' = 32 ,
а ◊ обозначает сложение по модулю 232.
Сказанное не означает, что невозможно построить машину, раскры-
вающую DESX за приемлемое время. Но оно подразумевает, что такая ма-
шина должна использовать какую-либо радикально новую идею. Это не
может быть машина, реализующая перебор ключей в общепринятом смыс-
ле.
Таким образом, практически во всех отношениях DESX оказывается
лучше DES. Этот алгоритм прост, совместим с DES, эффективно реализует-
ся аппаратно, может использовать существующее аппаратное обеспечение
DES и в его отношении было доказано, что он увеличивает стойкость к ата-
кам, основанным на переборе ключей.
2.3.2. СТАНДАРТ AES. АЛГОРИТМ RIJNDAEL
В конце 1996 г. Национальным институтом стандартов США (NIST)
был объявлен конкурс на создание нового общенационального стандарта
шифрования, который должен прийти на замену DES. Разрабатываемому
стандарту было присвоено рабочее наименование AES (Advanced Encryption
Standard).
2 октября 2000 г. в качестве предлагаемого стандарта был выбран ал-
горитм Rijndael ("Рейндал"), который разработан Винсентом Райманом
(Vincent Rijman) и Йоан Дамен (Joan Daemen) и представляет собой алго-
ритм, не использующий сети Фейстеля.
При описании алгоритма используется поле Галуа GF(2S), построенное
как расширение поля GF(2) по корням неприводимого многочлена
т(х) = х8 + х4 + х3 + х + 1.
Данный многочлен выбран из соображений эффективности представ-
ления элементов поля. Элементарные операции, использующиеся в алго-
ритме, выполняются в указанном поле.
Алгоритм Rijndael представляет собой блочный шифр с переменной
длиной блока и переменной длиной ключа. Длины блока и ключа могут
быть выбраны независимо равными 128, 192 или 256 бит. Шифр является
последовательностью итераций, выполняемых над некоторой промежуточ-
ной структурой, называемой состоянием.
Состояние может быть представлено в виде прямоугольного массива
байтов. В массиве 4 строки, а число столбцов, обозначаемое как Nb, равно
длине блока, деленной на 32. Ключ шифрования аналогичным образом
представляется в виде прямоугольного байтового массива с 4 строками.
Количество столбцов, обозначаемое Nk, равно длине ключа, деленной на
32. Входные и выходные значения алгоритма представляются в виде одно-
мерных байтовых массивов соответствующей длины. Состояние и ключе-
вой массив заполняются из этих массивов вначале по столбцам, а затем по
строкам. Количество итераций обозначается Nr зависит от Nb и Nk в соот-
ветствии со следующей таблицей:
Nr Nb = 4 Nb = 6 Nb = 8
Nk = 4 10 12 14
Nk = 6 12 12 14
Nk = 8 14 14 14
Блок нелинейной обратимой байтовой замены (S-бокс), состоящий из
двух операций:
• каждый байт заменяется на мультипликативный обратный к нему в
поле GF(2S).
• над каждым байтом выполняется аффинное преобразование в поле
GF(2), задаваемое следующим уравнением:
.
0
1
1
0
0
0
1
1
1 1 1 1
1 1 1 0
1 1 0 0
1 0 0 0
0 0 0 1
0 0 1 1
0 1 1 1
1 1 1 1
0 0 0 1
0 0 1 1
0 1 1 1
1 1 1 1
1 1 1 1
1 1 1 0
1 1 0 0
1 0 0 0
7
6
5
4
3
2
1
0
7
6
5
4
3
2
1
0
          


          


+
          


          


          


          


=
          


          


x
x
x
x
x
x
x
x
y
y
y
y
y
y
y
y
Это аффинное преобразование может быть описано в полиномиаль-
ном виде как b(х) = (х7 + х6 + х2 + х) + а(х) (х7 + х6 + х5 + х4 + 1) (mod х8 +
1). Полином, на который производится умножение, выбран взаимно про-
стым с модулем, так что умножение является обратимым.
Обратным будет преобразование, состоящее из обратного аффинного
преобразования и взятия мультипликативного обратного в GF(2S).
Следующее преобразование является циклическим сдвигом влево
строк массива состояния на различную величину. Строка 0 не сдвигается,
строка 1 сдвигается на С1 позиций, строка 2 – на С2 и строка 3 – на С3 по-
зиций. Величины сдвига приведены в таблице:
Nb С1 С2 С3
4 1 2 3
6 1 2 3
8 1 3 4
Обратным преобразованием будет циклический сдвиг строк массива
вправо на то же количество позиций.
"Перемешивание столбцов". В этом преобразовании столбцы массива
состояния рассматриваются как полиномы над полем GF(28). Преобразова-
ние заключается в умножении столбца по модулю (х4 + 1) на фиксирован-
ный полином с(x). Этот полином является взаимно простым с (х4 + 1) и по-
этому умножение обратимо. В матричной форме данное преобразование
можно представить как
.
03 01 01 02
01 01 02 03
01 02 03 01
02 03 01 01
3
2
1
0
3
2
1
0
    


    


   


   


=
    


    


a
a
a
a
b
b
b
b
Обратное преобразование представляет собой умножение на полином,
мультипликативно обратный к с (х) по модулю (х4 + 1) – d(x).
Преобразование добавление ключа итерации осуществляется простым
побитовым сложением по модулю 2 каждого байта массива состояния с
соответствующим байтом массива ключа. Это преобразование является
обратным самому себе.
Ключи итерации получаются из ключа шифрования с помощью алго-
ритма обработки ключа, состоящего из двух компонентов – расширения
ключа и выбора ключа итерации. Основные принципы его построения сле-
дующие:
• общее число бит ключей итерации равно длине блока, умноженной
на количество итераций плюс один (например, для блока 128 бит и 10 итера-
ций потребуется 1408 бит ключей итерации);
• ключ шифрования расширяется до расширенного ключа. Ключи
итерации берутся из расширенного ключа следующим образом: первый
ключ итерации состоит из первых Nb слов, второй – из следующих Nb слов
и т.д.
Выбор ключа итерации. Ключ итерации с номером i задается словами
из буфера расширенного ключа, начиная с W[Nb i] и до W[Nb (i + 1)] и состоит
из трех этапов: начального добавления подключа; Nr – 1 итераций; конеч-
ной итерации.
2.3.3. АЛГОРИТМ RC6
В качестве одного из кандидатов фирмой RSA Data Security, Inc. был
представлен алгоритм RC6, прошедший второй тур отбора. В нем преду-
сматривается использование четырех рабочих регистров, а также введена
операция целочисленного умножения, позволяющая существенно увели-
чить возмущения, вносимые каждым циклом шифрования, что приводит к
увеличению стойкости и/или возможности сократить число циклов.
RC6 является полностью параметризованным алгоритмом шифрова-
ния. Конкретная версия RC6 обозначается как RC6-w/r/b, где w обозначает
длину слова в битах, r – ненулевое количество итерационных циклов шиф-
рования, a b – длину ключа в байтах. Во всех вариантах RC6-w/r/b работает
с четырьмя w-битовыми словами, используя шесть базовых операций, обо-
значаемых следующим образом:
а + b – целочисленное сложение по модулю 2w;
a – b – целочисленное вычитание по модулю 2w;
a ⊕ b – побитовое "исключающее ИЛИ" w-битовых слов;
а × b – целочисленное умножение по модулю 2w;
a << b – циклический сдвиг w-битового слова влево на величину, за-
данную log2w младшими битами b;
a >> b – циклический сдвиг w-битового слова вправо на величину, за-
данную log2w младшими битами b;
Шифрование при помощи RC6-w/r/b описывается следующим обра-
зом:
Вход: Исходный текст, записанный в 4 w-битовых входных регистрах
А, В, С, D; число циклов шифрования r; ключевая таблица S[0; ..., 2r + 3] w-
битовых слов.
Выход: Шифрованный текст в регистрах А, В, С, D.
Процедура:
B=B + S[0]
D=D + S[1]
for i=1 to r do {
t=(B×(2B+1))<<log2w
u=(D×(2D+1))<<log2w
A=((A⊕t)<<u)+S[2i]
C=((C⊕u)<<t)+S[2i+1]
(A; B; C; D) = (В; С; D; A)
}
A=A + S[2r + 2]
C=C + S[2r +3]
Расшифрование в этих обозначениях выглядит очень похоже.
Вход: Шифрованный текст, записанный в 4 w-битовых входных реги-
страх А, В, С, D; число циклов шифрования r; ключевая таблица S[0; ..., 2r
+ 3] w-битовых слов.
Выход: Исходный текст в регистрах А, В, С, D.
Процедура:
C=C–S[2r +3]
A=A–S[2r + 2]
for i=r downto 1 do {
(A; B; C; D) = (D;A; B; C)
u=(D×(2D+1))<<log2w
t=(B×(2B+1))<<log2w
C=((C – S[2i+1])>>t)+ ⊕u
A=((A – S[2i])>>u)+ ⊕t
}
D=D – S[1]
B=B – S[0]
Алгоритм вычисления ключей для RC6-w/r/b выглядит следующим
образом:
Пользователь задает ключ длиной b байтов. Достаточное число нену-
левых байтов дописываются в конец, чтобы получилось целое число слов.
Затем эти байты записываются, начиная с младшего, в массив из с слов, т.е.
первый байт ключа записывается в L[0] и т.д., a L[c – 1] при необходимости
дополняется со стороны старших разрядов нулевыми байтами. В результате
работы алгоритма генерации ключей будет вычислено 2r + 4 слов, которые
будут записаны в массиве S [0; ..., 2r + 3].
Константы Р32 = В7Е15163h and Q32 = 9E3779B9h – это константы, по-
лучаемые из двоичного представления е – 2, где е – основание натуральных
логарифмов, и φ – 1, где φ – золотое сечение, соответственно. Подобные же
константы могут быть аналогичным образом получены и для RC6 с другим
размером слова. Выбор констант является в некотором роде произвольным,
и поэтому можно использовать и другие константы, получая при этом "ча-
стные" версии алгоритма.
Структура шифра RC6 является обобщением сети Фейстеля, но блок
текста разбивается не на два, а на четыре подблока, и на каждой итерации
изменяются два подблока из четырех. При этом в конце итерации шифро-
вания производится циклический сдвиг подблоков влево (при расшифрова-
нии, соответственно, вправо). Однако, такое обобщение привело к тому,
что было утеряно свойство инвариантности блоков шифрования и расшиф-
рования, хотя это и не является определяющим в оценке данного алгорит-
ма.
2.3.4. РОССИЙСКИЙ СТАНДАРТ ШИФРОВАНИЯ ГОСТ 28147–89
В Российской Федерации установлен единый стандарт преобразования
данных для систем обработки информации в сетях ЭВМ, отдельных вычис-
лительных комплексах и ЭВМ, который определяется ГОСТ 28147–89. Он
носит обязательный характер для государственных органов, организаций,
предприятий, банковских и иных учреждений, чья деятельность связана с
обеспечением информационной безопасности государства. Для других ор-
ганизаций и частных лиц ГОСТ имеет рекомендательный характер. Этот
алгоритм криптографического преобразования данных предназначен для
аппаратной или программной реализации, удовлетворяет криптографиче-
ским требованиям и не накладывает ограничения на степень секретности за-
щищаемой информации.
Данный стандарт формировался с учетом мирового опыта и, в частно-
сти, были приняты во внимание недостатки и нереализованные возможно-
сти алгоритма DES, поэтому использование стандарта ГОСТ предпочти-
тельнее. Алгоритм шифрования построен с использованием сети Фейстеля.
2.3.4.1. Общая структурная схема
Структурная схема алгоритма криптографического преобразования
(криптосхема) содержит элементы, согласно схеме рис. 2.5. Криптосхема
содержит следующие элементы:
• ключевое запоминающее устройство (КЗУ) на 256 бит, состоящее из
8-ми 32-разрядных накопителей (Х0, Х1, Х2, Х3, Х4, Х5, Х6, Х7);
• четыре 32-разрядные накопителя (N1, N2, N3, N4);
• два 32-разрядных накопителя (N5, N6) с записанными в них посто-
янными заполнениями C2, C1;
• два 32-разрядных сумматора по модулю 232 (СМ1, СМ3);
• 32-разрядный сумматор поразрядного суммирования по модулю 2
(СМ2);
• сумматор по модулю 2 без ограничений на разрядность (СМ5);
• блок подстановки (К);
• регистр циклического сдвига на одиннадцать шагов в сторону
старшего разряда (R).
Блок подстановки К состоит из восьми узлов замены К1-К8 с памятью
по 64 бита каждый. Ключи, определяющие заполнение КЗУ и таблиц блока
подстановки К являются секретными элементами и поставляются в уста-
новленном порядке.
Заполнение таблиц блока подстановки К является долговременным
ключевым элементом, общим для сети ЭВМ. Организация различных видов
связи достигается построением соответствующей ключевой системы. При
этом может быть использована возможность выработки ключей (заполне-
ний КЗУ) в режиме простой замены и зашифрования их в режиме простой
замены с обеспечением имитозащиты для передачи по каналам связи или
хранения в памяти ЭВМ.
Рис. 2.5. Общая структурная схема алгоритма ГОСТ 28147–89
В криптосхеме предусмотрены четыре вида работы:
1) зашифрование (расшифрование) данных в режиме простой замены;
2) зашифрование (расшифрование) данных в режиме гаммирования;
3) зашифрование (расшифрование) данных в режиме гаммирования с об-
ратной связью;
4) режим выработки имитовставки.
2.3.4.2. Режим простой замены
Зашифрование данных. Криптосхема, реализующая алгоритм зашиф-
рования в режиме простой замены, должна иметь вид, показана на рис. 2.6.
K
Рис. 2.6. Структурная схема зашифрования в режиме простой замены
Открытые данные, подлежащие зашифрованию, разбивают на блоки
по 64 бита каждый. Ввод любого блока Tо = (a1(0), a2(0), ..., a31(0), a32(0),
b1(0), b2(0), …, b32(0) двоичной информации в накопители N1 и N2 произ-
водятся так, что значение a1(0) вводится в 1-й разряд N1, значение a2(0)
вводится во 2-й разряд накопителя и т.д., значение a32(0) вводится в 32-й
разряд N1: значение b1(0) вводится в 1-й разряд N2, значение b2(0) вводит-
ся во 2-й разряд накопителя и т.д., значение b32(0) вводится в 32-й разряд
N2. В результате получаем состояние (a32(0), a31(0), ..., a2(0), a1(0)) нако-
пителя N1 и состояние (b32(0), b31(0),..., b2(0), b1(0)) накопителя N2. В
КЗУ вводится 256 бит ключа. Содержимое восьми 32-разрядных накопите-
лей X0, X1, ..., X7 имеет вид:
X0 = (W32, W31, ..., W2, W1)
X1 = (W64, W63, ..., W34, W33)
. . .
X7 = (W256, W255, ..., W226, W225)
Алгоритм зашифрования 64-разрядного блока открытых данных в ре-
жиме простой замены состоит из 32-х циклов.
В первом цикле начальное заполнение накопителя N1 суммируется по
модулю 232 в сумматоре СМ1 с заполнением накопителя X0, при этом за-
полнение накопителя N1 сохраняется. Результат суммирования преобразу-
ется в блоке подстановки K и полученный вектор поступает на вход реги-
стра R, где циклически сдвигается на одиннадцать шагов в сторону стар-
ших разрядов. Результат сдвига суммируется поразрядно по модулю 2 в
сумматоре СМ2 с 32-разрядным заполнением накопителя N2. Полученный
в СМ2 результат записывается в N1, при этом старое заполнение N1 пере-
писывается в N2. Первый цикл заканчивается.
Последующие циклы осуществляются аналогично, при этом во 2-м
цикле из КЗУ считывается заполнение X1, в 3-ем цикле из КЗУ считывает-
ся заполнение X2 и т.д., в 8-м цикле из КЗУ считывается заполнение X7. В
циклах с 9-го по 16-й, а также в циклах с 17-го по 24-й заполнения из КЗУ
считываются в том же порядке. В последних восьми циклах с 25-й по 32-й
порядок считывания заполнений КЗУ обратный. В 32-м цикле результат из
сумматора СМ2 вводится в накопитель N2, а в накопителе N1 сохраняется
K
старое заполнение.
Полученные после 32-го цикла зашифрования заполнения накопите-
лей N1 и N2 являются блоком зашифрованных данных, соответствующим
блоку открытых данных.
64-разрядный блок зашифрованных данных Тш выводится из накопи-
телей N1 и N2 в следующем порядке: из 1-го, 2-го, ..., 32-го разряда нако-
пителя N1, затем из 1-го, 2-го,..., 32-го разрядов накопителя N2. Остальные
блоки открытых данных в режиме простой замены зашифровываются ана-
логично.
Расшифрование данных. Криптосхема, реализующая алгоритм рас-
шифрования в режиме простой замены имеет тот же вид, что и при зашиф-
ровании. В КЗУ вводятся 256 бит того же ключа, на котором осуществля-
лось зашифрование открытых данных.
Зашифрованные данные разбиваются на блоки по 64 бита каждый.
Ввод любого блока
Tш = (a1(32), a2(32), ..., a31(32), a32(32), b1(32), b2(32), ..., b32(32)
двоичной информации в накопители N1 и N2 производятся так, что значе-
ние a1(32) вводится в 1-й разряд N1, значение a2(32) вводится во 2-й разряд
накопителя и т.д., значение a32(32) вводится в 32-й разряд N1: значение
b1(32) вводится в 1-й разряд N2, значение b2(32) вводится во 2-й разряд
накопителя и т.д., значение b32(32) вводится в 32-й разряд N2. Расшифро-
вание осуществляется по тому же алгоритму, что и зашифрование откры-
тых данных, с тем изменением, что заполнения накопителей X0, X1, ..., X7
считываются из КЗУ в циклах расшифрования в следующем порядке:
X0, X1, X2, X3, X4, X5, X6, X7, X7, X6, X5, X4, X3, X2, X1, X0
X7, X6, X5, X4, X3, X2, X1, X0, X7, X6, X5, X4, X3, X2, X1, X0
Полученные после 32-х циклов работы заполнения накопителей N1 и
N2 составляют блок открытых данных. Аналогично расшифровываются
остальные блоки зашифрованных данных. Алгоритм зашифрования в ре-
жиме простой замены 64-битового блока То обозначается через A, т.е.:
A (Tо) = A (a(0), b(0))) = (a(32), b(32)))= Tш.
2.3.4.3. Режим гаммирования
Зашифрование данных. Криптосхема, реализующая алгоритм зашиф-
рования данных в режиме гаммирования показана на схеме рис. 2.7. От-
крытые данные, разбитые на 64-разрядные блоки Tо(1), Tо(2), ..., Tо(M – 1),
Tо(M), зашифровываются в режиме гаммирования путем поразрядного
суммирования по модулю 2 в сумматоре СМ5 с гаммой шифра Гш, которая
вырабатывается блоками по 64 бита:
Гш = (Гш(1), Гш(2), ..., Гш(M – 1), Гш(M)),
где M – определяется объемом шифруемых данных. В КЗУ вводятся 256
бит ключа. В накопителе N1, N2 вводится 64-разрядная двоичная последо-
вательность (синхропосылка) S = (S1, S2, ..., S64), являющаяся исходным
заполнением этих накопителей для последующей выработки M блоков
гаммы шифра.
Рис. 2.7. Структурная схема зашифрования в режиме гаммирования
Исходное заполнение накопителей N1 и N2 (синхропосылка S) за-
шифровывается в режиме простой замены. Результат зашифрования
A(S) = (Y0, Z0) переписывается в 32-разрядные накопители N3 и N4. За-
полнение накопителя N4 суммируется по модулю (232-1) в сумматоре СМ4
с 32-разрядной константой С1 из накопителя N6, результат записывается в
N4. Заполнение накопителя N3 суммируется по модулю 232 в сумматоре
СМ3 с 32-разрядной константой С2 из накопителя N5, результат записыва-
ется в N3. Заполнение N3 переписывается в N1, а заполнение N4 переписы-
вается в N2, при этом заполнение N3, N4 сохраняется. Заполнение N1 и N2
зашифровывается в режиме простой замены. Полученное в результате за-
шифрования заполнение N1, N2 образует первый 64-разрядный блок гаммы
шифра Гш(1), который суммируется поразрядно по модулю 2 в сумматоре
СМ5 с первым 64-разрядным блоком открытых данных. В результате сум-
мирования получается 64-разрядный блок зашифрованных данных. Анало-
гичным образом зашифровываются остальные блоки открытых данных. В
канал связи или память ЭВМ передаются синхропосылка S и блоки зашиф-
рованных данных.
Расшифрование данных. При расшифровании криптосхема имеет тот
же вид, что и при зашифровании открытых данных в режиме гаммирова-
ния. В КЗУ вводятся 256 бит ключа, с помощью которого осуществлялось
зашифрование данных. В накопители N1 и N2 вводится синхропосылка S.
Процесс выработки M блоков гаммы шифра осуществляется совершенно
аналогично описанному выше. Блоки зашифрованных данных суммируют-
ся поразрядно по модулю 2 в сумматоре СМ5 с блоками гаммы шифра, в
результате получаются блоки открытых данных.
K
2.3.4.4. Режим гаммирования с обратной связью
Зашифрование данных. Криптосхема, реализующая алгоритм зашиф-
рования в режиме гаммирования с обратной связью показана на рис. 2.8.
Открытые данные, разбитые на 64-разрядные блоки зашифровываются в
режиме гаммирования с обратной связью путем поразрядного суммирова-
ния по модулю 2 в сумматоре СМ5 с гаммой шифра, вырабатываемой бло-
ками по 64 бита каждый.
В КЗУ вводится 256 бит ключа. Синхропосылка S из 64 бит вводится в
N1 и N2. Исходное заполнение N1 и N2 зашифровывается в режиме про-
стой замены. Полученное в результате заполнение N1 и N2 образует пер-
вый 64-разрядный блок гаммы шифра, который суммируется поразрядно по
модулю 2 в сумматоре СМ5 с первым 64-разрядным блоком открытых дан-
ных. В результате получается 64-разрядный блок зашифрованных данных.
Рис. 2.8. Структурная схема зашифрования в режиме гаммирования с обрат-
ной связью
Блок зашифрованных данных одновременно является также исходным
состоянием N1, N2 для выработки второго блока гаммы шифра и по обрат-
ной связи записывается в указанные накопители. Заполнение N1, N2 за-
шифровывается в режиме простой замены. Полученное в результате за-
шифрования заполнение N1, N2 образует второй 64-разрядный блок гаммы
шифра, который суммируется поразрядно по модулю 2 в сумматоре СМ5
со вторым блоком открытых данных. Выработка последующих блоков
гаммы шифра и зашифрование соответствующих блоков открытых данных
производится аналогично. В канал связи или память ЭВМ передаются син-
хропосылка S и блоки зашифрованных данных.
Расшифрование данных. При расшифровании криптосхема имеет тот
же вид, что и при зашифровании.
В КЗУ вводятся 256 бит того же ключа, с помощью которого произво-
дилось зашифрование данных. Синхропосылка S вводится в N1, N2. Ис-
ходное заполнение N1, N2 (синхропосылка) зашифровывается в режиме
простой замены. Полученное в результате заполнение N1, N2 образует пер-
вый блок гаммы шифра, который суммируется с по модулю 2 в сумматоре
СМ5 с блоком зашифрованных данных. В результате получается первый
блок открытых данных. Блок зашифрованных данных является исходным
K
заполнением N1, N2 для выработки второго блока гаммы шифра. Получен-
ное заполнение N1, N2 зашифровывается в режиме простой замены. Полу-
ченный в результате блок суммируется поразрядно по модулю 2 в сумма-
торе СМ5 со вторым блоком зашифрованных данных. В результате получа-
ется второй блок открытых данных. Аналогичным образом производится
расшифрование последующих блоков зашифрованных данных.
2.3.4.5. Режим выработки имитовставки
Для обеспечения имитозащиты открытых данных, состоящих из M 64-
разрядных блоков Tо(1), Tо(2), ..., Tо(M) где M > 2, вырабатывается допол-
нительный блок из 1 бит (имитовставка И1).
Процесс выработки имитовставки единообразен для всех режимов
шифрования. Первый блок открытых данных записывается в накопители
N1, N2. Заполнение N1, N2 подвергается преобразованию, соответствую-
щему первым 16 циклам алгоритма зашифрования в режиме простой заме-
ны. В КЗУ при этом находится тот же ключ, которым зашифровываются
блоки открытых данных. Полученное после 16 циклов преобразование за-
полнение N1, N2 суммируется в сумматоре СМ5 по модулю 2 со вторым
блоком открытых данных.
Результат суммирования заносится в N1, N2 и подвергается преобра-
зованию, соответствующему первым 16 циклам алгоритма зашифрования в
режиме простой замены. Полученное заполнение N1, N2 суммируется в
СМ5 по модулю 2 с третьим блоком открытых данных и т.д. Итоговый ре-
зультат суммирования заносится в N1, N2 и зашифровывается в режиме
простой замены по первым 16 циклам работы алгоритма. Из полученного
значения накопителей N1 и N2 выбирается отрезок И1 (имитовставка) дли-
ной 1 бит. Имитовставка передается по каналу связи или в память ЭВМ в
конце зашифрованных данных.
Поступившие зашифрованные данные расшифровываются, из полу-
ченных блоков открытых данных аналогично описанному выше вырабаты-
вается имитовставка И1’, которая затем сравнивается с имитовставкой И1
полученной вместе с зашифрованными данными. В случае несовпадения
имитовставок полученные данные считаются ложными. Выработка ими-
товставки может производится или перед зашифрованием (после расшиф-
рования) всего сообщения, или параллельно с зашифрованием (расшифро-
ванием) по блокам. Первые блоки открытых данных, которые участвуют в
выработке имитовставки, могут содержать служебную информацию (ад-
ресную часть, отметку времени, синхропосылку и т.д.) и не зашифровыва-
ются. Значение параметра l (длина двоичных разрядов в имитовставке) оп-
ределяется требованием к криптографической защите, при этом учитывает-
ся, что вероятность навязывания ложных данных равна 2 – l.
2.4. Режимы применения блочных шифров
Для шифрования исходного текста произвольной длины блочные
шифры могут быть использованы в нескольких режимах. Далее будут рас-
смотрены четыре режима применения блочных шифров, наиболее часто
встречающиеся в системах криптографической защиты информации, а
именно режимы электронной кодировочной книги (ЕСВ – Electronic Code
Book), сцепления блоков шифрованного текста (СВС – Cipher Block Chaining),
обратной связи по шифрованному тексту (СFВ – Cipher Feedback) и
обратной связи по выходу (OFB – Output Feedback).
В режиме электронной кодировочной книги каждый блок исходного
текста шифруется блочным шифром независимо от других (рис. 2.9).
Стойкость режима ЕСВ равна стойкости самого шифра. Однако,
структура исходного текста при этом не скрывается. Каждый одинаковый
блок исходного текста приводит к появлению одинакового блока шифро-
ванного текста Исходным текстом можно легко манипулировать путем
удаления, повторения или перестановки блоков. Скорость шифрования
равна скорости блочного шифра.
Рис. 2.9. Режим электронной кодировочной книги
Рис. 2.10. Режим сцепления блоков шифрованного текста
Режим ЕСВ допускает простое распараллеливание для увеличения
скорости шифрования, но никакая обработка невозможна до поступления
блока (за исключением генерации ключей). Режим ЕСВ соответствует ре-
жиму простой замены ГОСТ.
В режиме сцепления блоков шифрованного текста (СВС) каждый
блок исходного текста складывается поразрядно по модулю 2 с предыду-
щим блоком шифрованного текста, а затем шифруется (рис. 2.10). Для на-
чала процесса шифрования используется синхропосылка (или начальный
вектор), которая передается в канал связи в открытом виде.
Стойкость режима СВС равна стойкости блочного шифра, лежащего в
его основе. Кроме того, структура исходного текста скрывается за счет
сложения предыдущего блока шифрованного текста с очередным блоком
открытого текста. Стойкость шифрованного текста увеличивается, по-
скольку становится невозможной прямая манипуляция исходным текстом,
кроме как путем удаления блоков из начала или конца шифрованного тек-
ста.
Скорость шифрования равна скорости работы блочного шифра, но
простого способа распараллеливания процесса шифрования не существует,
хотя расшифрование может проводиться параллельно.
Одной из потенциальных проблем режима СВС является возможность
внесения контролируемых изменений в последующий расшифрованный
блок исходного текста. Например, если злоумышленник изменит один бит
в блоке, то весь блок будет расшифрован неверно, но в следующем блоке
появится ошибка в соответствующей позиции. Есть ситуации, когда такое
нежелательно. Для борьбы с этой угрозой исходный текст должен содер-
жать определенную избыточность.
Известны модификации режима СВС.
Режим сцепления блоков шифрованного текста с распространением
(РСВС – Propagating СВС) отличается тем, что по модулю 2 складывается
как предыдущий блок шифрованного, так и исходного текста:
1 1
1 1
( ),
( )
i k i i i
i i i k i
c E m c m
m c m D c
− −
− −
= ⊕ ⊕
= ⊕ ⊕
Рис. 2.11. Режим обратной связи по шифрованному тексту
Режим сцепления блоков шифрованного текста с контрольной суммой
.
(СВСС – СВС with Checksum) отличается тем, что к последнему блоку ис-
ходного текста перед шифрованием прибавляется сумма по модулю два
всех предыдущих блоков исходного текста. Это дает возможность прокон-
тролировать целостность передаваемого текста с небольшими дополни-
тельными накладными расходами.
В режиме обратной связи по шифрованному тексту (СFВ) предыду-
щий блок шифрованного текста шифруется еще раз, и для получения оче-
редного блока шифрованного текста результат складывается поразрядно по
модулю 2 с блоком исходного текста. Для начала процесса шифрования
также используется начальный вектор (рис. 2.11).
Стойкость режима СFВ равна стойкости блочного шифра, лежащего в
его основе и структура исходного текста скрывается за счет использования
операции сложения по модулю 2. Манипулирование исходным текстом
путем удаления блоков из начала или конца шифрованного текста стано-
вится невозможным. В режиме СFВ, если два блока шифрованного текста
идентичны, то результаты их шифрования на следующем шаге также будут
идентичны, что создает возможность утечки информации об исходном тек-
сте.
Скорость шифрования равна скорости работы блочного шифра и про-
стого способа распараллеливания процесса шифрования также не сущест-
вует. Этот режим в точности соответствует режиму гаммирования с обрат-
ной связью алгоритма ГОСТ 28147–89.
Режим обратной связи по выходу (OFB) подобен режиму СFВ за ис-
ключением того, что величины, складываемые по модулю 2 с блоками ис-
ходного текста, генерируются независимо от исходного или шифрованного
текста (рис. 2.12). Для начала процесса шифрования также используется
начальный вектор. Режим OFB обладает преимуществом перед режимом
СFВ – любые битовые ошибки, возникшие в процессе передачи, не влияют
на расшифрование последующих блоков. Однако, возможна простая мани-
пуляция исходным текстом путем изменения шифрованного текста. Суще-
ствует модификация этого режима под названием режим обратной связи по
выходу с нелинейной функцией.
Рис. 2.12. Режим обратной связи по выходу
2.5. Потоковые шифры
2.5.1. ОБЩИЕ СВЕДЕНИЯ О ПОТОКОВЫХ ШИФРАХ
Потоковые шифры представляют собой разновидность гаммирования
и преобразуют открытый текст в шифрованный последовательно по 1 биту.
Генератор ключевой последовательности, иногда называемый генерато-
ром бегущего ключа, выдает последовательность бит k1, k2, ..., ki, ... Эта
ключевая последовательность складывается по модулю 2 с последователь-
ностью бит исходного текста p1, p2, ..., pi, ... для получения шифрованного
текста:
сi = pi ⊕ki .
На приемной стороне шифрованный текст складывается по модулю 2
с идентичной ключевой последовательностью для получения исходного
текста:
i i i i i i с ⊕k = p ⊕k ⊕k = p .
Стойкость системы целиком зависит от внутренней структуры генера-
тора ключевой последовательности. Если генератор выдает последователь-
ность с небольшим периодом, то стойкость системы будет невелика. На-
против, если генератор будет выдавать бесконечную последовательность
истинно случайных бит, то получится одноразовый блокнот с идеальной
стойкостью.
Реальная стойкость потоковых шифров лежит где-то посредине между
стойкостью простой моноалфавитной подстановки и одноразового блокно-
та. Генератор ключевой последовательности выдает поток битов, который
выглядит случайным, но в действительности является детерминированным
и может быть в точности воспроизведен на приемной стороне. Чем больше
генерируемый поток похож на случайный, тем больше усилий потребуется
от криптоаналитика для взлома шифра.
Если каждый раз при включении генератор будет выдавать одну и ту
же последовательность, то взлом криптосистемы будет тривиальной зада-
чей. Перехватив два шифрованных текста, злоумышленник может сложить
их по модулю 2 и получить два исходных текста, сложенных также по мо-
дулю 2. Такую систему раскрыть очень просто. Если же в руках противни-
ка окажется пара исходный текст – шифрованный текст, задача вообще
становится тривиальной.
По этой причине все потоковые шифры предусматривают использова-
ние ключа. Выход генератора ключевой последовательности зависит от
этого ключа. В этом случае простой криптоанализ будет невозможен.
Потоковые шифры наиболее пригодны для шифрования непрерывных
потоков данных, например, в сетях передачи данных.
Структуру генератора ключевой последовательности можно предста-
вить в виде конечного автомата с памятью, состоящего из трех блоков:
блока памяти, хранящего информацию о состоянии генератора, выходной
функции, генерирующей бит ключевой последовательности в зависимости
от состояния, и функции переходов, задающей новое состояние, в которое
перейдет генератор на следующем шаге.
2.5.2. МЕТОДЫ ЗАМЕНЫ
Шифрование методом замены (подстановки) основано на алгебраиче-
ской операции, называемой подстановкой. Подстановкой называется вза-
имно-однозначное отображение некоторого конечного множества М на
себя. Число N элементов этого множества называется степенью подстанов-
ки. Природа множества M роли не играет, поэтому можно считать, что M =
{1, 2, ..., N}.
Если при данной подстановке S число j переходит в Ij, то подстановка
обозначается символом S:




=
I I In
n
S
1 2
1 2
В этой записи числа 1, 2, ..., n можно произвольным образом перестав-
лять, соответственно переставляя числа I1, I2, ..., In. Результат последова-
тельного выполнения двух подстановок S1 и S2 одной и той же степени
также является подстановкой, которая называется произведением подста-
новок S1 и S2 и обозначается S1S2.
Пусть S – произвольная подстановка степени n. Если для некоторого j
число Ij отлично от j, то говорят, что подстановка S действительно переме-
щает число j; в противном случае – подстановка S оставляет число j на мес-
те.
Количество m чисел, действительно перемещаемых подстановкой S,
называется длиной цикла подстановки.
Подстановка S называется транспозицией, если существует пара (j1, j2)
различных элементов из M, удовлетворяющих условиям:
Ij1 = j2, Ij2 = j2, Ij = j для каждого j ∈ {M\{j1, j2}}.
Любая подстановка разлагается в произведение транспозиций.
В криптографии рассматриваются четыре типа подстановки (замены):
моноалфавитная, гомофоническая, полиалфавитная и полиграммная. Далее
всюду в примерах, где необходимо, будем использовать кодирование букв
русского алфавита, приведенное в табл. 2.2. Знак "_" в табл. 2.2 и далее оз-
начает пробел.
2.2. Коды букв русского алфавита
Буква А Б В Г Д Е Ж З И Й К Л М Н О П Р
Код 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17
Буква С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я _
Код 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33
При моноалфавитной замене каждой букве алфавита открытого текста
ставится в соответствие одна буква шифртекста из этого же алфавита, на-
пример шрифт "отбаш".
Пpимеp. Открытый текст: "ШИФРОВАНИЕ_ЗАМЕНОЙ". Подстанов-
ка задана в табл. 2.3.
2.3. Подстановка шифра
ИТ А Б В Г Д Е Ж З И Й К Л М Н О П Р
ШТ _ Я Ю Э Ь Ы Ъ Щ Ш Ч Ц Х Ф У Т С Р
ИТ С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я _
ШТ П О Н М Л К Й И З Ж Е Д Г В Б А
ИТ – алфавит исходного текста ШТ – алфавит шифpтекста. Шифртекст:
"ИШМРТЮ_УШЫАЩ_ФЫУТЧ".
Основным недостатком рассмотренного метода является сохранение
статистических свойств открытого текста (частота повторения букв) в
шифртексте.
Общая формула моноалфавитной замены выглядит в виде:
Yi = k1Xi + k2(mod N),
где Yi – i-й символ aлфавитa; k1 и k2 – константы; Xi – i-й символ открытого
текста (номер буквы в алфавите); N – длина используемого алфавита.
Шифр, задаваемый фоpмулой:
Yi = Xi + ki(mod N),
где ki – i-я буква ключа, в качестве которого используются слово или фраза,
называется шифpом Вижинера.
Пример. Открытый текст: "ЗАМЕНА". Ключ: "КЛЮЧ" (табл. 2.4).
2.4. Шифр Вижинера
Открытый текст Ключ Преобразование Шифр
З К y1 = 8 + 11(mod 33) = 19 Т
А Л y2 = 1 + 12(mod 33) = 13 М
М Ю у3 = 13 + 31(mod 33) = 11 К
Е Ч y4 = 6 + 24(mod 33) = 30 Э
Н К у5 = 14 + 11(mod 33) = 25 Ш
А Л y6 = 1 + 12(mod 33) = 13 М
Шифртекст: "ТМКЭШМ".
Шифр Бофорта – многоалфавитная криптосистема, аналогичная
криптосистеме Вижинера. Строками квадрата Бофорта являются строки
квадрата Вижинера, записанные в обратном порядке. Криптосистема на-
звана в честь адмирала Френсиса Бофорта. Шифр Бофорта использует
формулы
уi = ki – xi(mod n) и yi = xi – ki(mod n).
Гомофоническая замена одному символу открытого текста ставит в
соответствие несколько символов шифртекста. Этот метод применяется для
искажения статистических свойств шифртекста.
Пример. Открытый текст: "ЗАМЕНА". Подстановка задана табл. 2.5.
2.5. Гомофоническая подстановка
Алфавит открытого
текста А Б … Е Ж З … М Н …
17 23 97 47 76 32 55
Алфавит шифртек- 31 44 51 67 19 28 84
ста
48 63 15 33 59 61 34
Шифртекст: "76 17 32 97 55 31".
Таким образом, при гомофонической замене каждая буква открытого
текста заменяется по очереди цифрами соответствующего столбца.
Полиалфавитная подстановка использует несколько алфавитов шиф-
ртекста. Пусть используется k алфавитов. Тогда открытый текст
Х = X1X2...XkXk+1...X2kX2k+1...
заменяется шифртекстом
Y = F1(X1)F2(X2)...Fk(Xk)Fk+1(Xk+1)...F2k(X2k)F2k+1(X2k+1),
где Fi(Xj) – символ шифртекста алфавита i для символа открытого текста Xj.
Полиграммная замена формируется из одного алфавита с помощью
специальных правил. В качестве примера рассмотрим шифр Плэйфера.
В этом шифре алфавит располагается в матрице. Открытый текст раз-
бивается на пары символов XiXi+1. Каждая пара символов открытого текста
заменяется на пару символов из матрицы следующим образом:
• если символы находятся в одной строке, то каждый из символов па-
ры заменяется на стоящий правее его (за последним символом в строке
следует первый);
• если символы находятся в одном столбце, то каждый символ пары
заменяется на символ, расположенный ниже его в столбце (за последним
нижним символом следует верхний);
• если символы пары находятся в разных строках и столбцах, то они
считаются противоположными углами прямоугольника. Символ, находя-
щийся в левом углу, заменяется на символ, стоящий в другом левом углу;
замена символа, находящегося в правом углу, осуществляется аналогично;
• если в открытом тексте встречаются два одинаковых символа под-
ряд, то перед шифрованием между ними вставляется специальный символ
(например, тире).
Пример. Открытый текст: "ШИФР_ПЛЭЙФЕРА.". Матрица алфавита
представлена в табл. 2.6.
2.6. Матрица алфавита
А Х Б М Ц В
Ч Г Н Ш Д О
Е Щ , Ж У П
. З Ъ Р И Й
С Ь К Э Т Л
Ю Я _ Ы Ф –
Шифртекст: "РДИЫ,-СТ-И.ЖЧС".
При рассмотрении этих видов шифров становится очевидным, что чем
больше длина ключа, тем лучше шифр. Существенного улучшения свойств
шифртекста можно достигнуть при использовании шифров с автоключом.
Шифр, в котором сам открытый текст или получающаяся криптограм-
ма используются в качестве "ключа", называется шифром с автоключом.
Шифрование в этом случае начинается с ключа, называемого первичным, и
продолжается с помощью открытого текста или криптограммы, смещенной
на длину первичного ключа.
Пример. Открытый текст: "ШИФРОВАНИЕ_ЗАМЕНОЙ". Первичный
ключ: "КЛЮЧ". Шифрование с автоключом при использовании открытого
текста представлено в табл. 2.7.
2.7. Шифрование с автоключом при использовании открытого текста
ИТ Ш И Ф Р О В А Н И Е _ З А М Е Н О Й
Кл К Л Ю Ч Ш И Ф Р О В А Н И Е _ З А М
Код 03 21 19 08 07 12 22 31 24 09 01 22 10 19 06 22 16 23
ШТ В Ф Т З Ж Л Х Ю Ч И А Х Й Т Е Х П Ц
ИТ – алфавит исходного текста; Кл – ключ; ШТ – алфавит шифpтекста.
Шифрование с автоключом при использовании криптограммы пред-
ставлено в табл. 2.8.
2.8. Шифрование с автоключом при использовании криптограммы
ИТ Ш И Ф Р О В А Н И Е _ З А М Е Н О Й
Кл К Л Ю Ч В Ф Т З С Ч У Х Ъ Э У Э Ы Й
Код 03 21 19 08 18 24 20 22 27 30 20 30 28 10 26 11 10 20
ШТ В Ф Т З С Ч У Х Ъ Э У Э Ы Й Щ К Й У
ИТ – алфавит исходного текста; Кл – ключ; ШТ – алфавит шифpтекста.
2.5.3. МЕТОДЫ ПЕРЕСТАНОВКИ
При использовании для шифрования информации методов переста-
новки символы открытого текста переставляются в соответствии с некото-
рыми правилами.
Пример. Открытый текст: "ШИФРОВАНИЕ_ПЕРЕСТАНОВКОЙ".
Ключ (правило перестановки): группы из 8 букв с порядковыми номерами
1, 2, ..., 8 переставить в порядок 3-8-1-5-2-7-6-4.
Шифртекст: "ФНШОИАВР_СИЕЕЕРПННТВАОКО".
Можно использовать и усложненную перестановку. Для этого откры-
тый текст записывается в матрицу по определенному ключу k1. Шифртекст
образуется при считывании из этой матрицы по ключу k2.
Пример. Открытый текст: "ШИФРОВАНИЕ_ПЕРЕСТАНОВКОЙ".
Матрица из четырех столбцов. Ключи: k1 = {5-3-1-2-4-6}; k2 = {4-2-3-1}.
Запись по стpокам производится в соответствии с ключом k1. Чтение по
столбцам в соответствии с ключом k2 (табл. 2.9.).
2.9. Шифрование перестановкой
1 И Е _ П
2 Е Р Е С
3 О В А Н
4 Т А Н О
5 Ш И Ф Р
6 В К О Й
k1/k2 1 2 3 4
Шифртекст: "ПСНОРЙЕРВАИК_ЕАНФОИЕОТШВ".
Наиболее сложные перестановки осуществляются по гамильтоновым
путям, которых в графе может быть несколько.
Пример. Открытый текст: "ШИФРОВАНИЕ_ПЕРЕСТАНОВКОЙ".
Ключ: гамильтонов путь на графе (рис. 2.13).
Рис. 2.13. Гамильтоновы пути на графе
Шифртекст: "ШАОНИРФВИЕЕСЕП_РТОВИАОНК".
Необходимо отметить, что для данного графа из восьми вершин мож-
но предложить несколько маршрутов записи открытого текста и несколько
гамильтоновых путей для чтения криптограмм.
В 1991 г. В.М. Кузьмич предложил схему перестановки, основанной
на кубике Рубика. Согласно этой схеме открытый текст записывается в
ячейки граней куба по строкам. После осуществления заданного числа за-
данных поворотов слоев куба считывание шифртекста осуществляется по
столбикам. Сложность расшифрования в этом случае определяется количе-
ством ячеек на гранях куба и сложностью выполненных поворотов слоев.
Перестановка, основанная на кубике Рубика, получила название объемной
(многомерной) перестановки.
В 1992–1994 гг. идея применения объемной перестановки для шифро-
вания открытого текста получила дальнейшее развитие. Усовершенство-
ванная схема перестановок по принципу кубика Рубика, в которой наряду с
открытым текстом перестановке подвергаются и функциональные элемен-
ты самого алгоритма шифрования, легла в основу секретной системы "Ру-
бикон". В качестве прообразов пространственных многомерных структур,
на основании объемных преобразований которых осуществляются переста-
новки, в системе "Рубикон" используются трехмерные куб и тетраэдр. Дру-
гой особенностью системы "Рубикон" является генерация уникальной вер-
сии алгоритма и ключа криптографических преобразований на основании
некоторого секретного параметра (пароля). Это обеспечивает как дополни-
тельные трудности для криптоанализа перехваченных сообщений наруши-
телем (неопределенность примененного алгоритма), так и возможность
априорного задания требуемой криптостойкости. Криптостойкость данной
системы определяется длиной ключа, криптостойкостью отдельных функ-
циональных элементов алгоритма криптографических преобразований, а
также количеством таких преобразований.
Использование уникальных алгоритма и ключа шифрования для каж-
дого пользователя системы соответствует положению теории К. Шеннона о
том, что абсолютно стойкий шифр может быть получен только при исполь-
зовании "ленты однократного применения", т.е. уникальных параметров
при каждом осуществлении шифрования.
2.5.4. МЕТОДЫ АНАЛИТИЧЕСКИХ ПРЕОБРАЗОВАНИЙ
Шифрование методами аналитических преобразований основано на
понятии односторонней функции. Будем говорить, что функция у = f (х)
является односторонней, если она за сравнительно небольшое число опера-
ций преобразует элемент открытого текста Х в элемент шифртекста Y для
всех значений Х из области определения, а обратная операция (вычисление
X = F-1(Y) при известном шифртексте) является вычислительно трудоемкой.
В качестве односторонней функции можно использовать следующие
преобразования: умножение матриц; решение задачи об укладке ранца;
вычисление значения полинома по модулю; экспоненциальные преобразо-
вания и др.
Метод умножения матриц использует преобразование вида
Y = CX, где Y = ||y1, y2, ..., yn||Т; С = ||Cij||; X = ||x1, x2, ..., xn||.
Пример. Открытый текст: "ПРИКАЗ" ("16 17 09 11 01 08" согласно
табл. 2.2).
0
2
1
3
4 5
6 7
0
2
1
3
4 5
6 7
0
2
1
3
4 5
6 7
Общий вид Маршрут 1 Маршрут 2
Матрица С:
3 2 1
2 1 5
1 3 2
85 94 91
09
17
16
*
3 2 1
2 1 5
1 3 2
= 30 63 43
08
01
11
*
3 2 1
2 1 5
1 3 2
=
Шифртекст: "85 94 91 30 63 43".
Задача об укладке ранца формулируется следующим образом.
Задан вектор С = |c1, c2, ..., cn|, который используется для шифрования
сообщения, каждый символ si которого представлен последовательностью
из n бит si = |x1, x2, ..., xn|T, Xk ⊂ {0, 1}. Шифртекст получается как скалярное
произведение Сsi.
Пример. Открытый текст: "ПРИКАЗ" ("16 17 09 11 01 08" согласно
табл. 2.2). Вектор С = {1,3,5,7,11}. Запишем символы открытого текста пя-
тиразрядным двоичным кодом.
П Р И К А З
10000 10001 01001 01011 00001 01000
Произведем соответствующие операции:
y1 = 1∗1 = 1.
y2 = 1∗1 + 1∗11 = 12.
y3 = 1∗3 + 1∗11 = 14.
y4 = 1∗3 + 1∗7 + 1∗11 = 21.
у5 = 1∗11 = 11.
y6 = 1∗3 = 3.
Шифртекст: "01 12 14 21 11 03".
Метод полиномов основан на преобразовании
yi = xi
n + a1∗xi
(n–1) +...+ an∗xi(mod р),
где n, а1, а2, ..., аn – целые неотрицательные числа, не превосходящие р, 1
<= хi, уi <= р; р – большое простое число.
Пример. Открытый текст: "ПРИКАЗ". ("16 17 09 11 01 08" согласно
табл. 2.2)
Полином:
уi = xi
3 + 2xi
2 + 3xi + 4(mod 991).
y1 = 163 + 2∗162 + 3∗16 + 4(mod 991) = 696.
y2 = 173 + 2∗172 + 3∗16 + 4(mod 991) = 591.
у3 = 93 + 2∗92 + 3∗9 + 4(mod 991) = 922.
у4 = 113 + 2∗112 + 3∗11 + 4(mod 991) = 619.
y5 = 13 + 2∗12 + 3∗1 + 4(mod 991) = 10.
у6 = 83 + 2∗82 + 3∗8 + 4(mod 991) = 668.
Шифртекст: "96 591 922 619 010 668".
Экспоненциальный шифр использует преобразование вида
уi =a(xi) (mod р),
где хi – целое, 1 <= хi <= р – 1; p – большое простое число; a – целое, 1 <= a
<= p.
Пример. Открытый текст: "ПРИКАЗ" ("16 17 09 11 01 08" согласно
табл. 2.2); a = 3; p = 991.
y1 = 316 (mod 991) = 43046721 (mod 991) = 654.
у2 = 317 (mod 991) = 129140163 (mod 991) = 971.
у3 = 39 (mod 991) = 19683 (mod 991) = 854.
y4 = 311 (mod 991) = 177147 (mod 991) = 749.
у5 = 31 (mod 991) = 3.
y6 = 38 (mod 991) = 6561 (mod 991) = 615.
Шифртекст: "654 971 854 749 003 615".
2.5.5. ГАММИРОВАНИЕ (ШИФРОВАНИЕ С ПОМОЩЬЮ ДАТЧИКАПСЕВ-
ДОСЛУЧАЙНЫХ ЧИСЕЛ)
Различают два случая: метод конечной гаммы и метод бесконечной
гаммы. В качестве конечной гаммы может использоваться фраза, а в каче-
стве бесконечной – последовательность, вырабатываемая датчиком псевдо-
случайных чисел.
Принцип зашифрования заключается в генерации гаммы шифра с по-
мощью датчика псевдослучайных чисел (ПСЧ) и наложении полученной
гаммы на открытые данные обратимым образом (например, при использо-
вании логической операции "исключающее ИЛИ").
Процесс расшифрования данных сводится к повторной генерации
гаммы шифра при известном ключе и наложению такой гаммы на зашиф-
рованные данные. Полученный зашифрованный текст является достаточно
трудным для раскрытия в том случае, когда гамма шифра не содержит по-
вторяющихся битовых последовательностей. По сути дела гамма шифра
должна изменяться случайным образом для каждого шифруемого слова.
Фактически если период гаммы превышает длину всего зашифрованного
текста и неизвестна никакая часть исходного текста, то шифр можно рас-
крыть только прямым перебором (подбором ключа). В этом случае крипто-
стойкость определяется размером ключа.
Чтобы получить линейные последовательности элементов гаммы,
длина которых превышает размер шифруемых данных, используются дат-
чики ПСЧ. На основе теории групп было разработано несколько типов та-
ких датчиков. В настоящее время наиболее доступными и эффективными
являются конгруэнтные генераторы ПСЧ. Они вырабатывают последова-
тельности псевдослучайных чисел Т(i), описываемые соотношением
T(i + 1) = (A∗T(i) + С) mod М,
где А и С – константы; Т(0) – исходная величина, выбранная в качестве по-
рождающего числа.
Для шифрования данных с помощью датчика ПСЧ может быть выбран
ключ любого размера. Например, пусть ключ состоит из набора чисел Х(j)
размерностью b, где j = 1, 2, ...., N. Тогда создаваемую гамму шифра G
можно представить как объединение непересекающихся множеств Н(j):
G = H(1) ∪ H(2) ∪…∪ H(N),
где Н(j) – множество соответствующих j-му сегменту данных и получен-
ных на основе порождающего числа Y(j), определенного как функция от
Х(j) (например, ПСЧ, полученное на основе Х(j)).
Разумеется, возможны и другие, более изощренные варианты выбора
порождающих чисел для гаммы шифра. Более того, гамму шифра необяза-
тельно рассматривать как объединение непересекающихся множеств. На-
пример, гамма шифра может быть представлена в виде
G = H(1) (+) H(2) (+) … (+) H(N),
где символ (+) обозначает операцию "исключающее ИЛИ".
Шифрование с помощью датчика ПСЧ является довольно распростра-
ненным криптографическим методом, а качество шифра определяется не
только и не столько характеристиками датчика, сколько алгоритмом полу-
чения гаммы. Хорошие результаты дает метод гаммирования с обратной
связью, который заключается в том, что для получения сегмента гаммы
используется контрольная сумма определенного участка шифруемых дан-
ных.
2.6. Примеры потоковых шифров
2.6.1. АЛГОРИТМ RC4
Алгоритм RC4 представляет собой потоковый шифр с переменной
длиной ключа, разработанный в 1987 г. Роном Ривестом для компании RSA
Data Security, Inc. В течение семи лет этот шифр лицензировался компани-
ей только на условиях неразглашения. Однако, в 1994 г. он был анонимно
опубликован в Интернете и с тех пор стал доступен для независимого ана-
лиза.
Описывается шифр очень просто. Алгоритм работает в режиме OFB.
Ключевая последовательность не зависит от исходного текста. Структура ал-
горитма включает блок замены размерностью 8 × 8: S0, ..., S255. Блок замены
представляет собой зависимую от ключа переменной длины перестановку
чисел 0, ..., 255. Имеется два счетчика i и j, первоначально равные 0. Для
генерирования псевдослучайного байта выполняются следующие действия:
( 1)mod 256,
( )mod256. i
i i
j j S
= +
= +
Далее переставить Si и Sj:
( )mod 256,
.
i j
i
t S S
k S
= +
=
Затем байт k складывается по модулю 2 с байтом исходного текста для
получения шифрованного.
Инициализация блока замены также проста. Вначале он заполняется
линейно: S0 = 0, ..., S255 = 255. Затем заполняется еще один 256-байтный массив
ключом, при этом ключ может повторяться необходимое число раз для за-
полнения всего массива: k0, ..., k255. Счетчик j устанавливается в 0. После
чего производятся следующие действия:
for i = 0 to 255
j = (j + ki + Si) mod 256
переставить Si и Sj.
Шифрование по этому алгоритму, примерно, в 10 раз быстрее, чем
шифрование DES при программной реализации.
Возможно обобщение алгоритма на большие длину слова и размер
блока замены. Например, можно построить шифр с блоком замены размер-
ностью 16 × 16 и длиной слова 16 бит. Этап инициализации будет значи-
тельно медленнее, необходим цикл до 65535, но получившийся в результа-
те алгоритм будет более быстрым.
2.6.2. АЛГОРИТМ SEAL
Алгоритм SEAL (Software Encryption Algorithm) представляет собой
приспособленный для программной реализации потоковый шифр, разрабо-
танный Филом Рогэвэем и Доном Копперсмитом из компании IBM. Алго-
ритм оптимизирован для 32-разрядных процессоров. Для эффективной ра-
боты ему требуются восьми 32-разрядных регистров и кэш объемом не-
сколько килобайт.
Одним из замечательных свойств этого шифра является то, что он не
является потоковым шифром в традиционном смысле, а представляет со-
бой семейство псевдослучайных функций. 160-битовый ключ k и 32-
битовое значение п (индекс) шифр преобразует в L-битовую строку k(n). L
может принимать любое значение, меньшее 64 килобайт. Такой шифр обо-
значают SEAL(k, n, L). Предполагается, что если k выбирается случайно, то
k(n) будет вычислительно неотличима от случайной L-битовой функции от
п.
Большинство шифров генерирует битовые последовательности в од-
ном направлении. Зная ключ k и позицию i, определить значение i-го бита
ключевой последовательности можно, только вычислив все биты до i-го
один за другим. В случае семейства псевдослучайных функций можно по-
лучить простой доступ к любому элементу ключевой последовательности.
Предположим, что необходимо зашифровать содержимое жесткого
диска компьютера по 512-байтным секторам. Тогда сектор с номером п
будет шифроваться с помощью ключевой последовательности k(n). При
этом легко может быть обеспечен доступ к произвольному сектору диска.
Данный шифр также облегчает проблему синхронизации, свойствен-
ную традиционным потоковым шифрам. Сообщение с номером п будет
шифроваться с ключевой последовательностью k(n), и п будет передаваться
вместе с сообщением. Получателю не нужно будет хранить состояние генера-
тора ключевой последовательности и беспокоиться о потерянных сообщениях
и их влиянии на процесс расшифрования.
Алгоритм SEAL предусматривает использование трех зависящих от
ключа таблиц: R, S и Т заполняются на предварительном этапе при помощи
алгоритма, основанного на SHA (описан далее), и зависят только от ключа.
Заполнение таблиц можно описать с помощью функции Ga(i), которая
представляет собой функцию сжатия из алгоритма SHA: а – 160-битное
значение, i – 32-битный индекс. Значение а используется для инициализа-
ции внутренних регистров А, В, С, D и Е в алгоритме SHA, а 512-битный
блок для обработки представляет собой строку i||0480. Выходное значение
функции G также имеет длину 512 бит.
Основные идеи, лежащие в основе этого алгоритма, можно сформули-
ровать следующим образом:
1. использование большого секретного, зависящего от ключа блока
замены Т;
2. перемежение операций, не коммутирующих друг с другом (сло-
жение и исключающее ИЛИ);
3. использование внутреннего состояния, явно не проявляющегося в
потоке данных (значения ni, используемые в конце итерации для модифи-
кации регистров А и С);
4. изменение шаговой функции в зависимости от номера шага и из-
менение итерационной функции в зависимости от номера итерации;
5. использование известных и отработанных алгоритмов для запол-
нения таблиц.
Шифр SEAL требует пять элементарных машинных операций в пере-
счете на один байт текста при шифровании и расшифровании. Таким обра-
зом, он является одним из самых быстрых программно реализуемых алго-
ритмов.
2.6.3. АЛГОРИТМ WAKE
Алгоритм WAKE (Word Auto Key Encryption – шифрование слов с ав-
тоключом) был предложен Дэвидом Уилером. На выходе получается по-
следовательность 32-битовых слов, которые могут служить в качестве гам-
мы шифра. WAKE работает в режиме СFВ – предыдущее слово шифрован-
ного текста используется для генерации следующего слова ключевой по-
следовательности.
В алгоритме используется специальный блок замены S из 256 32-
битных слов. При этом старшие байты этих слов являются перестановкой
чисел от 0 до 255, а остальные три младших байта выбираются случайны-
ми.
Вначале инициализируется блок замены на основе ключа. Затем ини-
циализируются четыре регистра А, В, С и D начальными значениями, также
зависящими от ключа (возможно другого): a0, b0, с0, d0. Очередное слово
ключевой последовательности получается по формуле ki = di .
После этого изменяется значение регистров:
1
1 1
1 1
1 1
( , );
( , );
( , );
( , ).
i i i
i i i
i i i
i i i
a Ma d
b Mb a
c Mc b
d Md c
+
+ +
+ +
+ +
=
=
=
=
где ( )&255 ( , ) ( ) 8 x y M x y x y S + = + 􀀕 ⊕ $ здесь 8 младших бит суммы х + у ис-
пользуются для входа в таблицу замены.
Данный шифр является достаточно быстрым, хотя и нестойким к ата-
кам по выбранному исходному тексту.
2.7. Комбинированные методы
Шифрование комбинированными методами основывается на резуль-
татах, полученных К. Шенноном. Наиболее часто применяются такие ком-
бинации, как подстановка и гамма, перестановка и гамма, подстановка и
перестановка, гамма и гамма. При составлении комбинированных шифров
необходимо проявлять осторожность, так как неправильный выбор состав-
лявших шифров может привести к исходному открытому тексту.
В качестве примера можно привести шифр, предложенный Д. Френд-
бергом, который комбинирует многоалфавитную подстановку с генерато-
ром ПСЧ. Особенность данного алгоритма состоит в том, что при большом
объеме шифртекста частотные характеристики символов шифртекста близ-
ки к равномерному распределению независимо от содержания открытого
текста.
Комбинация методов подстановки и перестановки была применена в
1974 г. фирмой IBM при разработке системы ЛЮЦИФЕР.
Система ЛЮЦИФЕР строится на базе блоков подстановки (S-блоков)
и блоков перестановки (Р-блоков). Блок подстановки включает линейные и
нелинейные преобразования.
Первый преобразователь S-блока осуществляет развертку двоичного
числа из n разрядов в число по основанию 2n. Второй преобразователь осу-
ществляет свертку этого числа.
Блок перестановки осуществляет преобразование n разрядного вход-
ного числа в n разрядное число.
Входные данные (открытый текст) последовательно проходят через че-
редующиеся слои 32-разрядных Р-блоков и 8-разрядных S-блоков.
Реализация шифрования данных в системе ЛЮЦИФЕР программными
средствами показала низкую производительность, поэтому P- и S-блоки
были реализованы аппаратно, это позволило достичь скорости шифрования
до 100 Кбайт/с. Опыт, полученный при разработке и эксплуатации систе-
мы, позволил создать стандарт шифрования данных DES (Data Encryption
Standard).
2.7.1. САМОСИНХРОНИЗИРУЮЩИЕСЯ ШИФРЫ
В 1946 г. в США была запатентована базовая идея так называемых са-
мосинхронизирующихся потоковых шифров (или шифрования с автоклю-
чом – CipherText Auto Key (CTAK)). Она заключается в том, что внутреннее
состояние генератора является функцией фиксированного числа предшест-
вующих битов шифрованного текста. Поскольку внутреннее состояние за-
висит только от п бит шифрованного текста, генератор на приемной сторо-
не войдет в синхронизм с передающей стороной после получения п бит.
Реализация этого подхода выглядит следующим образом. Каждое со-
общение предваряется случайным заголовком длиной п бит. Этот заголовок
шифруется и передается в линию. На приемной стороне заголовок расшиф-
ровывается. Результат расшифрования будет неверным, но после обработки
п бит заголовка оба генератора будут синхронизированы.
Недостатком системы является распространение ошибок. При искаже-
нии одного бита генератор на приемной стороне выдаст п неверных бит
ключевой последовательности, пока ошибочный бит не будет вытолкнут из
памяти, что приведет к ошибочному расшифрованию п бит исходного тек-
ста.
Кроме того, самосинхронизирующиеся шифры уязвимы для атак типа
"воспроизведение". Злоумышленник записывает некоторое количество бит
шифрованного текста. Затем, позднее, он подменяет биты трафика запи-
санными – "воспроизводит" их. После некоторого количества "мусора",
пока приемная сторона не синхронизируется, старый шифрованный текст
будет расшифровываться нормально. У приемной стороны нет никаких
средств определения того, что принимаемые данные не являются актуаль-
ными.
Самосинхронизирующиеся потоковые шифры могут быть реализова-
ны в виде блочных шифров, используемых в режиме обратной связи по
шифрованному тексту. При этом за один раз может шифроваться произ-
вольное число бит, меньшее либо равное длине блока. Проиллюстрируем
это на примере шифрования по одному байту за цикл.
Блочный шифр работает над очередью размером, равным длине блока.
Первоначально очередь заполняется синхропосылкой. Затем очередь шиф-
руется и левые 8 бит складываются с первыми 8 битами исходного текста.
Полученные 8 бит шифрованного текста передаются в линию, очередь
сдвигается влево на 8 бит, левые биты отбрасываются, а правые заполня-
ются 8 битами шифрованного текста, переданными в линию. Далее проце-
дура повторяется. Число 8 взято только для примера. За один цикл работы
блочного алгоритма может шифроваться и один бит, хотя это будет не
слишком эффективно с точки зрения скорости работы схемы. В режиме СРВ
синхропосылка должна быть уникальна для каждого сообщения в течение сро-
ка действия ключа. Если это будет не так, злоумышленник сможет восстано-
вить исходный текст.
В случае возникновения ошибки в шифрованном тексте на приемной
стороне в общем случае возникнут ошибки при расшифровании текущего и
последующих [m/n] блоков, где т – размер блока; п – число бит, шифруе-
мых за один цикл, т.е. пока ошибочный бит шифрованного текста не будет
вытеснен из памяти.
2.7.2. СИНХРОННЫЕ ШИФРЫ
Потоковые шифры носят название синхронных, если выходные значения
генератора не зависят от исходного или шифрованного текстов.
Основная сложность в данном подходе заключается в необходимости
синхронизации генераторов ключа на передающей и приемной сторонах.
Если в процессе передачи произошло выпадение или вставка хотя бы одно-
го бита, то вся последовательность битов шифрованного текста после оши-
бочного бита не сможет быть расшифрована. Если такое произойдет, сто-
роны должны провести повторную синхронизацию. При этом синхрониза-
ция должна быть проведена так, чтобы никакой отрезок ключевой последо-
вательности не повторился, так что очевидное решение возвратиться к не-
которому предыдущему состоянию генератора не подходит.
Положительным свойством синхронных потоковых шифров является
отсутствие эффекта распространения ошибок. Один искаженный бит при
передаче приведет к искажению только одного бита текста при расшифро-
вании.
Синхронные шифры также защищают от вставок и выбрасываний от-
резков шифрованного текста из потока. Такие операции приведут к нару-
шению синхронизации, что будет сразу же обнаружено на приемной сторо-
не.
Однако, такие шифры уязвимы к изменению отдельных бит. Если зло-
умышленник знает исходный текст, то он сможет изменять биты в потоке
шифрованного текста таким образом, что он будет расшифровываться так,
как необходимо злоумышленнику.
Синхронный потоковый шифр может быть реализован в виде блочно-
го шифра, работающего в режиме обратной связи по выходу (режим OFB) с
любым размером обратной связи, меньшим размера блока. Однако, данный
способ не рекомендуется, так как при этом снижается период генератора
до, примерно, 2m/2. При длине блока 64 это будет около 232, чего явно не-
достаточно.
В этом случае выходная функция очень часто выбирается простой, на-
пример, суммой по модулю 2 нескольких бит состояния или вообще одним
битом состояния. Криптографическая стойкость обеспечивается функцией
перехода к следующему состоянию, которая зависит от ключа. Иногда дан-
ный режим называют режимом с внутренней обратной связью, поскольку
обратная связь является внутренней по отношению к алгоритму генерации
ключевой последовательности.
Вариантом этого режима является схема, когда ключ задает начальное
состояние генератора, после чего последний работает без дальнейшего
вмешательства.
Еще одним способом построения потокового шифра является исполь-
зование счетчика в качестве входного значения для блочного шифра. После
каждого цикла шифрования блока значение счетчика увеличивается, чаще
всего на единицу. Свойства данного режима в отношении распространения
ошибок и синхронизации будут такими же, как и для режима OFB. В каче-
стве счетчика может быть использован любой генератор псевдослучайных
чисел, вне зависимости от его криптографической стойкости.
При использовании потокового шифра в режиме счетчика выбирается
простая функция перехода и сложная, зависящая от ключа функция выхода.
Функция перехода может быть простым счетчиком, увеличивающимся на
единицу на каждом такте.
2.7.4. МЕТОДЫ КОДИРОВАНИЯ
Как уже отмечалось, под кодированием понимается замена элементов
открытого текста (букв, слов, фраз и т.п.) кодами. Различают символьное и
смысловое кодирование.
При символьном кодировании каждый знак алфавита открытого текста
заменяется соответствующим символом. Примером символьного кодиро-
вания служит азбука Морзе, а также методы шифрования заменой и пере-
становкой. Рассмотрим метод символьного кодирования, который исполь-
зует предыдущие символы открытого текста. Этот метод, называемый ме-
тодом стопки книг, был предложен Б.Я. Рябко.
Предположим, что нужно передать сообщение X из алфавита А, в ко-
тором буквы алфавита отождествлены с числами 1, 2, …, L, где L – число
элементов алфавита А. Каждой букве алфавита соответствует код ki, 1 = 1,
..., L. При появлении в сообщении X очередной буквы хj ее код представля-
ется кодом номера позиции j, занимаемой в данный момент буквой хj в
списке. Это дает возможность на приемном конце по коду номера позиции
j определить букву хj. После кодирования буквы хj одновременно на прием-
ном и передающих концах перемещают букву хj в начало списка, увеличи-
вая тем самым на единицу номера букв, стоявших на позициях от 1 до j – 1.
Номера букв, стоявших на позициях от j + 1 до L, остаются без изменений.
В результате кодирования открытого текста в начале списка будут нахо-
диться буквы, которые наиболее часто встречались в открытом тексте.
Интересный метод кодирования в 1992 г. предложил С.П. Савчук. В
отличие от метода стопки книг перемещению подвергается список кодов.
Пусть алфавит А = {а1, а2, ..., аn}. Данному порядку расположения букв со-
ответствует начальный список кодов K0 = {k1, k2, ..., kn}. При появлении в
кодируемом сообщении буквы ai в качестве кода выбирается соответст-
вующий ее местоположению код ki. После этого осуществляется сдвиг спи-
ска кодов:
{k1, k2, ..., ki, ..., kn} → {k2, k3, ..., kn, k1}.
Таким образом, список кодов образует замкнутое кольцо.
Смысловое кодирование – это кодирование, в котором в качестве ис-
ходного алфавита используются не только отдельные символы (буквы), но
и слова и даже наиболее часто встречающиеся фразы.
Рассмотрим пример одноалфавитного и многоалфавитного смыслово-
го кодирования.
Пример. Открытый текст: "19.9.1992 ГОДА" (табл. 2.10).
2.10. Таблица кодирования
Элементы откpытого текста Коды
1 089 146 214 417
2 187 226 045 361
9 289 023 194 635
ГОД 031 155 217 473
. 786 432 319 157
Закодированное сообщение при одноалфавитном кодировании:
"089 289 786 289 786 089 289 289 187 031".
Закодированное сообщение при многоалфавитном кодировании:
"089 289 786 023 432 146 194 635 187 031" (при многоалфавитном ко-
дировании одинаковые символы заменяются кодами из следующего столб-
ца).
Среди различных кодов, применяемых для кодирования естественных
языков, особый интерес вызывает код Хаффмена, который позволяет сжи-
мать открытый текст. Суть его состоит в присваивании наиболее часто
встречающимся буквам наиболее коротких кодов.
Строка двоичных символов кодов Хаффмена единственным образом
разлагается на коды символов (такие коды называются префиксными).
Пример. Закодированное кодом Хаффмена сообщение имеет вид:
"01101000100000010101111000100000".
Пользуясь деpевом для английского языка, получаем 0110=S.
Далее снова начинаем движение из вершины: 100=E; 01000=C;
00010=U; 1011=R; 1010=I; 001=T; 00000=Y.
Открытый текст: "SECURITY".
2.7.5. ДРУГИЕ МЕТОДЫ
Широкое применение персональная ЭВМ (ПЭВМ) сделало актуальной
задачу защиты хранящихся данных (файлов). Для защиты файлов могут
быть применены рассмотренные методы шифрования и кодирования.
Специфика применения ПЭВМ позволяет реализовать дополнитель-
ные методы кодирования для надежного закрытия содержимого файлов.
Примером такого кодирования является метод рассечения-разнесения, в
соответствии с которым содержимое одного файла разбивается на блоки,
которые разносятся по нескольким файлам. Каждый такой файл не несет
никакой информации, а сбор данных в единое целое осуществляется про-
стой программой.
Пример. Блок (файл открытого текста) начинается словами: "МЕ-
ТОД_РАССЕЧЕНИЯ-РАЗНЕСЕНИЯ".
Для рассечения блока открытого текста на 8 частей запишем откры-
тый текст в следующем виде (табл. 2.11).
2.11. Рассечения открытого текста
1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4
1 М Е Т О С С Е Ч – Р А З Н И Я _
2 Д _ Р А Е Н И Я Н Е С Е
Для рассечения текста на 8 частей выбраны 2 строки и 4 столбца.
Пусть столбцы sj выбираются в последовательности {4, 1, 3, 2}, а строки ri
– в последовательности {2, 1}. Тогда номер k блока Фk, куда записывается
очередной символ открытого текста, определяется по формуле
k = (ri – 1)n + sj,
где n – число столбцов.
Первый символ М запишется в блок с номером (ri = 2, sj = 4) : k = (2 –
1)*4 + 4 = 8; второй символ E – в блок с номером (ri = 2, sj = 1) : k = (2 – 1)*4
+ 1 = 5, и т.д.
Тогда блоки Фk, записанные в порядке номеров, будут содержать
следующие символы: Ф1 = (_НЕ...), Ф2 = (АЯЕ...), Ф3 = (РИС..,),
Ф4 = {ДЕН...), Ф5 = {ЕСРИ...}, Ф6 = {ОЧЗ...), Ф7 = {ТЕАЯ...), Ф8 = {МС-
Н...}. Таким образом, один блок открытого текста заменяется восемью бло-
ками, которые в сумме дают длину исходного блока.
Одной из важных проблем при использовании ПЭВМ является про-
блема хранения больших массивов данных. Для этой цели применяют раз-
личные методы сжатия данных (сжатие рассматривается как метод кодиро-
вания).
Методы сжатия данных осуществляют такое преобразование повто-
ряющихся символов и строк символов, которое позволяет использовать для
хранения данных меньший объем памяти. Методы сжатия можно разделить на
два класса: статические и динамические (адаптивные).
Методы статического сжатия данных эффективны, когда частоты по-
явления символов изменяются незначительно. Методы динамического сжа-
тия адаптивно отслеживают неравномерности частот появления символов с
сохранением последовательности изменений вероятностей появления сим-
волов.
Адаптивные методы сжатия могут динамично реагировать на измене-
ния в открытом тексте, происходящие по мере кодирования. Первые такие
методы являлись модификацией кодов Хаффмена и использовали счетчики
для хранения текущих частот появления каждого символа. При таких мето-
дах наиболее часто встречающиеся символы сдвигаются ближе к корню
дерева и, следовательно, получают более короткие кодовые слова.
Кодирование Лемпеля-Зива использует синтаксический метод для ди-
намического источника. Этот метод осуществляет синтаксический анализ
символьных потоков, которые не превышают заданной длины, и строит
таблицу отображения этих потоков в кодированные слова фиксированной
длины. Длина кодового слова зависит от размера таблицы, используемой
для хранения кодового отображения поток-слово. Например, размер табли-
цы в 4096 слов требует 12-битового кодового слова. Кодовое слово являет-
ся просто табличным адресом соответствующих слов в таблице.
При кодировании по методу Лемпеля-Зива-Уэлча таблица инициали-
зируется символьным множеством и содержит вместо потоков заданной
длины пары (кодовое слово, символ) фиксированной длины. Таблица стро-
ится на основе синтаксического анализа самого длинного опознанного в
таблице потока и использовании последующего символа для формирования
нового входа в таблицу. Это позволяет уменьшить размеры таблицы.
В последнее время широкое распространение получили методы сжа-
тия на основе расширяющихся деревьев. Префиксный код переменной
длины в этих методах строится на основе положения символов в дереве.
Для получения оптимальных кодов дерево балансируется.
Несомненно, криптография должна стать обязательным компонентом
защиты всех сколько-нибудь развитых систем. К сожалению, этому мешает
огромное количество самых разных барьеров.
КОНТРОЛЬНЫЕ ВОПРОСЫ
1. Дайте определение шифра и сформулируйте основные требования
к нему.
2. Назовите и охарактеризуйте методы шифрования.
3. Дешифруйте сообщение, зашифрованное с помощью шифра про-
стой замены: " 11 03 18 21 11 04 15 02 13 29 12 10 01 28 02 18 21 11 01 28 28
12 30 12 21 32 04 00 27 32 01 21 11 12 27 32 01 32 12 14 28 12 21 28 01 23 32
02 21 22 04 27 32 12 21 28 01 21 00 12 32 12 29 12 22 21 28 01 06 12 11 02 32
27 18 21 27 03 12 10 12 21 11 04 15 02 13 29 12 10 01 28 02 04".
4. Поясните, что вы понимаете под совершенным шифром. Приведи-
те пример совершенного шифра.
5. Дешифруйте следующее сообщение: "15 03 23 21 22 32 14 06 25 14
04 07 24 16 31" методом перебора всех возможных ключей. Исходное со-
общение состоит из цифр от 0 до 32, которыми закодированы буквы в соот-
ветствии с табл. 4. Шифрование произведено сложением по модулю 32 с
псевдослучайной гаммой: K, (K2) mod 32, …, (Kn) mod 32, где K – неизвест-
ный ключ из множества чисел от 0 до 32.
6. Перечислите основные режимы работы, предусмотренные в рос-
сийском стандарте на шифрование данных.
7. Проведите сравнительный анализ параметров алгоритмов шифро-
вания DES, AES и Российского стандарта (в режиме простой замены).
8. Сравните наиболее распространенные стандарты шифрования.
3. АСИММЕТРИЧНЫЕ КРИПТОСИСТЕМЫ
3.1. Общие положения
Еще одним обширным классом криптографических систем являются
так называемые асимметричные или двухключевые системы. Эти системы
характеризуются тем, что для шифрования и для расшифрования исполь-
зуются разные ключи, связанные между собой некоторой зависимостью.
Применение таких шифров стало возможным благодаря К. Шеннону пред-
ложившему строить шифр таким способом, чтобы его раскрытие было эк-
вивалентно решению математической задачи, требующей выполнения объ-
емов вычислений, превосходящих возможности современных ЭВМ (на-
пример, операции с большими простыми числами и их произведениями).
Один из ключей (например, ключ шифрования) может быть сделан
общедоступным, и в этом случае проблема получения общего секретного
ключа для связи отпадает. Если сделать общедоступным ключ расшифро-
вания, то на базе полученной системы можно построить си-стему аутенти-
фикации передаваемых сообщений. Поскольку в большинстве случаев один
ключ из пары делается общедоступным, такие системы получили также
название криптосистем с открытым ключом.
Первый ключ не является секретным и может быть опубликован для
использования всеми пользователями системы, которые зашифровывают
данные. Расшифрование данных с помощью известного ключа невозможно.
Для расшифрования данных получатель зашифрованной информации ис-
пользует второй ключ, который является секретным. Разумеется, ключ
расшифрования не может быть определен из ключа зашифрования.
Использование асимметричного шифрования иллюстрирует рис. 3.1.
Криптосистема с открытым ключом определяется тремя алгоритмами:
генерации ключей, шифрования и расшифрования. Алгоритм генерации
ключей открыт, всякий может подать ему на вход случайную строку r над-
лежащей длины и получить пару ключей (k1, k2). Один из ключей (напри-
мер, k1) публикуется, он называется открытым, а второй, называемый сек-
ретным, хранится в тайне. Алгоритмы шифрования Ek и расшифрования Dk
таковы, что для любого открытого текста т
2 1 Dk (Ek (m)) = m.
Рассмотрим теперь гипотетическую атаку злоумышленника на эту
систему. Противнику известен открытый ключ k1, но неизвестен соответст-
вующий секретный ключ k2. Противник перехватил криптограмму d и пы-
тается найти сообщение m, где d = Ek (m). Поскольку алгоритм шифрования
открыт, противник может просто последовательно перебрать все возмож-
ные сообщения длины п, вычислить для каждого такого сообщения тi
криптограмму di = Ek (mi) и сравнить di с d. Тогда сообщение, для которого di
= d, и будет искомым открытым текстом. Если повезет, то открытый текст
будет найден достаточно быстро. В худшем же случае перебор будет вы-
полнен за время порядка 2nТ(п), где Т(п) – время, требуемое для шифрова-
ния сообщения длины п. Если сообщения имеют длину порядка 1000 битов,
то такой перебор неосуществим на практике ни на каких самых мощных
компьютерах.
Такой способ атаки на криптосистему и простейший алгоритм поиска
открытого текста называется алгоритмом полного перебора. Используется
также и другое название: "метод грубой силы". Другой простейший алго-
ритм поиска открытого текста – угадывание. Этот очевидный алгоритм
требует небольших вычислений, но срабатывает с пренебрежимо малой
вероятностью (при больших длинах текстов). На самом деле противник
может пытаться атаковать криптосистему различными способами и исполь-
зовать различные, более изощренные алгоритмы поиска открытого текста.
Кроме того, злоумышленник может попытаться восстановить секрет-
ный ключ, используя знания (в общем случае несекретные) о математиче-
ской зависимости между открытым и секретным ключами. Естественно
считать криптосистему стойкой, если любой такой алгоритм требует прак-
тически неосуществимого объема вычислений или срабатывает с пренеб-
режимо малой вероятностью. Это и есть теоретико-сложностный подход к
определению стойкости. Для его реализации в отношении того или иного
типа криптографических систем необходимо выполнить следующее: дать
формальное определение системы данного типа; дать формальное опреде-
ление стойкости системы; доказать стойкость конкретной конструкции сис-
темы данного типа.
Здесь сразу же возникает ряд проблем.
Во-первых, для применения теоретико-сложностного подхода необхо-
димо построить математическую модель криптографической си-стемы,
зависящую от некоторого параметра, называемого параметром безопасно-
сти, который может принимать сколь угодно большие значения (обычно
предполагается, что параметр безопасности может пробегать весь нату-
ральный ряд).
Во-вторых, определение стойкости криптографической системы зави-
Сообщение (X) Сообщение
(X=DK2 (EK1(X)))
Зашифрование
Зашифрованное
сообщение (Y =
EK1(X))
Расшифрование
Открытый
ключ (K1)
Секретный
ключ (K2)
Генератор ключей
Рис. 3.1. Использование асимметричного метода шифрования
сит от той задачи, которая стоит перед противником, и от того, какая ин-
формация о схеме ему доступна. Поэтому стойкость систем приходится
определять и исследовать отдельно для каждого предположения о против-
нике.
В-третьих, необходимо уточнить, какой объем вычислений можно
считать "практически неосуществимым". Из сказанного следует, что эта
величина не может быть просто константой, она должна быть представлена
функцией от растущего параметра безопасности. В соответствии с тезисом
Эдмондса алгоритм считается эффективным, если время его выполнения
ограничено некоторым полиномом от длины входного слова (от параметра
безопасности). В противном случае говорят, что вычисления по данному
алгоритму практически неосуществимы. При этом сами криптографические
системы должны быть эффективными, т.е. все вычисления, предписанные
той или иной схемой, должны выполняться за полиномиальное время.
В-четвертых, необходимо определить, какую вероятность можно счи-
тать пренебрежимо малой. В криптографии принято считать таковой лю-
бую вероятность, которая для любого полинома p и для всех достаточно
больших п не превосходит 1/р(п), где п – параметр безопасности.
Итак, при наличии всех указанных выше определений, проблема
обоснования стойкости криптографической системы сводится к доказа-
тельству отсутствия полиномиального алгоритма, который решает задачу,
стоящую перед противником. Но здесь возникает еще одно и весьма серь-
езное препятствие: современное состояние теории сложности вычислений
не позволяет доказывать сверхполиномиальные нижние оценки сложности
для конкретных задач рассматриваемого класса. Из этого следует, что на
данный момент стойкость криптографических систем может быть установ-
лена лишь с привлечением каких-либо недоказанных предположений. По-
этому основное направление исследований состоит в поиске наиболее сла-
бых достаточных условий (необходимых и достаточных) для существова-
ния стойких систем каждого из типов. В основном, рассматриваются пред-
положения двух типов – общие (или теоретико-сложностные) и теоретико-
числовые, т.е. предположения о сложности конкретных теоретико-
числовых задач. Все эти предположения в литературе обычно называются
криптографическими.
3.2. Односторонние функции и функции-ловушки
Центральным понятием в теории асимметричных криптографических
систем является понятие односторонней функции.
Под односторонней функцией понимается эффективно вычислимая
функция, для обращения которой (т.е. для поиска хотя бы одного значения
аргумента по заданному значению функции) не существует эффективных
алгоритмов. Заметим, что обратная функция может и не существовать.
Под функцией будем понимать семейство отображений {fn}, где
: n m , ( )
n f Σ →Σ m = m n .
Для простоты предположим, что п пробегает натуральный ряд, а ото-
бражения fn, определены всюду. Функция f называется честной, если
∃q(x),∀n q(m(n)) ≥ n .
Функцией-ловушкой называется односторонняя функция, для которой
обратную функцию вычислить просто, если имеется некоторая дополни-
тельная информация, и сложно, если такая информация отсутствует.
В качестве задач, приводящих к односторонним функциям, можно
привести следующие:
1. Разложение числа на простые сомножители. Вычислить произведе-
ние двух простых чисел очень просто. Однако, для решения обратной зада-
чи – разложения заданного числа на простые сомножители – эффективного
алгоритма в настоящее время не существует.
2. Дискретное логарифмирование в конечном простом поле (проблема
Диффи-Хеллмана). Допустим, задано большое простое число р и пусть g –
примитивный элемент поля GF(p). Тогда для любого а вычислить ga(mod р)
просто, а вычислить а по заданным k = ga(mod р) и р оказывается затрудни-
тельным.
Криптосистемы с открытым ключом основываются на односторонних
функциях-ловушках. При этом открытый ключ определяет конкретную
реализацию функции, а секретный ключ дает информацию о ловушке. Лю-
бой, знающий ловушку, может легко вычислять функцию в обоих направ-
лениях, но тот, у кого такая информация отсутствует, может производить
вычисления только в одном направлении. Прямое направление использует-
ся для шифрования и для верификации цифровых подписей, а обратное –
для расшифрования и выработки цифровой подписи.
Во всех криптосистемах с открытым ключом, чем больше длина клю-
ча, тем выше различие между усилиями, необходимыми для вычисления
функции в прямом и обратном направлениях (для того, кто не обладает
информацией о ловушке).
Все практические криптосистемы с открытым ключом основываются
на функциях, считающихся односторонними, но это свойство не было до-
казано в отношении ни одной из них. Это означает, что теоретически воз-
можно создание алгоритма, позволяющего легко вычислять обратную
функцию без знания информации о ловушке. В этом случае, криптосисте-
ма, основанная на этой функции, станет бесполезной. С другой стороны,
теоретические исследования могут привести к доказательству существова-
ния конкретной нижней границы сложности обращения некоторой функ-
ции, и это доказательство будет существенным событием, которое окажет
значительное позитивное влияние на развитие криптографии.
3.3. Асимметричные системы шифрования
3.3.1. КРИПТОСИСТЕМА ЭЛЬ-ГАМАЛЯ
Система Эль-Гамаля – это криптосистема с открытым ключом, осно-
ванная на проблеме логарифма, Система включает как алгоритм шифрова-
ния, так и алгоритм цифровой подписи.
Множество параметров системы включает простое число p и целое
число g, степени которого по модулю р порождают большое число элемен-
тов Zp. У пользователя А есть секретный ключ а и открытый ключ у, где у =
ga (mod р). Предположим, что пользователь В желает послать сообщение т
пользователю А. Сначала В выбирает случайное число k, меньшее р, и вы-
числяет
1 2 y = gk (mod p) , y = m⊕( yk (mod p)),
где ⊕ обозначает побитовое "исключающее ИЛИ". В посылает А пару (у1,
у2).
После получения шифрованного текста пользователь А вычисляет
1 2 m = ( ya mod p)⊕ y .
Известен вариант этой схемы, когда операция ⊕ заменяется на умно-
жение по модулю р. Это удобнее в том смысле, что в первом случае текст
(или значение хэш-функции) необходимо разбивать на блоки той же длины,
что и число yk (mod p). Во втором случае этого не требуется и можно обра-
батывать блоки текста заранее заданной фиксированной длины (меньшей,
чем длина числа р). Уравнение расшифрования в этом случае будет таким:
2 1 m = y / yk mod p .
Схема Эль-Гамаля не лишена определенных недостатков, среди них
можно указать следующие: отсутствие семантической стойкости; дели-
мость шифра. Для защиты от недостатков Шнорром и Якобссоном было
предложено объединить схему шифрования Эль-Гамаля с цифровой подпи-
сью Шнорра, что позволяет не только шифровать сообщение, но и аутен-
тифицировать его.
3.3.2. КРИПТОСИСТЕМА, ОСНОВАННАЯ НА ПРОБЛЕМЕ ДИФФИ-
ХЕЛЛМАНА
Система шифрования была представлена Мишелем Абдаллой, Михи-
ром Беллэром и Филлипом Рогэвэем в рамках европейского проекта NESSIE
(New European Schemes for Signatures, Integrity and Encryption). Она
столь же эффективна, что и система Эль-Гамаля, но обладает дополнитель-
ными свойствами безопасности. Более того, стойкость системы может быть
доказана в предположении о стойкости лежащих в ее основе криптографи-
ческих примитивов.
Данная криптосистема реализуема на основе любой циклической
группы, для которой может быть сформулирована проблема Диффи-
Хеллмана, например в {Zp
*} или в группе точек на эллиптической кривой.
Система строится из криптографических примитивов низкого уровня:
групповой операции, симметричного шифра, функции хэширования и ал-
горитма вычисления кода аутентификации сообщения-имитовставки
(MAC). Стойкость доказывается на основе предположения о сложности
решения соответствующей проблемы Диффи-Хеллмана и предположения о
стойкости входящих в схему симметричных примитивов.
Опишем криптографические примитивы, входящие в схему.
Циклическая группа G = {g}. Далее будем использовать мультиплика-
тивную запись групповой операции. Алгоритмы, реализующие эту опера-
цию, будут работать с представлениями элементов группы в виде битовых
строк фиксированной длины gLen ∈ N. Способ кодирования G →{0,1}gLen
не фиксируется и может быть выбран из соображений эффективности.
Код аутентификации сообщения позволяет пользователям, обладаю-
щим общим секретным ключом, выработать битовую строку для аутенти-
фикации и проверки целостности данных Пусть Msg = {0,1}* – пространство
сообщений, mKey = {0,1}mLen – пространство ключей для вычисления MAC
для некоторого mLen ∈ N, Tag = {0,1}tLen – включающее множество всех воз-
можных значений MAC для некоторого tLen ∈ N. В этих обозначениях код
аутентификации сообщений представляет собой пару алгоритмов MAC =
{MAC.gen, MAC.ver}. Алгоритм генерации MAC определяется как отображение
MAC.gen(k, x) :mKey ×Msg →Tag и может быть вероятностным.
Алгоритм верификации MAC является отображением со свойством
MAC.ver(k, x,MAC.gen(k, x)) =1.
В качестве MAC можно использовать, например, блочный шифр с дос-
таточной длиной блока и ключа в режиме сцепления блоков шифрованного
текста.
Симметричный шифр позволяет пользователям, обладающим общим
секретным ключом, обеспечить секретность. Пусть Msg, как и ранее, про-
странство сообщений, eKey = {0,1}eLen – пространство ключей для некоторо-
го eLen ∈ N, Ctext = {0,1}* – включающее множество всех возможных зна-
чений шифрованного текста и Coins = {0,1}∞ – множество строк бесконеч-
ной длины. В этих обозначениях шифр представляет собой пару алгорит-
мов SYM = {SYM.enc, SYM.dec}. Алгоритм зашифрования определяется как
отображение
SYM.enc(k, x, r) : eKey×Msg ×Coins→Ctext ,
алгоритм расшифрования является отображением
SYM.dec(k, y) : eKey×Ctext →Msg ∪{BAD},
где значение BAD выдается, если шифртекст у не является результатом за-
шифрования никакого открытого текста
Асимметричный шифр. Пусть Msg, Ctext, Coins определены как и ра-
нее, PK ⊆{0,1}* , SK ⊆{0,1}* – множества открытых и секретных ключей.
Асимметричный шифр определяется как тройка алгоритмов ASYM =
{ASYM.enc, ASYM.dec, ASYM.Key}. Алгоритм зашифрования является ото-
бражением
ASYM.enc( pk, x, r) : PK ×Msg ×Coins→Ctext ,
а расшифрования:
ASYM.enc(sk, y) : SK ×Ctext →Msg ∪{BAD} .
Алгоритм выработки ключа в качестве аргумента берет строку r ∈
Coins и выдает пару ключей pk, sk ∈PK × SK . При этом должно выпол-
няться следующее свойство:
∪
∪
( , ): ' :( , ) . ( '),
. ( , . ( , , ))
pk sk r Coins pk sk ASYM key r r Coins
x Msg ASYM dec sk ASYM enc pk x r x
∀ ∃ ∈ = ∀ ∈
∀ ∈ =
Функция хэширования является отображением следующего вида:
H :{0,1)2gLen →{0,1)mLen+eLen .
Теперь можно описать криптографические примитивы, непосредст-
венно составляющие рассматриваемую криптографическую систему. Гра-
фически процесс зашифрования представлен на рис. 3.2.
Рис. 3.2. Процесс зашифрования
Все ключевые пары в данном алгоритме выбираются так же, как и в
криптосистеме Эль-Гамаля, т.е. пара (pk, sK) = (gv, v) для некоторого слу-
чайного v. При отсылке сообщения выбирается некоторое случайное значе-
ние и и получателю отсылается gu, что обеспечивает неявный обмен клю-
чами по сxеме Диффи-Хеллмана. Таким образом, зашифрованное сообще-
ние состоит из одноразового открытого ключа, текста, зашифрованного
симметричным шифром, и кода аутентификации сообщения, выработанно-
го с помощью алгоритма MAC.gen.
Процесс расшифрования и аутентификации графически представлен
на рис. 3.3. Элементы принятого сообщения также выделены двойной рам-
кой.
Н
ASYM.key
SYM.enс
MАС.gen
;
.
MAC.ver
SYM.dec
Н
ОK
ВAD
Рис. 3.3. Процесс расшифрования и аутентификации
Рассмотренная криптосистема является семантически стойкой и неде-
лимой. В частности, неделимость обеспечивается тем, что значение gu по-
дается на вход функции хэширования. Если этого не сделать, то возможна
атака, подобная атаке на шифр Эль-Гамаля.
Эффективность предложенной схемы по существу та же, что и у шиф-
ра Эль-Гамаля, т.е. для зашифрования требуются две операции возведения
в степень, а для расшифрования – одна. Тем самым для больших сообще-
ний скорость шифрования будет определяться скоростью работы симмет-
ричного шифра и алгоритма вычисления кода аутентификации сообщения.
3.3.3. КРИПТОСИСТЕМА РИВЕСТА–ШАМИРА–АДЛЕМАНА
В настоящее время наиболее развитым методом криптографической
защиты информации с известным ключом является RSA, названный так по
начальным буквам фамилий ее изобретателей (Rivest, Shamir и Adleman) и
представляющую собой криптосистему, стойкость которой основана на
сложности решения задачи разложения числа на простые сомножители..
Перед тем как приступить к изложению концепции метода RSA, необходи-
мо определить некоторые термины.
Под простым числом будем понимать такое число, которое делится
только на единицу и на само себя. Взаимно простыми числами будем назы-
вать такие числа, которые не имеют ни одного общего делителя, кроме
единицы.
Под результатом операции i mod j будем считать остаток от целочис-
ленного деления i на j. Чтобы использовать алгоритм RSA, надо сначала
сгенерировать открытый и секретный ключи, выполнив следующие шаги:
• выберем два очень больших простых числа p и q;
• определим n как результат умножения p на q (n = p × q);
• выберем большое случайное число, которое назовем d (оно должно
быть взаимно простым с m результатом умножения (р – 1) × (q – 1));
• определим такое число e, для которого является истинным следую-
щее соотношение: (e × d) mod (m) =1 или e = (1 mod (m))/d.
Открытым ключом будут числа e и n, а секретным ключом – числа d и
n.
Теперь, чтобы зашифровать данные по известному ключу {e, n}, необ-
ходимо сделать следующее:
• разбить шифруемый текст на блоки, каждый из которых может
быть представлен в виде числа М(i) = 0, 1, …, n – 1;
• зашифровать текст, рассматриваемый как последовательность чисел
М(i) по формуле С(i) = (М(i)e) mod n.
Чтобы расшифровать данные, используя секретный ключ {d, n}, необ-
ходимо выполнить следующие вычисления: М(i) = (С(i)d) mod n. В резуль-
тате получится множество чисел М(i), которые представляют собой исход-
ный текст.
Пример. Применим метод RSA для шифрования сообщения "ГАЗ".
Для простоты будем использовать очень маленькие числа (на практике ис-
пользуются намного большие числа).
Выберем p = 3 и q = 11.
Определим n = 3 × 11 = 33.
Найдем (p – 1) × (q – 1) = 20. Следовательно, в качестве d выберем лю-
бое число, которое является взаимно простым с 20, например d = 3.
Выберем число е. В качестве такого числа может быть взято любое чис-
ло, для которого удовлетворяется соотношение (e × 3) mod 20 = 1, например
7.
Представим шифруемое сообщение как последовательность целых чи-
сел в диапазоне 0…32. Пусть буква А изображается числом 1, буква Г –
числом 4, а буква З – числом 9. Тогда сообщение можно представить в виде
последовательности чисел 4 1 9. Зашифруем сообщение, используя ключ
{7, 33}:
C1 = (47) mod 33 = 16384 mod 33 = 16,
C2 = (17) mod 33 = 1 mod 33 = 1,
C3 = (97) mod 33 = 4782969 mod 33 = 15.
Шифртекст: "16 1 15"
Попытаемся расшифровать сообщение {16, 1, 15}, полученное в ре-
зультате зашифрования по известному ключу, на основе секретного ключа
{3, 33}:
М1 = (163) mod 33 = 4096 mod 33 = 4,
М2 = (13) mod 33 = 1 mod 33 = 1,
М3 = (153) mod 33 = 3375 mod 33 = 9.
Таким образом, в результате расшифрования сообщения получено ис-
ходное сообщение "ГАЗ".
Криптостойкость алгоритма RSA основывается на предположении, что
исключительно трудно определить секретный ключ по известному, по-
скольку для этого необходимо решить задачу о существовании делителей
целого числа. Данная задача является NР – полной и, как следствие этого
факта, не допускает в настоящее время эффективного (полиномиального)
решения. Более того, сам вопрос существования эффективных алгоритмов
решения NР – полных задач является до настоящего времени открытым. В
связи с этим для чисел, состоящих из 200 цифр (а именно такие числа ре-
комендуется использовать), традиционные методы требуют выполнения
огромного числа операций (около 1023). Время выполнения наилучших из
известных алгоритмов разложения при п > 10145 на сегодняшний день вы-
ходит за пределы современных технологических возможностей.
Существует вариант криптосистемы RSA, в которой вместо функции
Эйлера используется функция Кармайкла λ, где λ(n) – наименьшее целое t,
такое что для любого целого х, взаимно простого с п, выполняется хt= 1
mod п. Если п выбирается так, как описано выше, то λ(n) = НОК(р – 1, q –
1).
3.3.4. КРИПТОСИСТЕМЫ МЕРКЛЯ-ХЕЛЛМАНА И ХОРА-РИВЕСТА
Криптосистемы Меркля-Хеллмана и Хора-Ривеста основаны на ис-
пользовании односторонней функции, известной под названием "задача
укладки рюкзака".
Пусть имеется п объектов, так что можно составить п-компонентный
вектор f, в котором i-й компонент f представляет собой место, занимаемое
i-м объектом. Имеется рюкзак общим объемом K.
Тогда задачу укладки рюкзака можно сформулировать следующим
образом: даны f и K, и требуется найти битовый вектор х, такой что fx = K.
Доказано, что не существует эффективного алгоритма вычисления х по f и
K в общем случае. Таким образом, можно использовать вектор f для шиф-
рования n-битового сообщения х путем вычисления произведения K = f x.
Важно отметить, что выбор f является критическим. Предположим,
что f выбирается в виде супервозрастающей последовательности, тогда для
любого i
1
1
i
i j
j
f f
−
=
> Σ .
В этом случае при данных f и K вычислить х очень просто. Проверим,
является ли K большим, чем последний элемент f, и если да, то делаем по-
следний элемент х равным 1, вычитаем это значение из K и рекурсивно ре-
шаем меньшую проблему. Этот метод работает, поскольку когда K больше
последнего элемента f, даже если выбрать х = (1 1 1 ... 1 0), то произведение
fx все равно будет слишком маленьким, благодаря тому, что последова-
тельность супервозрастающая. Таким образом, необходимо выбирать еди-
ницу в последней позиции х.
Ясно, что выбор f очень важен: можно получить, а можно и не полу-
чить одностороннюю функцию. Однако, именно существование этого про-
стого случая позволяет создать функцию-ловушку, которую можно исполь-
зовать для построения криптосистемы с открытым ключом.
Пользователь А получает свой открытый ключ следующим образом:
1. Выбирает супервозрастающую последовательность f’, примерно,
из 100 элементов.
2. Выбирает случайное целое т, большее суммы элементов f’.
3. Выбирает другое случайное целое w, взаимно простое с т.
4. Теперь вычисляется f' умножением каждого компонента f на w по
модулю т; f' = f w (mod m).
5. Проводится случайная перестановка Р элементов f’ для получения
открытого ключа f.
Теперь А раскрывает ключ f и держит в секрете f’, m, w и P.
Когда пользователь В хочет послать А сообщение (битовый вектор) х,
он вычисляет S = fx и посылает это вычисленное S. Если данная система
является стойкой, тогда для внешнего наблюдателя С вычисление х по S и
публичному ключу f будет эквивалентно решению задачи рюкзака в общем
случае. Допустим, что предположение о стойкости верно. В этом случае,
хотя С не может расшифровать сообщение, А может это сделать, применяя
секретные значения, которые он использовал при вычислении f.
Пользователь А может вычислить S'= f’x, так что она сможет решить
задачу рюкзака в случае супервозрастающей последовательности. Вычис-
ление S' производится следующим образом:
S′ = f ′x =Σ f ′x m = w− Σwf ′xi m =
i
i i
i
i mod mod 1
w 1 wf xi modm w 1S modm.
i
i
− Σ = −
Таким образом, А просто умножает S на мультипликативное обратное
w по модулю т, а затем решает задачу рюкзака в случае супервозрастаю-
щей последовательности f ′, и теперь сможет прочитать сообщение.
В 1982 г. Э. Шамир открыл атаку на криптосистему, использующую
одну итерацию, что привело к отказу от систем, основанных на "задаче
рюкзака".
В 1986 г. Бен-Цион Хор предложил криптосистему, на сегодняшний
день единственную, не использующую модульное умножение для скрытия
простой задачи укладки рюкзака. Это также единственная си-стема, осно-
ванная на задаче укладки рюкзака, которая не раскрыта.
Во-первых, что любая супервозрастающая последовательность должна
расти экспоненциально, поскольку минимальная супервозра-стающая по-
следовательность – это степени двойки. Во-вторых, отметим, что причина,
по которой используются супервозрастающие последовательности, заклю-
чается в том, что любая h-элементная сумма из нее уникальна. Другими
словами, если представить последовательность в виде вектора f, функция
скалярного произведения f на битовый вектор х будет однозначна и поэто-
му может быть обращена. Но оказывается возможным построить последо-
вательность, растущую только полиномиально, но сохраняющую свойство
единственности h-элементных сумм. Конструкция такой последовательно-
сти была опубликована в 1962 г.
Пусть GF(p) – поле целых чисел по модулю простого числа р, и GF(ph)
– расширение степени h основного поля. Также пусть 1 – вектор, все эле-
менты которого равны единице.
Построим последовательность длины р такую, что для любого i от 0 до
р – 1
1 ≤ аi ≤ ph – 1,
и для каждых различных х, у, таких, что х × 1 = у × 1 = h, x × a и у × а также
должны быть различны. Можно представить векторы х и у как битовые.
Далее построение проводится довольно просто. Во-первых, выберем t
– алгебраический элемент степени h над GF(p), т.е. минимальный много-
член с коэффициентами из GF(p), корнем которого является t, имеет сте-
пень h. Далее выберем g – мультипликативный генератор (примитивный
элемент) поля GF(ph), т.е. для каждого элемента х из GF(ph) (кроме нуля)
существует некоторое i, такое, что g в степени i будет равно х.
Теперь рассмотрим аддитивный сдвиг GF(p), т.е. множество
t + GF( p) = {t + i 0 ≤ i ≤ p −1}⊂ GF( ph ).
Пусть каждый элемент вектора а будет логарифмом по основанию g
соответствующего элемента из t + GF(p):
аi = logg (t +1).
При этом каждый элемент а будет лежать в заданном диапазоне, по-
скольку g порождает GF(p, h). Теперь пусть есть различные х и у, такие что
х × 1 = у × 1 = h, но х × а = у × а. Тогда, возводя g в степень х × а и у × а,
получим:
Σ −
=
1
0
p
i
xiai
g =
Σ −
=
1
0
p
i
yiai
g .
Это можно записать:
Π −
=
1
0
( )
p
i
x a i i g = Π
−
=
1
0
( )
p
i
y a i i g и Π
−
=
+
1
0
( )
p
i
xi i t = Π
−
=
+
1
0
( )
p
i
t i yi .
Теперь заметим, что произведение в обеих частях неравенства пред-
ставляет собой приведенный многочлен от t степени h. Иными словами,
если вычислить оба этих произведения и заменить значение t формальным
параметром z, тогда старшим членом на каждой стороне был бы х в степени
h с коэффициентом 1. Зная, что если подставить значение t вместо z, то
значения этих двух полиномов будут равны. Тогда вычтя один из другого,
старшие члены сократятся, и если подставить i, то получим 0. При этом
получим полином степени h – 1, корнем которого является t. Но это проти-
воречит тому, что выбранное t является алгебраическим элементом степени
h. Таким образом, доказательство закончено и построение корректно.
Хор Б.-Ц. разработал метод использования данного построения в каче-
стве основы криптосистемы. Выбирают р и h достаточно маленькими, что-
бы можно было вычислять дискретные логарифмы в GF(ph) (рекомендуется
p около 200, a h около 25), далее выбирают t и g. Для каждого из них будет
много вариантов, и можно просто произвести случайный выбор. (В дейст-
вительности, будет так много пар <t, g>, что очень большое количество
пользователей могут использовать одинаковые р и h, и вероятность того,
что два пользователя выберут одинаковые ключи, будет пренебрежимо
мала.). Затем, следуя конструкции Боуза–Чоула, вычисляют логарифмы по
основанию g от t + i для каждого i, что даст а. Наконец, выбирают случай-
ную перестановку а, которая и будет ключом. При этом о результатах пере-
становки а вместе с р и h извещают, а величины t, g и использованная пере-
становка остаются в секрете.
Чтобы послать сообщение А, В просто берет свое сообщение и вычис-
ляет S = х × а. В действительности, это не так уж и просто, поскольку со-
общение должно быть длиной p бит и должно быть х × 1 = h, но Хор Б.-Ц.
представил довольно прямолинейный метод преобразования неограничен-
ной битовой строки в несколько блоков, каждый из которых имеет требуе-
мую форму. А получает S. Он возводит g в степень S и выражает результат
в виде полинома от t степени h с коэффициентами из GF(p). Далее он вы-
числяет h корней этого полинома, затем применяет обратную подстановку
и получает индексы элементов в х, содержащих единицы.
Интересно отметить, что если кто-либо откроет эффективный метод
вычисления дискретных логарифмов, то такой алгоритм не только не по-
может вскрыть эту систему, но и облегчит генерацию ключей, так как при
этом необходимо вычислять дискретные логарифмы.
До настоящего времени не было опубликовано ни одного эффективно-
го метода вскрытия этой системы при знании только открытого ключа.
3.3.5. КРИПТОСИСТЕМЫ, ОСНОВАННЫЕ НА ЭЛЛИПТИЧЕСКИХ КРИ-
ВЫХ
Рассмотренная выше криптосистема Эль-Гамаля основана на том, что
проблема логарифмирования в конечном простом поле является сложной с
вычислительной точки зрения. Однако, конечные поля являются не единст-
венными алгебраическими структурами, в которых может быть поставлена
задача вычисления дискретного логарифма. В 1985 г. Коблиц и Миллер
независимо друг от друга предложили использовать для построения крип-
тосистем алгебраические структуры, определенные на множестве точек на
эллиптических кривых. Рассмотрим случаи определения эллиптических кри-
вых над простыми полями Галуа произвольной характеристики и над полями
Галуа характеристики 2.
Пусть р > 3 – простое число. Пусть a, b ∈ GF(p) такие, что
4a2 + 27b2 ≠ 0 . Эллиптической кривой Е над полем GF(p) называется мно-
жество решений (х, у) уравнения
y2 = x3 + ax + b
над полем GF(p) вместе с дополнительной точкой ∞ называемой точкой в
бесконечности или нулевой точкой О (поскольку эта точка выполняет роль
нейтрального элемента в группе точек). Такое представление эллиптиче-
ской кривой носит название эллиптической кривой в форме Вейерштрасса.
Если обозначить количество точек на эллиптической кривой Е через
#Е, то по теореме Хассе #E = p + 1 – t, где t ≤ 2 q .
#Е называется порядком кривой E, a t – следом кривой Е.
Множество точек эллиптической кривой Е с заданной бинарной опе-
рацией образует абелеву группу.
Если #Е = р + 1, то кривая Е называется суперсингулярной.
Эллиптическая не являющаяся суперсингулярной кривая Е над полем
GF(2m) характеристики 2 задается следующим образом.
Пусть т > 3 – целое число. Пусть a, b ∈ GF(2m), b ≠ 0. Эллиптической
кривой Е над полем GF(2m) называется множество решений (х, у) уравне-
ния
y2 + xy = x3 + ax + b
над полем GF(2m) вместе с дополнительной точкой ∞, называемой точкой в
бесконечности.
Количество точек на кривой Е также определяется теоремой Хассе:
q +1− 2 q ≤ #E≤ q +1+ 2 q , где q = 2m, a #Е – четно.
В этом случае множество точек эллиптической кривой Е с заданной
бинарной операцией также образует абелеву группу.
Группа точек на кривой имеет простую структуру, а именно она явля-
ется абелевой группой ранга 1 или 2, т.е. изоморфна прямому произведе-
нию двух циклических групп n1 n2 Z × Z , где п1 и п2 – целые числа, п2 делит п1
и n2 делит q – 1, где q – порядок поля коэффициентов, при этом п1 может
быть равно 1. Индекс подгруппы Zn в группе точек называют кофактором
эллиптической кривой.
Пользуясь операцией сложения точек на кривой, можно естественным
образом определить операцию умножения точки Р ∈ Е на произвольное
целое число п: пР = Р + Р + ... + Р, где операция сложения выполняется п
раз.
Теперь построим одностороннюю функцию, на основе которой можно
будет создать криптографическую систему.
Пусть Е – эллиптическая кривая, Р ∈ Е – точка на этой кривой. Выбе-
рем целое число п < #Е. Тогда в качестве прямой функции выберем произ-
ведение пР. Для его вычисления по оптимальному алгоритму потребуется
не более 2log2n операций сложения. Обратную задачу сформулируем сле-
дующим образом: по заданным эллиптической кривой Е, точке Р ∈ Е и
произведению пР найти п. В настоящее время все известные алгоритмы
решения этой задачи требуют экспоненциального времени.
Теперь можно описать криптографический протокол, аналогичный из-
вестному протоколу Диффи-Хеллмана. Для установления защищенной свя-
зи два пользователя А и В совместно выбирают эллиптическую кривую Е и
точку Р на ней. Затем каждый из пользователей выбирает свое секретное
целое число, соответственно а и b. Пользователь А вычисляет произведение
аР, а пользователь В – bР. Далее они обмениваются вычисленными значе-
ниями. При этом параметры самой кривой, координаты точки на ней и зна-
чения произведений являются открытыми и могут передаваться по неза-
щищенным каналам связи. Затем пользователь А умножает полученное
значение на а, а пользователь В умножает полученное им значение на b. В
силу свойств операции умножения на число аbР = bаР. Таким образом, оба
пользователя получат общее секретное значение (координаты точки аbР),
которое они могут использовать для получения ключа шифрования. Отме-
тим, что злоумышленнику для восстановления ключа потребуется решить
сложную с вычислительной точки зрения задачу определения а и b по из-
вестным Е, Р, аР и bР.
3.4. Применение асимметричных алгоритмов
Сообщение
Ключ
Открытый ключ получателя
Генератор ключей
(для каждого сообщения
генерируется свой ключ)
Симметричное
зашифрование
Зашифрованное
сообщение
Асимметричное
зашифрование
Зашифрованный
ключ
Рис. 3.4. Эффективное шифрование сообщения
Существенным недостатком асимметричных методов является их низ-
кое быстродействие, поэтому их приходится сочетать с симметричными
(асимметричные методы на 3–4 порядка медленнее симметричных). Так,
для решения задачи рассылки ключей сначала сообщение симметрично
шифруют случайным ключом, затем этот ключ шифруют открытым асим-
метричным ключом получателя, после чего сообщение и ключ отправляют-
ся по сети.
Рис. 3.4 иллюстрирует эффективное шифрование, реализованное путем
сочетания симметричного и асимметричного методов, а рис. 3.5 – расшиф-
рование эффективно зашифрованного сообщения.
Применение асимметричных методов позволило решить важную зада-
чу совместной выработки секретных ключей, обслуживающих сеанс взаи-
модействия, при изначальном отсутствии общих секретов. Для этого ис-
пользуется алгоритм Диффи-Хелмана.
Определенное распространение получила разновидность симметрич-
ного шифрования, основанная на использовании составных ключей. Идея
состоит в том, что секретный ключ делится на две части, хранящиеся от-
дельно. Каждая часть сама по себе не позволяет выполнить расшифрова-
ние. Если у правоохранительных органов появляются подозрения относи-
тельно лица, использующего некоторый ключ, они могут в установленном
порядке получить половинки ключа и дальше действовать обычным для
симметричной расшифровки образом.
Составные ключи – отличный пример следования принципу разделе-
ния обязанностей. Они позволяют сочетать право граждан на тайну с воз-
можностью эффективно следить за нарушителями закона, хотя, здесь очень
много тонкостей и технического, и юридического плана.
Криптографические методы позволяют надежно контролировать цело-
стность информации, определять ее подлинность, гарантировать невоз-
можность отказаться от совершенных действий. В отличие от традицион-
ных методов контрольного суммирования, способных противостоять толь-
ко случайным ошибкам, криптографическая контрольная сумма (имитов-
ставка), вычисленная с применением секретного ключа, практически ис-
ключает все возможности незаметным образом изменить данные.
КОНТРОЛЬНЫЕ ВОПРОСЫ
Сообщение
Ключ
Секретный ключ получателя
Симметричное
расшифрование
Зашифрованное
сообщение
Асимметричное
расшифрование
Зашифрованный
ключ
Рис. 3.5. Расшифрование эффективно зашифрованного сообщения
1. Дайте определение асимметричного шифрования (с открытым
ключом) и сформулируйте основные требования к нему.
2. Изложите схему организации секретной связи с использованием
системы шифрования с открытым ключом.
3. Назовите и охарактеризуйте методы шифрования с открытым
ключом.
4. Расскажите, каким образом можно организовать передачу цифро-
вых сообщений, с помощью криптосистемы RSA. Приведите примеры.
5. Расскажите, каким образом с помощью криптосистемы RSA можно
организовать передачу сообщений, подлинность которых подтверждена
цифровой подписью. Приведите примеры.
6. Пусть p = 383, q = 563, n = 215629, E = 49. Докажите, что в этом
случае открытый текст полностью восстанавливается уже через 10 шагов
повторного шифрования (подсказка: достаточно показать, что
4910 ≡ 1(mod(p – 1)q – 1))).
7. Дешифруйте сообщение "17 12 26 26 24 29 25 32 19 26 29 10 05 11
07 10 05 32 29 09 05 29 05 01 05 08 32 04 26 30 26 19 17 25 32 31 00 19 19 05
03 32 13 00 31 00 23 17", зашифрованное на открытом ключе: E = 3, n = 33.
Исходное сообщение состоит из цифр от 0 до 32, которыми закодированы
буквы в соответствии с табл. 4.
8. Разложите на простые сомножители число 391, которое является
произведением двух близких по значению простых чисел.
9. Сравните наиболее распространенные стандарты шифрования.
4. ЭЛЕКТРОННЫЕ ЦИФРОВЫЕ ПОДПИСИ
4.1. Постановка задачи
Передача сообщения отправителем (пользователь А) получателю
(пользователь В) предполагает передачу данных, побуждающую пользова-
телей к определенным действиям. Передача данных может представлять
собой передачу фондов между банками, продажу акций или облигаций на
автоматизированным рынке, а также передачу приказов (сигналов) по ка-
налам электросвязи. Участники нуждаются в защите от множества злона-
меренных действий, к которым относятся:
• отказ (ренегатство) – отправитель впоследствии отказывается от пе-
реданного сообщения;
• фальсификация – получатель подделывает сообщение;
• изменение – получатель вносит изменения в сообщение;
• маскировка – нарушитель маскируется под другого пользователя.
Для верификации (подтверждения) сообщения М (пользователь А – поль-
зователю В) необходимо следующее:
1. Отправитель (пользователь А) должен внести в М подпись, содер-
жащую дополнительную информацию, зависящую от М и, в общем случае,
от получателя сообщения и известной только отправителю закрытой ин-
формации kA.
2. Необходимо, чтобы правильную подпись М: SIG{kA, M, идентифи-
катор В} в сообщении для пользователя В нельзя было составить без kA.
3. Для предупреждения повторного использования устаревших сообще-
ний процедура составления подписи должны зависеть от времени.
4. Пользователь В должен иметь возможность удостовериться, что
SIG{kA, М, идентификатор В} – есть правильная подпись М пользователем
А.
Рассмотри эти пункты подробнее.
1. Подпись сообщения – определенный способ шифрования М путем
криптографического преобразования. Закрываемым элементом kA в преобра-
зовании <Идентификатор В, М >→ SIG{kA, M, идентификатор В} является
ключ криптопреобразования.
Цифровая сигнатура – это строка символов, зависящая как от иден-
тификатора отправителя, так и содержания сообщения.
Во всех практических криптографических системах kA принадлежит
конечному множеству ключей K. Исчерпывающая проверка всех ключей,
задаваемых соответствующими парами < М, идентификатор В > ↔ SIG{kA,
M, идентификатор В} в общем должна привести к определению ключа kA
злоумышленником. Если множество K достаточно велико и ключ k опреде-
лен методом случайного выбора, то полная проверка ключей невозможна.
Говоря, что составить правильную подпись без ключа невозможно, имеется
в виду, что определение SIG{kA, М, идентификатор В} без kA с вычисли-
тельной точки зрения эквивалентно поиску ключа.
2. Доступ к аппаратуре, программам и файлам системы обработки ин-
формации обычно контролируется паролями. Подпись – это вид пароля,
зависящий от отправителя, получателя информации и содержания переда-
ваемого сообщения.
3. Подпись должна меняться от сообщения к сообщению для преду-
преждения ее повторного использования с целью проверки нового сообще-
ния. Цифровая подпись отличается от рукописной, которая обычно не за-
висит от времени составления и данных. Цифровая и рукописная подписи
идентичны в том смысле, что они характерны только для данного владель-
ца
4. Хотя получатель информации не может составить правильную под-
пись, он должен уметь удостоверять ее подлинность. При коммерческих
сделках, например, продажа недвижимой собственности, эту функцию за-
частую выполняет третье, независимое доверенное лицо (нотариус).
Установление подлинности подписи – это процесс, посредством кото-
рого каждая сторона устанавливает подлинность другой. Обязательным
условием этого процесса является сохранение тайны. Во многих случаях
приходится удостоверять свою личность, например, подписью при получе-
нии денег по чеку либо фотографией в паспорте при пересечении границы.
Для того чтобы в системе обработки данных получатель мог установить
подлинность отправителя, необходимо выполнение следующих условий:
1. Отправитель (пользователь А) должен обеспечить получателя
(пользователя В) удостоверяющей информацией AUTH{kA, M, идентифика-
тор В}, зависящей от секретной информации kA, известной только пользо-
вателю А.
2. Необходимо, чтобы удостоверяющую информацию AUTH{kA,
идентификатор В} от пользователя А пользователю В можно было дать
только при наличии ключа kA.
3. Пользователь В должен располагать процедурой проверки того, что
AUTH{kA, идентификатор В} действительно подтверждает личность поль-
зователя А.
4. Для предупреждения использования предыдущей проверенной на
достоверность информации процесс установления подлинности должен
иметь некоторую зависимость от времени.
В основе криптографического контроля целостности лежат два поня-
тия: хэш-функция, электронная цифровая подпись (ЭЦП).
Хэш-функция – это труднообратимое преобразование данных (одно-
стороняя функция), реализуемое, как правило, средствами симметричного
шифрования со связыванием блоков. Результат шифрования последнего
блока (зависящий от всех предыдущих) и служит результатом хэш-
функции.
Пусть имеются данные, целостность которых должна быть проверена,
хэш-функция и ранее вычисленный результат ее применения к исходным
данным (дайджест). Хэш-функцию обозначим через h, исходные данные –
через Т, проверяемые данные – через Т’. Контроль целостности данных
сводится к проверке равенства h(T) = h(T’). Если оно выполняется, считает-
ся, что T = T’. Совпадение дайджестов для различных данных называется
коллизией. В принципе коллизии возможны (так как мощность множества
дайджестов меньше множества хэшируемых данных), однако, исходя из
определения хэш-функции, специально организовать коллизию за прием-
лемое время невозможно.
Асимметричные методы позволяют реализовать так называемую элек-
тронную цифровую подпись, или электронное заверение сообщения. Идея
состоит в том, что отправитель посылает два экземпляра сообщения – от-
крытое и дешифрованное его секретным ключом (естественно, дешифровка
незашифрованного сообщения на самом деле есть форма шифрования).
Получатель может зашифровать с помощью открытого ключа отправителя
дешифрованный экземпляр и сравнить с открытым. Если они совпадут,
личность и подпись отправителя можно считать установленными.
Пусть E(T) обозначает результат шифрования текста T с помощью от-
крытого ключа, а D(T) – результат дешифровки текста Т с помощью сек-
ретного ключа. Чтобы асимметричный метод мог применяться для реали-
зации электронной подписи, необходимо выполнение тождества
E(D(T)) = D(E(T)) = T.
Проиллюстрируем (рис. 4.1) процедуру эффективной генерации элек-
тронной подписи, состоящую в шифровании преобразованием D дайджеста
h(T), а проверка эффективно сгенерированной электронной подписи может
быть реализована способом, изображенным на рис. 4.2.
Из равенства E(S’) = h(T) следует S’ = D(h(T’)), т.о. ЭЦП защищает
целостность сообщения, удостоверяет личность отправителя и служит ос-
новой неотказуемости.
Два российских стандарта − "Процедуры выработки и проверки элек-
тронной цифровой подписи на базе асимметричного криптографического
алгоритма" и "Функция хэширования", объединенные общим заголовком
"Информационная технология. Криптографическая защита информации",
регламентируют вычисление дайджеста и реализацию электронной подпи-
си.
В сентябре 2001 г. утвержден, а с 1 июля 2002 г. вступил в силу новый
стандарт ЭЦП – ГОСТ Р 34.10–2001.
Для контроля целостности последовательности сообщений (т.е. защи-
ты от кражи, дублирования и переупорядочения сообщений) применяют
временные штампы и нумерацию элементов последовательности, при этом
штампы и номера включают в подписываемый текст.
Обратим внимание на то, что при использовании асимметричных ме-
тодов шифрования (в частности, ЭЦП) необходимо иметь гарантию под-
линности пары (имя, открытый ключ) адресата. Для решения этой задачи в
спецификациях Х.509 вводятся понятия цифрового сертификата и сертифи-
кационного центра. Сертификационный центр – это компонент глобальной
службы каталогов, отвечающий за управление криптографическими клю-
чами пользователей, заверяющий подлинность пары "имя–открытый ключ
адресата" своей подписью.
Цифровые сертификаты в формате Х.509 стали не только формаль-
ным, но и фактическим стандартом, поддерживаемым многочисленными
сертификационными центрами.
Отметим, что услуги, характерные для асимметричного шифрования,
Сообщение Т
Секретный ключ отправителя
Электронная
подпись
Сообщение T
ЭЦП D(h(T))
Дайджест h(T)
Рис. 4.1. Выработка электронной цифровой подписи
Сообщение Т
Открытый ключ отправителя
Сообщение T
E(S’)
Электронная под-
пись S’
Рис. 4.2. Проверка электронной цифровой подписи
E(S’)
=
Подтверждение
ЭЦП
можно реализовать и с помощью симметричных методов, если имеется на-
дежная третья сторона, знающая секретные ключи своих клиентов. Эта
идея положена, например, в основу сервера аутентификации Kerberos.
4.2. Алгоритмы электронной цифровой подписи
4.2.1. ЦИФРОВЫЕ ПОДПИСИ, ОСНОВАННЫЕ НА АСИММЕТРИЧНЫХ
КРИПТОСИСТЕМАХ
Для формирования системы ЭЦП можно использовать криптографи-
ческую систему Ривеста-Шамира-Адлемана.
Пользователь А вырабатывает цифровую подпись предназначенного
для пользователя В сообщения М с помощью следующего преобразования:
( ) eB ,nB ( dA ,nA ( )) SIG M = E E M .
При этом он использует: свое секретное преобразование dA ,nA E ; откры-
тое преобразование eB ,nB E пользователя В.
Затем он передает пользователю В пару 〈М, SIG(M)〉.
Пользователь В может верифицировать это подписанное сообщение
сначала при помощи своего секретного преобразования dB ,nB E с целью по-
лучения
, , , , , ( ) ( ( )) ( ( ( ))) dA nA dB nB dB nB eB nB dA nA E M = E SIG M = E E E M
и затем открытого , eA nA E пользователя А для получения сообщения М:
, , ( ( )) eA nA dA nA M = E E M .
Затем пользователь В производит сравнение полученного сообщения
М с тем, которое он получил в результате проверки цифровой подписи, и
принимает решение о подлинности/подложности полученного сообщения.
В рассмотренном примере проверить подлинность ЭЦП может только
пользователь В. Если же требуется обеспечение возможности верификации
ЭЦП произвольным пользователем (например, при циркулярной рассылке
документа), то алгоритм выработки ЭЦП упрощается, и подпись вырабаты-
вается по формуле
, ( ) ( ) dA nA SIG M = E M ,
а пользователи осуществляют верификацию с использованием открытого
преобразования отправителя (пользователя А):
, , , ( ( )) ( ( )) eA nA eA nA dA nA M = E SIG M = E E M .
Вместо криптосистемы RSA для подписи сообщений можно использо-
вать и любую другую асимметричную криптосистему.
Недостатком подобного подхода является то, что производительность
асимметричной криптосистемы может оказаться недостаточной для удов-
летворения предъявляемым требованиям.
Возможным решением является применение специальной эффективно
вычисляемой функции, называемой хэш-функцией или функцией хэширо-
вания. Входом этой функции является сообщение, а выходом – слово фик-
сированной длины, много меньшей, чем длина исходного сообщения. ЭЦП
вырабатывается по той же схеме, но при этом используется не само сооб-
щение, а значение хэш-функции от него.
Очень часто бывает желательно, чтобы электронная цифровая подпись
была разной, даже если дважды подписывается одно и то же сообщение.
Для этого в процесс выработки ЭЦП необходимо внести элемент "случай-
ности". Конкретный способ был предложен Эль-Гамалем аналогично тому,
как это делается в системе шифрования, носящей его имя.
Выбирается большое простое число р и целое число g, являющееся
примитивным элементом в Zp. Эти числа публикуются. Затем выбирается
секретное число х и вычисляется открытый ключ для проверки подписи
y = gx (mod p) .
Далее для подписи сообщения М вычисляется его хэш-функция т =
h(M). Выбирается случайное целое k: 1 < k < (р – 1), взаимно простое с р –
1, и вычисляется r = gk (mod p) . После этого с помощью расширенного
алгоритма Евклида решается относительно s уравнение
m = xr + ks(mod ( p −1)) . Подпись образует пара чисел (r, s). После выработ-
ки подписи значение k уничтожается.
Получатель подписанного сообщения вычисляет хэш-функцию со-
общения т = h(M) и проверяет выполнение равенства
yrrs = gxr gks = gxr+ks = gm (mod p) . Корректность этого уравнения очевидна.
Еще одна подобная схема была предложена Шнорром. Как обычно, р
– большое простое число; q – простой делитель (р – 1); g – элемент порядка
q в Zр; k – случайное число, х и у = gx (mod p) – секретный и открытый клю-
чи соответственно. Уравнения выработки подписи выглядят следующим
образом:
r = gk (mod p); e = h(m, r); s = k + xe(mod q) .
Подписью является пара (r, s). На приемной стороне вычисляется зна-
чение хэш-функции e = h(m, r) и проверяется выполнение равенства
r = gs y−e (mod p) , при этом действия с показателями степени производятся
по модулю q.
Другой вариант подписи Шнорра выглядит так. Для подписи сообще-
ния т автор выбирает случайное k ∈ Zq, вычисляет gk (mod р), е = h(gk, т) и
z = k + xe (mod q) . Подписью является тройка (т, е, z). Проверка подписи
заключается в проверке равенства h(g z y−e ,m) = e .
4.2.2. СТАНДАРТ ЦИФРОВОЙ ПОДПИСИ DSS
Новая редакция стандарта на выработку и верификацию цифровой
подписи DSS (Digital Signature Standard) принята в США 7 января 2000 г.
(FIPS PUB 186-2). Согласно этому стандарту, электронная цифровая под-
пись может вырабатываться по одному из трех алгоритмов: DSA (Digital
Signature Algorithm), основанному на проблеме логарифма в конечном по-
ле, ANSI Х9.31 (RSA DSA) или ANSI X9.63 (ЕС DSA – алгоритм выработки
подписи, основанной на проблеме логарифма в группе точек эллиптиче-
ской кривой над конечным полем).
Опишем алгоритм DSA.
1. Предварительный этап – выбор параметров.
Выбираются числа р, q и g, такие, что р – простое число, 2l−1 < p < 2l ,
где l кратно 64 и 512 < l < 1024; q – простой делитель числа p – 1 длиной
160 бит (2159 < q < 2160); g – элемент порядка q в Zp. g выбирается в виде g =
h(p – 1)/q, где 1 < h < p – 1 и h(p – 1)/q > 1. Эти три числа являются открытыми
данными и могут быть общими для группы пользователей.
Выбирается секретный ключ х, 0 < х < q, и вычисляется открытый
ключ для проверки подписи у = gx (mod p).
2. Выработка электронной цифровой подписи.
Вычисляется значение хэш-функции от сообщения h(/w). При этом ис-
пользуется алгоритм безопасного хэширования SHA-1 (Secure Hashing Algorithm),
на который ссылается стандарт (FIPS PUB 180-1). Значение хэш-
функции h(/w) имеет длину 160 бит.
Далее подписывающий выбирает случайное или псевдослучайное значе-
ние k, 0 < k < q, вычисляет k-1mod q, и вырабатывает пару значений:
r = gk (mod p)(mod q); s = k −1(h(m) + xr)(mod q) .
Эта пара значений (r, s) и является электронной подписью под сооб-
щением М. После выработки цифровой подписи значение k уничтожается.
3. Верификация электронной цифровой подписи.
Пусть было принято сообщение m1. Тогда уравнение проверки выгля-
дит следующим образом:
1 1
r gh(m1 )s yrs (mod p)(mod q) − − ≡ .
Алгоритм выработки ЭЦП, основанный на эллиптических кривых,
может быть описан следующим образом:
1. Выбор параметров. Стандарт определяет поля, над которыми зада-
ются эллиптические кривые. Это простые поля Галуа и поля Галуа харак-
теристики 2. Выбор полей в стандарте сделан, исходя из требования повы-
шения вычислительной эффективности машинных операций умножения в
поле. Для этого в качестве простых модулей выбраны так называемые
обобщенные числа Мерсенна (табл. 4.1).
4.1. Обобщенные числа Марсенна для эллиптических кривых
Кривая Р
Р-192 2192 – 264 – 1
Р-224 2224 – 296 + 1
Р-256 2256 – 2224 + 2192 + 296 – 1
Р-384 2384 – 2128 – 296 + 232 – 1
Р-521 2521 – 1
Стандарт фиксирует кривые, которые должны использоваться в алго-
ритмах, и примерные базовые точки на этих кривых. Пользователь может
либо воспользоваться приведенными в стандарте базовыми точками, либо
сгенерировать свои, если, например, ему понадобится обеспечить крипто-
графическое разделение сетей ЭВМ. В частности, кривые Р-192, ..., Р-521
представляют собой эллиптические кривые простого порядка r вида у2 = х3
– 3х + b над полем GF(p).
Для задания кривых над полями характеристики 2 выбраны порождаю-
щие многочлены. При этом возможно использовать представление полей как
в полиномиальном, так и в нормальном базисах (табл. 4.2).
4.2. Порождающие многочлены
Кривая Порождающий многочлен p(t) Тип нормального базиса
К-163, В-163 t163 + t7 + t6 + t3+ 1 4
К-233, В-233 t233 + t74 + 1 2
К-283, В-283 t283 + t12 + t7 + t5+ 1 6
К-409, В-409 t409 + t87 + 1 4
К-571, В-571 t571 + t10 + t5 + t2+ 1 10
Коэффициенты b заданы для каждого размера поля. Например, кривая
Р–521 задается коэффициентом b = 051 953еb961 8elc9alf 929а21а0
b68540ее a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b
1652c0bd 3bblbf07 3573df88 3d2c34fl ef451fd4 6b503f00 (в шестнадцатерич-
ном виде) и имеет порядок r = 686479766013060971498
19007990813932172694353001433054093944634591855431833976553942450
57746333217197532963996371363321113864768612440380340372808892707
005449 (в десятичной записи).
Поскольку определенные в стандарте кривые имеют простой порядок,
группы точек на них являются циклическими и порядок базовой точки п в
точности равен r.
Для каждого из полей GF(2m) в стандарте указаны по две кривых:
псевдослучайная вида у2 + ху = х3 + х2 + b, и специальная кривая Коблица,
или аномальная двоичная кривая вида у2 + ху = х3 + ах2 + 1, где а = 0 или 1.
При генерации ключевой пары пользователь выбирает в качестве сек-
ретного ключа целое число d, 0 < d < п, где п – порядок базовой точки G на
эллиптической кривой. Далее он вычисляет Q = dG и публикует Q в качест-
ве открытого ключа.
2. Выработка ЭЦП. Для того, чтобы подписать сообщение т, пользо-
ватель:
1) Выбирает случайное число k, 0 < k < n – 1.
2) Вычисляет kG = (х1, у1), r = х1(mod п). Если r = 0, то перейти к ша-
гу 1.
3) Вычисляет k-1 (mod п).
4) Вычисляет е = SHA(m). Выбор варианта функции хэширования
осуществляется в зависимости от используемого поля.
5) Вычисляет s = k −1(e + dr)mod n . Если s = 0, то перейти к шагу 1.
6) Подписью сообщения т является пара (r, s).
3. Верификация ЭЦП.
Для проверки подписи получатель сообщения выполняет следующие
действия:
1) Проверяет, что r и s лежат на интервале (0, п).
2) Вычисляет е = SHA(m).
3) Вычисляет w = s-l mod n.
4) Вычисляет u1 = ew mod п и w2 = rw mod n.
5) Вычисляет Х = u1G + u2Q. Если Х = ∞, то подпись отвергается,
иначе, вычислить v = x1 mod n, где Х = (х1, у1).
6) Принять подпись, если и только если v = г.
4.2.3. СТАНДАРТ ЦИФРОВОЙ ПОДПИСИ ГОСТ Р 34.10–94
Российский стандарт ЭЦП разрабатывался позже первоначального ва-
рианта американского, поэтому параметры этого алгоритма выбраны с уче-
том возросших возможностей потенциального противника по вскрытию
криптосистем. В частности, увеличена длина значения хэш-функции, что
снижает вероятность столкновений, и, соответственно, порядок элемента-
генератора, что делает более сложным решение задачи дискретного лога-
рифма для восстановления секретного ключа. При описании алгоритма будут
использоваться следующие обозначения:
В* – множество всех конечных слов в алфавите В = {0,1};
|A| – длина слова А;
Vk(2) – множество всех двоичных слов длины k;
А||В – конкатенация слов А и В, также обозначается как АВ;
Ak – конкатенация k экземпляров слова А;
<N>k – слово длины k, содержащее запись N(mod 2k), где N –
неотрицательное целое;
⊕ – побитовое сложение слов по модулю 2;
[+] – сложение по правилу А [+] В = <A + B > k (k = |А| = |В|);
т – передаваемое сообщение;
т1 – полученное сообщение;
h – хэш-функция, отображающая последовательность т в слово h(m) ∈
V256(2) ;
р – простое число, 2509 <р < 2512, либо 21020 < р < 21024;
q – простое число, 2254 < q < 2256 и q является делителем для (p – 1) ;
а – целое число, 1 < а < р – 1, при этом aq(mod p) = 1;
k – целое число, 0 < k < q;
х – секретный ключ пользователя для формирования подписи, 0 < х <
q;
у – открытый ключ для проверки подписи у = ax(mod p).
Система ЭЦП включает в себя процедуры выработки и проверки под-
писи под данным сообщением.
Цифровая подпись, состоящая из двух целых чисел, вычисляется с по-
мощью определенного набора правил, изложенных в стандарте.
Числа p, q и а, являющиеся параметрами системы, не являются сек-
ретными. Конкретный набор их значений может быть общим для группы
пользователей. Целое число k, которое генерируется в процедуре подписи
сообщения, должно быть секретным и должно быть уничтожено сразу по-
сле выработки подписи. Число k снимается с физического датчика случай-
ных чисел или вырабатывается псевдослучайным методом с использовани-
ем секретных параметров.
Процедура выработки подписи включает в себя следующие шаги:
1. Вычислить h(m) – значение хэш-функции h от сообщения т. Если
h(m)(mod q) = 0, то присвоить h(m) значение 02551.
2. Выработать целое число k, 0 < k < q.
3. Вычислить два значения: r' = d
k(mod p) и r = r' (mod q). Если r = 0,
то перейти к шагу 2 и выработать другое значение числа k.
4. С использованием секретного ключа х пользователя вычислить
значение s = (xr + kh(m))(mod q) . Если s = 0, то перейти к шагу 2, в против-
ном случае закончить работу алгоритма.
Сообщение, дающее нулевое значение хэш-функции, не подписывает-
ся. В противном случае уравнение подписи упростилось бы до s = xr (mod
q) и злоумышленник легко мог бы вычислить секретный ключ х.
Проверка цифровой подписи возможна при наличии у получателя от-
крытого ключа отправителя, пославшего сообщение.
Уравнение проверки будет следующим:
1 1
r (ash(m1 ) y rh(m1 ) (mod p))(mod q) ≡ − − − .
Вычисления по этому уравнению реализуются следующим образом:
1. Проверить условия: 0 < s < q и 0 < r < q. Если хотя бы одно из этих
условий не выполнено, то подпись считается недействительной.
2. Вычислить h(m1) – значение хэш-функции h от полученного сооб-
щения т1. Если h(m1)(mod q) = 0, присвоить h(m1) значение 02551.
3. Вычислить значение v = (h(m1)))q–2(mod q), что является ни чем
иным, как мультипликативным обратным к h(m1)(mod q). Вообще говоря,
алгоритм проверки можно несколько ускорить, если вычислять h(m1)–1(mod
q) с помощью расширенного алгоритма Евклида, а ни путем возведения в
степень.
4. Вычислить значения: 1 z = sv(mod q) и 2 z = (q − r)v(mod q) .
5. Вычислить значение u = (az1 yz2 (mod p))(mod q) .
6. Проверить условие r = и.
При совпадении значений r и и получатель принимает решение о том,
что полученное сообщение подписано данным отправителем и в процессе
передачи не нарушена целостность сообщения, т.е. т1 = т. В противном
случае подпись считается недействительной.
4.2.4. СТАНДАРТ ЦИФРОВОЙ ПОДПИСИ ГОСТ Р 34.10–2001
С повышением производительности вычислительных средств и усо-
вершенствованием алгоритмов вычисления логарифмов в конечном поле поя-
вилась потребность в повышении стойкости ЭЦП к различного рода атакам. В
связи с этим был разработан стандарт ГОСТ Р 34.10–2001 "Информационная
технология. Криптографическая защита информации. Процессы формиро-
вания и проверки электронной цифровой подписи", введенный с 1 июля
2002 г. вместо ранее действовавшего стандарта ГОСТ Р 34.10–94.
В данном стандарте используются операции группы точек эллиптиче-
ской кривой над конечным полем. Применяется эллиптическая кривая Е в
форме Вейерштрасса над простым полем, задаваемая коэффициентами а и
b или величиной J(E), называемой инвариантом эллиптической кривой:
3
3 2
( ) 1728 4 (mod )
4 27
J E a p
a b
≡
+
.
Коэффициенты а и b кривой Е определяются по известному инвариан-
ту следующим образом:
3 (mod ),
2 (mod ), ( ) (mod ), ( ) 0 1728.
1728 ( )
a k p
b k p ãäå k J E p J E èëè
J E
≡ 


 ≡ ≡ ≠  −
Точку Q будем называть точкой кратности k, k ∈ Z, если для некото-
рой точки Р выполнено равенство Q = kP.
Параметрами схемы ЭЦП являются следующие значения: р – модуль
эллиптической кривой, простое число; p > 2255; эллиптическая кривая, зада-
ваемая инвариантом J(E) или коэффициентами а и b; целое число т – порядок
группы точек эллиптической кривой Е; простое число q – порядок цикли-
ческой подгруппы группы точек эллиптической кривой Е, для которого
выполнены следующие условия:
m = nq, n∈Z, n ≥1, 2254 ≤ q ≤ 2256.
Базовая точка Р ≠ 0 на кривой, имеющая порядок q, т.е. удовлетво-
ряющая равенству qP = 0. Координаты этой точки обозначим через (хр, ур);
где или
хэш-функция, отображающая сообщения произвольной длины в множество
двоичных векторов длины 256. Хэш-функция определена стандартом ГОСТ
Р 34.11–94.
Каждый пользователь схемы ЭЦП должен обладать личной ключевой
парой:
• секретный ключ пользователя – целое число d, 0 < d < q;
• открытый ключ пользователя – точка Q с координатами (xq, yq),
удовлетворяющая равенству dP = Q.
Параметры ЭЦП должны удовлетворять следующим условиям:
pt ≠ 1(mod q) , для всех целых t = 1, 2, ..., В, где B удовлетворяет нера-
венству В ≥ 31; т ≠ р; J(E) ≠ 0 или 1728.
Двоичному вектору h = (α255, ..., α0 ) ставится в соответствие число
Σ=
α = α
255
0
2
i
t
i .
ЭЦП под сообщением М вырабатывается по следующему алгоритму:
1. Вычислить хэш-функцию сообщения М: h = h(M) .
2. Вычислить целое число α, двоичным представлением которого яв-
ляется вектор h, и определить е ≡ α(mod q) . Если е = 0, то задать е = 1.
3. Сгенерировать (псевдо)случайное целое число k, удовлетворяющее
неравенствам 0 < k < q;
4. Вычислить точку эллиптической кривой C = kP и положить
(mod ) c r ≡ x q , где хс – x – координата точки С. Если r = 0, то вернуться на
шаг 3.
5. Вычислить значение s ≡ (rd + ke)(mod q) . Если s = 0, то вернуться
на шаг 3.
6. Вычислить двоичные векторы, соответствующие числам r и s. Оп-
ределить цифровую подпись ζ = (r s) как конкатенацию двух двоичных
векторов.
Для проверки подписи ζ под полученным сообщением М необходимо
выполнить следующие действия, используя ключ проверки подписи Q.
1. По полученной подписи ζ вычислить целые числа r и s. Если выпол-
нены неравенства 0 < r < q, 0 < s < q, то перейти к следующему шагу. В
противном случае подпись неверна.
2. Вычислить хэш-функцию полученного сообщения М:
h = h(M) .
3. Вычислить целое число α, двоичным представлением которого является
вектор h и определить е ≡ α(mod q) . Если е = 0, то задать е = 1.
4. Вычислить значение v ≡ e−1(mod q) .
5. Вычислить значения 1 2 z ≡ sv(mod q), z ≡ −rv(mod q) .
6. Вычислить точку эллиптической кривой С = z1P + z2Q и определить
(mod ) c R ≡ x q , где хс – x-координата точки С.
7. Если выполнено равенство R = r, то подпись принимается, в про-
тивном случае подпись неверна.
4.2.5. ЦИФРОВЫЕ ПОДПИСИ, ОСНОВАННЫЕ НА СИММЕТРИЧНЫХ
КРИПТОСИСТЕМАХ
Общеизвестно, что так называемая "современная", она же двухключе-
вая криптография возникла и стала быстро развиваться в последние деся-
тилетия именно потому, что ряд новых криптографических протоколов
типа протокола цифровой подписи не удалось эффективно реализовать на
базе традиционных криптографических алгоритмов, широко известных и
хорошо изученных к тому времени. Тем не менее, это возможно. И первы-
ми, кто обратил на это внимание, были родоначальники криптографии с
открытым ключом У. Диффи и М. Хеллман, опубликовавшие описание
подхода, позволяющего выполнять процедуру цифровой подписи одного
бита с помощью блочного шифра. Прежде чем изложить эту идею примем
во внимание несколько замечаний о сути и реализациях цифровой подписи.
Стойкость какой-либо схемы подписи доказывается обычно установ-
лением равносильности соответствующей задачи вскрытия схемы какой-
либо другой, о которой известно, что она вычислительно неразрешима.
Практически все современные алгоритмы ЭЦП основаны на так называе-
мых "сложных математических задачах" типа факторизации больших чисел
или логарифмирования в дискретных полях. Однако, доказательство не-
возможности эффективного вычислительного решения этих задач отсутст-
вует, и нет никаких гарантий, что они не будут решены в ближайшем бу-
дущем, а соответствующие схемы взломаны – как это произошло с "ранце-
вой" схемой цифровой подписи. Более того, с бурным прогрессом средств
вычислительной техники "границы надежности" методов отодвигаются в
область все больших размеров блока. Всего пару десятилетий назад, на заре
криптографии, с открытым ключом считалось, что для реализации схемы
подписи RSA достаточно даже 128-битовых чисел.
Сейчас эта граница отодвинута до 1024-битовых чисел и это далеко
еще не предел. Все это приводит к необходимости переписывать реали-
зующие схему программы, и зачастую перепроектировать аппаратуру. Ни-
чего подобного не наблюдается в области классических блочных шифров,
если не считать изначально ущербного и непонятного решения комитета по
стандартам США ограничить размер ключа алгоритма DES 56-ю битами,
тогда как еще во время обсуждения алгоритма предлагалось использовать
ключ большего размера. Схемы подписи, основанные на классических
блочных шифрах, свободны от указанных недостатков:
• во-первых, их стойкость к попыткам взлома вытекает из стойкости ис-
пользованного блочного шифра, поскольку классические методы шифрования
изучены гораздо больше, а их надежность обоснована намного лучше, чем
надежность асимметричных криптографических систем;
• во-вторых, даже если стойкость использованного в схеме подписи
шифра окажется недостаточной в свете прогресса вычислительной техни-
ки, его легко можно будет заменить на другой, более устойчивый, с тем же
размером блока данных и ключа, без необходимости менять основные ха-
рактеристики всей схемы – это потребует только минимальной модифика-
ции программного обеспечения.
Итак, вернемся к схеме Диффи и Хеллмана подписи одного бита со-
общения с помощью алгоритма, базирующегося на любом классическом
блочном шифре. Предположим, что есть алгоритм зашифрования Ek, опе-
рирующий блоками данных X размера п и использующий ключ размером
пк: X = n, K = nk . Структура ключевой информации в схеме следующая:
секретный ключ подписи ks выбирается как произвольная (случайная) пара
ключей k0, k1 используемого блочного шифра: 0 1 ( , ) sk = k k . Таким образом,
размер ключа подписи равен удвоенному размеру ключа использованного
блочного шифра: 2 2 s K k = K = n .
Ключ проверки представляет собой результат шифрования двух бло-
ков текста Х0 и Х1 с ключами k0 и k1 соответственно:
0 1 0 0 1 1 ( , ) ( ( ), ( )) V k k k = C C = E X E X ,
где являющиеся параметром схемы блоки данных несекретны и известны
проверяющей подпись стороне. Таким образом, размер ключа проверки
подписи равен удвоенному размеру блока использованного блочного шиф-
ра: 2 2 s K k = K = n .
Алгоритм Sig выработки цифровой подписи для бита t (t ∈ {0, 1}) за-
ключается просто в выборе соответствующей половины из пары, состав-
ляющей секретный ключ подписи: s = S(t) = kt.
Алгоритм Ver проверки подписи состоит в проверке уравнения Ekt (Xf)
= Q, которое, очевидно, должно выполняться для нашего t. Получателю
известны все используемые при этом величины.
Таким образом, функция проверки подписи будет следующей:
1, ( ) ;
( , , )
0, ( ) .
s t t
V
s t t
E X C
Ver t s k
E X C
 =
=  ≠ 
Предложенная Диффи и Хеллманом схема цифровой подписи на ос-
нове классического блочного шифра обладает такой же стойкостью, что и
лежащий в ее основе блочный шифр, и при этом весьма проста. Однако, у
нее есть два существенных недостатка.
Первый недостаток заключается в том, что данная схема позволяет
подписать лишь один бит информации. В блоке большего размера придется
отдельно подписывать каждый бит, поэтому даже с учетом хэширования
сообщения все компоненты подписи – секретный ключ, проверочная ком-
бинация и собственно подпись получаются довольно большими по размеру
и более чем на два порядка превосходят размер подписываемого блока.
Второй недостаток данной схемы менее заметен, но столь же серьезен.
Дело в том, что пара ключей выработки подписи и проверки подписи могут
быть использованы только один раз, так как выполнение процедуры подпи-
си бита сообщения приводит к раскрытию половины секретного ключа,
после чего он уже не является полностью секретным и не может быть ис-
пользован повторно. Поэтому для каждого подписываемого сообщения
необходим свой комплект ключей подписи и проверки. Это практически
исключает возможность использования рассмотренной схемы Диффи-
Хеллмана в первоначально предложенном варианте в реальных системах
ЭЦП.
Однако, несколько лет назад Березин и Дорошкевич предложили мо-
дификацию схемы Диффи-Хеллмана, фактически устраняющую ее недос-
татки.
Центральным в этом подходе является алгоритм "односторонней
криптографической прокрутки", который в некотором роде может служить
аналогом операции возведения в степень. Предположим, что имеется крип-
тографический алгоритм Ek с размером блока данных и ключа соответст-
венно п и nk бит, причем п < nk. Пусть также имеется некоторая функция
отображения n – битовых блоков данных в nk – битовые
n nK ( ), , K Y P X X n Y n → = = = . Определим рекурсивную функцию Rk "одно-
сторонней прокрутки" блока данных Т размером п бит k раз (k > 0) при по-
мощи формулы
( 1 ( )
, 0,
( ) ( ), 0 n nk k
k
P R T
T k
R T E X k → −
=  =  > 
где Х – произвольный несекретный n-битовый блок данных, являющийся
параметром процедуры прокрутки. По своей идее функция односторонней
прокрутки чрезвычайно проста, надо всего лишь нужное количество раз (K)
выполнить следующие действия: расширить n-битовый блок данных Т до
размера ключа использованного алгоритма шифрования (nk), на получен-
ном расширенном блоке как на ключе зашифровать блок данных X, резуль-
тат зашифрования занести на место исходного блока данных (T). По опре-
делению операция Rk(Т) обладает двумя важными свойствами.
1. Аддитивность и коммутативность по числу прокручиваний:
' ' ' ( ) ( ( )) ( ( )) k k k k k k R T R R T R R T + = = .
2. Односторонность или необратимость прокрутки: если известно
только некоторое значение функции Rk(T), то вычислительно невозможно
найти значение Rk’(T), для любого k' < k – если бы это было возможно, то
был бы способ определить ключ шифрования по известному входному и
выходному блоку алгоритма Еk, что противоречит предположению о стой-
кости шифра.
При реализации данного алгоритма размер ключа проверки подписи
равен удвоенному размеру блока данных использованного блочного шиф-
ра: 2 Sk = n .
Вычисление и проверка ЭЦП будут выглядеть следующим образом:
Алгоритм
nT Sig выработки цифровой подписи для nT-битового блока Т
заключается в выполнении "односторонней прокрутки" обеих половин
ключа подписи Т и 2nT −1−T раз соответственно:
( ) ( , ) ( ), ( 1). 0 1 0 2 1 S Sig T s s R k P k
nT T nT − −T
= = =
;
,
nk. nk
Алгоритм
nT Ver проверки подписи состоит в проверке истинности со-
отношений 0 0 1 1 2 1
P (s ) C , RT (S ) C nT T = =
− −
которые должны выполняться
для подлинного блока данных Т:
( ) (( ( )) ( ) ( 0 ) 0; 2 1 0 2 1 0 2 1 0 2 1
P s P R k P k P k C nT nT nT nT T T T T T
= = = =
− − − − − − + −
( ) ( ( )) ( ) ( 1) 1. 1 2 1 1 2 1 1 2 1 Р s R P k R k P k C nT nT nT Т T T T T = = = =
− − + − − −
Таким образом, функция проверки подписи будет следующей:



≠ ≠
= =
=
− −
− −
0, ( ) ( ) .
1, ( ) ( ) ;
( , , )
2 1 0 0 1 1
2 1 0 0 1 1
R s C R s C
R s C R s C
Ver T s k
T T
T T
C
nT
nT
Таким образом, рассмотренная модификация схемы Диффи-Хеллмана
делает возможным подпись не одного бита, а целой битовой группы. Это
позволяет в несколько раз уменьшить размер подписи и ключей подпи-
си/проверки данной схемы. Однако надо понимать, что увеличение размера
подписываемых битовых групп приводит к экспоненциальному росту объ-
ема необходимых вычислений и, начиная с некоторого значения, делает
работу схемы также неэффективной. Граница "разумного размера" подпи-
сываемой группы находится где-то около десяти бит, и блоки большего
размера все равно необходимо подписывать "по частям".
Размер ключа подписи и проверки подписи можно дополнительно
уменьшить следующими приемами:
1. Нет необходимости хранить ключи подписи отдельных битовых
групп, их можно динамически вырабатывать в нужный момент времени с
помощью генератора криптостойкой гаммы. Ключом подписи в этом слу-
чае будет являться обычный ключ использованного в схеме подписи блоч-
ного шифра. Например, если схема подписи будет построена на алгоритме
ГОСТ 28147–89, то размер ключа подписи будет равен 256 битам.
2. Аналогично, нет необходимости хранить массив ключей про-
верки подписи отдельных битовых групп блока, достаточно хранить его
значение хэш-функции этого массива. При этом алгоритм выработки ключа
подписи и алгоритм проверки подписи будут дополнены еще одним шагом
– вычислением хэш-функции массива проверочных комбинаций отдельных
битовых групп.
4.3. Функции хэширования
Функция хэширования (хэш-функция) Н представляет собой отобра-
жение, на вход которого подается сообщение переменной длины М, а вы-
ходом является строка фиксированной длины Н(М). В общем случае Н(М)
будет гораздо меньшим, чем М, например, Н(М) может быть 128 или 256
бит, тогда как М может быть размером в мегабайт или более.
Функция хэширования может служить для обнаружения модификации
сообщения, т.е. она может служить в качестве криптографической кон-
трольной суммы (также называемой кодом обнаружения изменений (MDC
– Manipulation Detection Code) или проверкой целостности сообщения (MIC
– Message Integrity Check)).
Теоретически возможно, что два различных сообщения могут быть
сжаты в одну и ту же свертку (так называемая ситуация "столкновения").
Поэтому для обеспечения стойкости функции хэширования необходимо
предусмотреть способ избегать столкновений. Полностью столкновений
избежать нельзя, поскольку в общем случае количество возможных сооб-
щений превышает количество возможных выходных значений функции
хэширования. Однако вероятность столкновения должна быть низкой.
Для того чтобы функция хэширования могла должным образом быть
использована в процессе аутентификации, функция хэширования Н должна
обладать следующими свойствами:
1. Н может быть применена к аргументу любого размера.
2. Выходное значение Н имеет фиксированный размер.
3. H(x) достаточно просто вычислить для любого х. Скорость
вычисления хэш-функции должна быть такой, чтобы скорость
выработки и проверки ЭЦП при использовании хэш-функции
&
&
,
была значительно больше, чем при использовании самого со-
общения.
4. Для любого у с вычислительной точки зрения невозможно
найти х такое, что H(x) = y.
5. Для любого фиксированного х с вычислительной точки зре-
ния невозможно найти х' ≠ х такое, что Н(x’) = Н(х).
Последнее свойство гарантирует отсутствие другого сообщения, даю-
щего ту же свертку, что предотвращает подделку и позволяет использовать
Н в качестве криптографической контрольной суммы для проверки целост-
ности.
Четвертое свойство эквивалентно тому, что Н является односторонней
функцией. Стойкость систем с открытыми ключами зависит от того, что
открытое криптопреобразование является односторонней функцией-
ловушкой. Напротив, функции хэширования являются односторонними
функциями, не имеющими ловушек. Классическая хэш-функция является
открытым преобразованием. В случае, когда она зависит от ключа, резуль-
тат ее вычисления носит название кода аутентификации сообщения (MAC
– Message Authentication Code).
4.3.1. ФУНКЦИЯ ХЭШИРОВАНИЯ SHA
Алгоритм безопасного хэширования SHA (Secure Hash Algorithm) при-
нят в качестве стандарта США в 1992 г. и предназначен для использования
совместно с алгоритмом цифровой подписи, определенным в стандарте
DSS. При вводе сообщения М алгоритм вырабатывает 160-битовое выход-
ное сообщение, называемое сверткой (Message Digest), которая и использу-
ется при выработке ЭЦП.
Рассмотрим работу алгоритма подробнее. Пусть исходное сообщение
дополняется так, чтобы его длина стала кратной 512 битам. При этом со-
общение дополняется даже тогда, когда его длина уже кратна указанной.
Процесс происходит следующим образом: добавляется единица, затем
столько нулей, сколько необходимо для получения сообщения, длина кото-
рого на 64 бита меньше, чем кратная 512, и затем добавляется 64-битовое
представление длины исходного сообщения.
Далее инициализируются пять 32-битовых переменных следующими
шестнадцатеричными константами:
А = 67452301 В = EFCDAB89 С = 98BADCFE D = 10325476 E = C3D2E1F0
Эти пять переменных копируются в новые переменные а, b, c, d и e
соответственно.
Главный цикл может быть описан на псевдокоде следующим образом:
for (t=0; t<80; t++){
temp = (а <<< 5)+ft(b, с, d) + e + Wt + Кt;
e = d; d = c; c = b <<<30; b = а; а = temp;
}
где <<< – операция циклического сдвига влево; Kt – 16-ричные константы,
определяемые как:
 

 


=
=
=
=
=
62 1 6, 60...79,
8 1 , 40...59;
6 9 1, 20...39;
5 827999, 0...19;
CA C D t
F BBCDC t
ED EDA t
A t
Kt
функции ft(x, у, z) задаются следующими выражениями:



∧ ∨ ∧ ∨ ∧ =
⊕ ⊕ =
∧ ∨ ¬ ∧ =
=
, 40...59,
, 20...39, 60...79;
, 0...19;
( , , )
X Y X Z Y Z t
X Y Z t
X Y X Z t
f x y z t
значения Wt получаются из 32-битовых подблоков 512-битового блока
расширенного сообщения по следующему правилу:
  
⊕ ⊕ ⊕ <<< =
=
=
( − − − − ) 1, 16...79.
, 0...19;
W 3 W 8 W 14 W 16 t
M t
W
t t t t
t
t
После окончания главного цикла значения а, b, с, d и е складываются с
содержимым А, В, С, D и Е соответственно и осуществляется переход к
обработке следующего 512-битового блока расширенного сообщения. Вы-
ходное значение хэш-функции является конкатенацией значений А, В, С, D
и Е.
4.3.2. ФУНКЦИИ ХЭШИРОВАНИЯ SHA-256, SHA-512 И SHA-384
Стойкость функции хэширования к поиску столкновений, примерно,
равна 2n/2, где п – длина выходного значения функции. В связи с разработ-
кой в США нового стандарта шифрования с длиной ключа 128, 192 и 256
бит потребовалось создать "сопровождающие" алгоритмы, обеспечиваю-
щие такой же уровень стойкости. В качестве нового стандарта США пред-
полагается принять алгоритмы вычисления функций хэширования с длиной
выходного значения 256, 384 и 512 бит.
Работа алгоритма SHA-256 может быть разбита на две части – описа-
ние функции сжатия и алгоритма обработки сообщения. Функция сжатия
представляет собой по сути алгоритм блочного шифрования с размером
блока 256 бит промежуточного значения функции хэширования с исполь-
зованием очередного текстового блока в качестве ключа. Размер слова ра-
вен 32 битам. Сложение производится по модулю 232. Стартовый вектор
хэширования H0 представляет собой набор из 8 32–разрядных слов, полу-
чаемых взятием дробной части квадратных корней первых 8 простых чи-
сел. Далее вычисление происходит по схеме подобной SHA, более подроб-
но алгоритм изложен [7]. В SHA-256 используются шесть логических функ-
ций, аргументы и значения которых – 32-битовые слова. Слова-константы
K0, ..., K63 берутся как первые 32 бита дробных частей кубических корней
первых 64 простых чисел в 16-ричном виде.
Функция SHA-512 подобна по своей структуре SHA-256, но работает с
размером слова 64 бита. Вначале текст дополняется так, чтобы его длина
была кратна 1024. Процедура дополнения аналогична: добавляется 1, затем
столько нулей, что длина текста станет на 128 меньше, нежели кратная
1024, а затем 128-битовое представление длины исходного текста. Старто-
вый вектор хэширования задается следующим образом: берутся первые 64
бита дробных частей квадратных корней первых 8 простых чисел. Далее
исходный текст разбивается на блоки по 1024 бита. Слова-константы K0, ...,
K79 берутся как первые 64 бита дробных частей кубических корней первых
80 простых чисел в 16-ричном виде.
Функция SHA-384 определяется точно так же, как и функция SHA-512
с тем исключением, что в качестве стартового вектора хэширования берут-
ся первые 64 бита квадратных корней простых чисел с девятого по шестна-
дцатое. Далее выход функции обрезается до 384 левых бит и эти биты бе-
рутся в качестве значения функции хэширования SHA-384.
4.3.3. ФУНКЦИЯ ХЭШИРОВАНИЯ ГОСТ Р 34.11–94
При описании функции хэширования будут использоваться те же обо-
значения, что использовались при описании алгоритма выработки цифро-
вой подписи согласно ГОСТ Р 34.10. Кроме того, пусть М – последователь-
ность двоичных символов, подлежащих хэшированию; h – хэш-функция,
отображающая последовательность М в слово h(M) ∈ V256(2); ЕK (А) – ре-
зультат шифрования слова А на ключе K с использованием алгоритма шиф-
рования по ГОСT 28147–89 в режиме простой замены; Н – стартовый век-
тор хэширования.
Под хэш-функцией h понимается отображение : 256 (2).
h B* →V
Для определения хэш-функции необходимы: алгоритм вычисления шаго-
вой функции хэширования κ, где κ :V256 (2)×V256 (2)→V256 (2) ; описание
итеративной процедуры вычисления значения хэш-функции h.
Алгоритм вычисления шаговой функции хэширования состоит из трех
частей: генерации четырех 256-битных ключей; шифрующего преобразова-
ния – шифрования 64-битных подслов слова Н на ключах Ki (i = 1, 2, 3, 4) с
использованием алгоритма ГОСT 28147–89 в режиме простой замены; пе-
ремешивающего преобразования результата шифрования.
Генерация ключей. Рассмотрим Х = (b256 , b255 , ..., b1)∈V256 (2).
Пусть Х = х4 х3 х2 х1 = η16 η15 ... η1 = ξ16 ξ15 ... ξ1,
где хi ∈V64(2), i =1, ..., 4; ηj ∈V16(2), j =1, ..., 16; ξk ∈V8 (2), i =1, ..., 32 .
Обозначим А(Х ) = (х1 ⊕ х2 ) х4 х3 х2.
Задается преобразование P :V256 (2)→V256 (2) слова ξ32 ... ξ1
ξϕ(32) ξϕ(31) ... ξϕ(1) , где ϕ(i +1+ 4(k −1)) = 8i + k, i = 0, ..., 3, k = 1, ..., 8.
Для генерации ключей необходимо использовать следующие исход-
ные данные:
• слова Н, М ∈ V256(2);
• константы: слова Сi (i = 2, 3, 4), имеющие значения С2 = С4 = = 0256
и С3 = 180811602411608(0818)21808(0818)4(1808)4.
При вычислении ключей реализуется следующий алгоритм:
1. Присвоить значения I = 1, U = H, V = M.
2. Выполнить вычисление W = U ⊕ V, K1= P(W).
3. Присвоить i = i + 1.
4. Проверить условие i = 5. При положительном исходе перейти к
шагу 7. При отрицательном – перейти к шагу 5.
5. Выполнить U = A(U)⊕Ci , V = A(A(V)), W =U ⊕V, Ki = P(W).
6. Перейти к шагу 3.
7. Конец работы алгоритма.
Шифрующее преобразование. На данном этапе осуществляется шиф-
рование 64-битных подслов слова Н на ключах Ki (i = 1, 2, 3, 4). Для шиф-
рующего преобразования необходимо использовать следующие исходные
данные:
H = h4 h3 h2 h1, hi ∈V64 (2), i = 1...4 и набор ключей K1 K2, K3, K4.
После выполнения шифрования получают слова si EK (hi ) i = , где I =
1, 2, 3, 4, т.е. в результате получается вектор S = s4 s3 s2 s1.
Перемешивающее преобразование. На данном этапе осуществляется
перемешивание полученной последовательности с применением регистра
сдвига.
Исходными данными являются слова Н, М ∈ V256(2) и слово S ∈
V256(2).
Пусть отображение ψ :V256 (2)→V256 (2) преобразует слово
η16 η15 ... η1 ∈V16 (2), i = 1...16 в слово
η1 ⊕η2 ⊕η3 ⊕ η4 ⊕ ⊕η13 ⊕η16 ... η2.
Тогда в качестве значения шаговой функции хэширования принимает-
ся слово κ(М, H) = ψ61(H ⊕ ψ(M ⊕ ψ12 (S))) , где ψi – i-я степень преобра-
зования ψ.
Процедура вычисления хэш-функции. Исходными данными для проце-
дуры вычисления значения функции h является подлежащая хэшированию
последовательность М ∈ В. Параметром является стартовый вектор хэши-
рования Н – произвольное фиксированное слово из V256(2).
Процедура вычисления функции h на каждой итерации использует
следующие величины: М ∈ В* – часть последовательности М, не прошед-
шая процедуры хэширования на предыдущих итерациях;
H ∈ V256(2) – текущее значение хэш-функции;
Σ ∈ V256(2) – текущее значение контрольной суммы;
L ∈ V256(2) – текущее значение длины обработанной на предыдущих
итерациях части последовательности М.
Алгоритм вычисления функции h включает в себя три этапа.
Этап 1
Присвоить начальные значения текущих величин
М := М; Н : = Н; Σ : = 0256; L := 0256.
Этап 2
Проверить условие |М| > 256. Если да, то перейти к этапу 3. В против-
ном случае выполнить последовательность вычислений:
L := <L + |M| > 256; М' : = 0256–|M| ||М; Σ : = Σ [+] М';
Н := κ(М', Н); Н := κ(L, Н); Н := κ(Σ, Н).
Конец работы алгоритма. Н содержит значение хэш-функции.
Этап 3
Вычислить подслово MS ∈ V256(2) слова М (M = MP||MS). Далее выпол-
нить последовательность вычислений:
Н := κ(МS, Н); L := <L + 256 > 256; Σ : = Σ [+] МS; M := MP.
Перейти к этапу 2.
КОНТРОЛЬНЫЕ ВОПРОСЫ
1. Изложите принципиальную схему организации обмена документа-
ми, заверенными цифровой подписью.
2. Перечислите основные требования, предъявляемые к хэш-
функции, пригодной для использования при вычислении цифровой подпи-
си документа.
3. Назовите и охарактеризуйте методы, реализующие ЭЦП.
4. Расскажите, каким образом можно организовать Стандарт цифро-
вой подписи DSS. Приведите примеры.
5. Расскажите, каким образом с помощью криптосистемы RSA можно
организовать передачу сообщений, подлинность которых подтверждена
цифровой подписью. Приведите примеры.
6. Охарактеризуйте и поясните на примерах работу стандартов циф-
ровой подписи ГОСТ Р 34.10–94 и ГОСТ Р 34.10–2001
7. Сравните наиболее распространенные стандарты ЭЦП.
5. УПРАВЛЕНИЕ КРИПТОГРАФИЧЕСКИМИ КЛЮЧАМИ
5.1. ОБЫЧНАЯ СИСТЕМА УПРАВЛЕНИЯ КЛЮЧАМИ
Помимо выбора подходящей для конкретной информационной систе-
мы средств криптографической защиты информации, важной проблемой
является управление ключами. Как бы ни была сложна и надежна сама
криптосистема, она основана на использовании ключей. Если для обеспе-
чения конфиденциального обмена информацией между двумя пользовате-
лями процесс обмена ключами тривиален, то в информационной системе,
где количество пользователей составляет сотни и тысячи, управление клю-
чами – серьезная проблема.
Под ключевой информацией понимается совокупность всех дейст-
вующих в ИС ключей. Если не обеспечено достаточно надежное управле-
ние ключевой информацией, то, завладев ею, злоумышленник получает
неограниченный доступ ко всей информации.
Управление ключами – информационный процесс, включающий в себя
три элемента: генерацию ключей; накопление ключей; распределение клю-
чей.
Не стоит использовать неслучайные ключи с целью легкости их запо-
минания. В серьезных информационных системах используются специаль-
ные аппаратные и программные методы генерации случайных ключей. Как
правило, используют датчики ПСЧ. Однако степень случайности их гене-
рации должна быть достаточно высокой. Идеальными генераторами явля-
ются устройства на основе "натуральных" случайных процессов. Например,
появились серийные образцы генерации ключей на основе белого радио-
шума. Физический датчик случайных чисел встроен в ядро процессора Pentium-
III. Другим случайным математическим объектом являются десятич-
ные знаки трансцендентных чисел, например π или е, которые вычисляют-
ся с помощью стандартных математических методов.
В ИС со средними требованиями защищенности вполне приемлемы
программные генераторы ключей, которые вычисляют ПСЧ как сложную
функцию от текущего времени и (или) числа, введенного пользователем.
Под накоплением ключей понимается организация их хранения, учета
и удаления.
Поскольку ключ является самым привлекательным для злоумышленни-
ка объектом, открывающим ему путь к конфиденциальной информации, то
секретные ключи никогда не должны записываться в явном виде на носителе,
который может быть считан или скопирован.
В достаточно сложной ИС один пользователь может работать с боль-
шим объемом ключевой информации, и иногда даже возникает необходи-
мость организации мини-баз данных по ключевой информации. Такие базы
данных отвечают за принятие, хранение, учет и удаление используемых
ключей.
Вся информация об используемых ключах должна храниться в зашиф-
рованном виде. Ключи, зашифровывающие ключевую информацию, назы-
ваются мастер-ключами. Желательно, чтобы мастер-ключи каждый пользо-
ватель знал наизусть, и не хранил их вообще на каких-либо материальных
носителях.
Очень важным условием безопасности информации является перио-
дическое обновление ключевой информации в ИС. При этом переназна-
чаться должны как обычные ключи, так и мастер-ключи. В особо ответст-
венных ИС обновление ключевой информации желательно делать еже-
дневно.
Для описания алгоритмов и методов в этой главе потребуются сле-
дующие обозначения:
IA – идентификатор стороны А;
DA – секретное криптопреобразование стороны А (с использованием
секретного ключа асимметричной криптосистемы);
ЕА – открытое криптопреобразование стороны А (с использованием
открытого ключа асимметричной криптосистемы);
TА – временной штамп стороны А;
RА – случайное число, выбранное стороной А.
Распределение ключей – самый ответственный процесс в управлении
ключами. К нему предъявляются два требования:
1. оперативность и точность распределения;
2. скрытность распределяемых ключей.
В рамках симметричной (одноключевой) системы шифрования двум
пользователям, желающим установить безопасное взаимодействие, необхо-
димо сначала установить безопасный общий ключ. Одной из возможностей
является использование третьей стороны, такой как курьера. На практике
по соображениям безопасности необходимо время от времени менять ключ.
Это может сделать использование курьера или другой подобной схемы до-
рогостоящим и неэффективным.
Альтернативой является получение двумя пользователями общего
ключа от центрального органа – центра распределения ключей (ЦРК), с
помощью которого они могут безопасно взаимодействовать. Для организа-
ции обмена данными между ЦРК и пользователем последнему при регист-
рации выделяется специальный ключ, которым шифруются сообщения,
передаваемые между ними. Поскольку каждому пользователю выделяется
отдельный ключ, его компрометация не приведет к особо неприятным по-
следствиям. Слабое место этого подхода заключается в следующем: в ЦРК,
обладающий доступом к ключам, возможно проникновение злоумышлен-
ника. Вследствие концентрации доверия одно нарушение безопасности
скомпрометирует всю систему. Кроме того, ЦРК может, например, долгое
время участвовать в пассивном подслушивании, прежде чем это будет об-
наружено, хотя доказать это может оказаться трудно.
В больших сетях эта процедура может стать узким местом, поскольку
каждой паре пользователей, нуждающейся в ключе, необходимо хотя бы
один раз обратиться к центральному узлу. Кроме того, сбой центрального
органа может разрушить систему распределения ключей. Иерархическая
(древовидная) система с пользователями, находящимися на листьях, и цен-
трами распределения ключей в промежуточных узлах является одним из
способов смягчения этой проблемы. Однако, это создает новую проблему
безопасности, поскольку создается множество точек входа для злоумыш-
ленника. Более того, данная система будет неэффективной, если пара часто
взаимодействующих пользователей не будет находиться в одном поддере-
ве, поскольку в этом случае корень дерева вновь окажется узким местом.
Некоторые из этих недостатков можно устранить, применив подход к
распределению ключей, основанный на системах с открытым ключом.
5.2. УПРАВЛЕНИЕ КЛЮЧАМИ, ОСНОВАННОЕ НА СИСТЕМАХ С
ОТКРЫТЫМ КЛЮЧОМ
До использования криптосистемы с открытым ключом для обмена
обычными секретными ключами пользователи А и В должны обменяться
своими открытыми ключами. Эта проблема проще, чем обмен секретными
ключами, поскольку открытые ключи не требуют секретности при хране-
нии и передаче. Управление открытыми ключами может быть организовано
с помощью оперативной или автономной службы каталогов, пользователи
могут также обмениваться ключами непосредственно. Однако, проблемой
здесь является аутентичность. Если А думает, что Ес в действительности
является Ев, то А может зашифровать сообщение с помощью Ес и ненаме-
ренно дать возможность С расшифровать сообщение, используя Dc. Второй
проблемой является целостность: любая ошибка в передаче открытого
ключа сделает его бесполезным. Поэтому желательно наличие какой-либо
формы обнаружения ошибок. Вне зависимости от схемы, выбранной для
распределения открытых ключей, скорее всего на каком-либо этапе будет
участвовать центральный орган. Однако, обмен открытыми ключами меж-
ду пользователями не требует участия центрального органа, поскольку ос-
новной проблемой является аутентичность. Следовательно, последствия
компрометации центрального органа будут не столь тяжелыми, как в слу-
чае обычной ключевой системы.
Еще одним аспектом проблемы является достоверность: открытый
ключ пользователя может оказаться недостоверным вследствие компроме-
тации соответствующего секретного ключа или по какой-либо иной причи-
не, например, из-за истечения срока действия, что создает проблему уста-
ревших данных, если открытые ключи хранятся или доступ к ним осущест-
вляется через каталог.
В качестве примера можно привести протокол обмена ключом Диффи-
Хеллмана. Системными параметрами этого протокола являются большое
простое число р и число g, являющееся примитивным элементом GF(p).
Пусть теперь пользователи А и В желают получить общий секретный
ключ. Сначала А генерирует случайное число а, которое он держит в секрете,
а В генерирует случайное число b, которое он также держит в секрете. Затем
они вычисляют ga mod p и gb mod p соответственно и передают вычисленные
значения друг другу, причем это можно сделать по открытым каналам связи.
После этого А вычисляет ( b mod )a mod
ab k = g p p , а В вычисляет
( a mod )b mod
ba k = g p p . Поскольку kab = kba = k, у А и В теперь есть общий
секретный ключ k.
Однако протокол Диффи-Хеллмана является уязвимым для атаки, на-
зываемой "человек в середине". Злоумышленник С может перехватить от-
крытое значение, посылаемое от А к В, и послать вместо него свое откры-
тое значение. Затем он может перехватить открытое значение, посылаемое
от В к А, и также послать вместо него свое открытое значение. Тем самым
С получит общие секретные ключи с А и В и сможет читать и/или модифи-
цировать сообщения, передаваемые от одной стороны к другой.
5.3. ПРОТОКОЛ ОБМЕНА СЕКРЕТНЫМ КЛЮЧОМ
Для защиты от атаки, рассмотренной в предыдущем параграфе, можно
использовать протокол, описанный ниже. При этом предполагается, что А и
В обладают возможностью проверить аутентичность открытых ключей
друг друга.
Предположим, что А и В желают определить общий секретный ключ
(K). При этом если они получили открытые ключи друг друга, то тогда
можно использовать трехэтапный протокол рукопожатия.
А может послать В сообщение C = EB (RA, IA ) , где ЕB – процедура
шифрования с открытым ключом В, IА – идентификатор А и RA – случайное
число. Теперь В может расшифровать С и получить IА. Теперь В выбирает
случайное число RB и посылает ' ( , ) A A B C = E R I А. После расшифрования С'
А может в реальном времени проверить, что В получил RA, поскольку толь-
ко В может расшифровать С. Наконец, А посылает В C″ = EB(KB), и когда В
расшифрует С", он сможет проверить в реальном времени, что А получил
RB, поскольку только А может расшифровать С'. Тем самым А и В аутенти-
фицировали друг друга, т.е. каждый из них знает, что они общаются имен-
но друг с другом.
Теперь А посылает В EB(DA(K)), В расшифровывает сообщение и полу-
чает К. Данная процедура обеспечивает как секретность, так и аутентич-
ность при обмене ключом K.
Рассмотренная выше процедура является вариантом так называемого
механизма "запрос-ответ", который заключается в том, что для аутентифи-
кации контрагента пользователь направляет ему некоторое непредсказуе-
мое заранее сообщение, на которое тот должен дать ответ, выполнив неко-
торую заранее обусловленную операцию над сообщением-запросом. После
получения ответа пользователь может быть уверен в подлинности сеанса
связи. Недостатком этого метода является возможность установления, хотя
и сложной, закономерности между запросом и ответом.
5.4. ИСПОЛЬЗОВАНИЕ СЕРТИФИКАТОВ
Метод достижения одновременно аутентичности и целостности при
распределении открытых ключей заключается в использовании сертифика-
тов. Система, основанная на сертификатах, предполагает, что имеется цен-
тральный орган (ЦО), как и в случае распределения секретных ключей. Да-
лее предполагается, что каждый пользователь может осуществлять безо-
пасное взаимодействие с ЦО. Для этого требуется, чтобы у каждого поль-
зователя был открытый ключ ЦО – ЕЦО. Тогда каждый пользователь А мо-
жет зарегистрировать в ЦО свой открытый ключ ЕА. Поскольку ЕД является
открытым, это можно сделать по почте, по открытому каналу электросвязи
и т.п.
Обычно при регистрации в ЦО А будет следовать определенной ау-
тентификационной процедуре. Альтернативным вариантом может быть
обработка регистрации системой, имеющей древовидную структуру: ЦО
выдает сертификаты местным представителям, которые в дальнейшем дей-
ствуют в качестве посредников в процессе регистрации пользователя на
более низких уровнях иерархии.
В любом случае, в ответ А получает сертификат, подписанный ЦО и
содержащий ЕА, т.е. ЦО формирует сообщение М, содержащее ЕА, иденти-
фикационную информацию для А (IА), период действия сертификата и т.п.
Затем ЦО вычисляет CERTА = DЦО(М), который и становится сертификатом
A. CERTA делается общедоступным документом, который содержит ЕА и
одновременно аутентифицирует его, поскольку сертификат подписан ЦО.
Сертификаты могут распространяться ЦО, пользователями или использо-
ваться в иерархической системе. Включение срока действия является
обобщением временного штампа, что обеспечивает защиту от использова-
ния скомпрометированных ключей.
Однако, проблема устаревших данных не может быть решена только с
помощью временных штампов, поскольку сертификат может стать недей-
ствительным до истечения срока его действия вследствие компрометации
или по административным причинам. Поэтому, если сертификаты хранятся
у пользователей (а не выдаются каждый раз ЦО при их использовании), ЦО
должен время от времени публиковать списки аннулированных сертифика-
тов.
Некоторые свойства рассмотренных схем могут быть объединены в
подход, известный под названием "телефонный справочник", с использова-
нием электронного эквивалента, такого как гибкий диск, содержащий сер-
тификаты. Это облегчит использование, поскольку пользователь сможет
быстро связаться с другим, очень быстро получая доступ к сертификату
последнего.
5.5. ПРОТОКОЛЫ АУТЕНТИФИКАЦИИ
Предположим, что А желает установить связь с В, получил сертифика-
ционный путь от А до В, например обратившись к каталогу, и использовал
этот путь для получения открытого ключа В.
Пусть IА – идентификатор стороны А; DA – секретное криптопреобразо-
вание стороны А (секретный ключ); ЕА – открытое криптопреобразование сто-
роны А (открытый ключ); TА – временной штамп стороны А; RА – случайное
число, выбранное стороной А; СА – сертификат стороны.
IB – идентификатор стороны В; DB – секретное криптопреобразование
стороны В (секретный ключ); EB – открытое криптопреобразование сторо-
ны В (открытый ключ); TB – временной штамп стороны В; RB – случайное
число, выбранное стороной В.
Идентификаторы – это уникальные имена А и В. Временной штамп,
включаемый в сообщение М, содержит также дату истечения срока дейст-
вия М. Дополнительно он также может включать время создания М. Слу-
чайные числа могут быть заменены последовательными числами, которые
не должны повторяться в течение срока действия, указанного во временном
штампе в том же сеансе связи.
Тогда односторонний протокол аутентификации будет выглядеть сле-
дующим образом:
Пользователь А:
1. Выбирает RA.
2. Формирует сообщение М = (ТА, RA, IB, 〈данные〉), где 〈данные〉
произвольны. Данные могут быть зашифрованы с помощью EB для секретно-
сти, например, когда А передает В ключ шифрования данных.
3. Посылает (СА, DA(M)) пользователю В.
Пользователь В:
1. Расшифровывает СА и получает ЕА. Проверяет дату окончания
срока действия сертификата;
2. Использует ЕА для расшифрования DA(M), проверяя как подлин-
ность подписи А, так и целостность подписанной информации.
3. Проверяет IB, содержащееся в М, на точность.
4. Проверяет ТА в М.
5. Дополнительно проверяет RA, содержащееся в М.
Широкое распространение основанных на интеллектуальных картах
систем доступа для различного рода приложений (как гражданского, так и
военного назначения) потребовало создать схему обеспечения безопасной
аутентификации субъекта. При этом секретный ключ владельца карты ста-
новится неотъемлемым признаком его личности, и для обеспечения защиты
от возможной компрометации этого ключа был предложен ряд схем, назы-
ваемых протоколами доказательства с нулевым разглашением или с нуле-
вым знанием (zero-knowledge proofs), подтверждающий полномочия субъ-
екта, не раскрывая значения секретного ключа.
Первая схема подобного рода предложена в 1986 г. Фейге, Фиатом и
Шамиром. Суть ее состоит в следующем.
Для группы пользователей, которым придется доказывать свою под-
линность, выбирается большое (длиной более 512 бит) случайное целое
число п, являющееся произведением двух простых чисел. В процессе ау-
тентификации участвуют две стороны: сторона А, доказывающая свою
подлинность, и сторона В – проверяющий.
Доверенный арбитр (центр распределения ключей) выбирает некото-
рое целое число v, являющееся квадратичным вычетом по модулю п, т.е.
∃x : x2 = v(mod n) , и взаимно простым с п. Это значение v передается А в
качестве открытого ключа. Затем вычисляется наименьшее значение s, та-
кое что s = (v−1)1/ 2 (mod n) . Это значение будет секретным ключом сторо-
ны А.
Далее протокол аутентификации выглядит следующим образом:
1. Сторона А выбирает случайное число r, 0 < r < п. Затем она вычис-
ляет х = r2 mod п и отправляет его стороне В.
2. Сторона В посылает А случайный бит b.
3. Если b = 0, то А отправляет В число r. Если b = 1, то А отправляет
В: у = rs (mod n).
4. Если b = 0, то В проверяет, что х = r2 (mod n), чтобы убедиться, что
А знает квадратный корень из х. Если b = 1, то сторона В проверяет, что х =
y2v(mod n), чтобы убедиться, что А знает квадратный корень из v–1.
Шаги 1 – 4 образуют один цикл протокола. Стороны повторяют этот
цикл t раз при разных случайных значениях r и b. Если сторона А не знает
значения s, она может выбрать такое r, которое позволит ей обмануть В в
случае b = 0 или b = 1, но не в обоих случаях одновременно. Вероятность
обмана в одном цикле составляет 0,5. Вероятность обмана в t циклах равна
2–t.
Недостатком данной схемы является большое число циклов протоко-
ла, необходимое для доказательства с требуемой вероятностью, если эта
вероятность достаточно мала. Способ, требующий только одного раунда
обмена, но требующий большего объема вычислений, был предложен Гил-
лоу и Кискатером (Guillou, Quisquater).
Пусть I – идентификационная информация стороны А (или значение ее
хэш-функции); п – открытое произведение двух секретных простых чисел;
v – открытое значение (показатель степени).
Секретный ключ g стороны А выбирается так, что Igv =1(mod n) .
Сторона А отправляет В свои идентификационные данные I. Протокол
доказательства выглядит следующим образом.
1. А выбирает случайное целое r (1 < r < п – 1), вычисляет Т = rv (mod
n) и отправляет это значение стороне В.
2. В выбирает случайное целое d (1 < d < n – 1) и отправляет это чис-
ло стороне А.
3. А вычисляет D = rgd (mod n) и отправляет это значение В.
4. В вычисляет Т' =DvId (mod n) и проверяет выполнение равенства Т'
= Т. Если оно выполняется, то проверка считается завершенной успешно.
5.6. АНОНИМНОЕ РАСПРЕДЕЛЕНИЕ КЛЮЧЕЙ
Если мы полагаем, что пользователи сами не могут выбирать собст-
венные ключи, то они должны пользоваться услугами центра распределе-
ния ключей. Проблема заключается в том, что ключи должны распреде-
ляться так, чтобы никто не мог определить, кто получил какой ключ. Про-
цедура распределения ключей в этом случае может выглядеть так:
1. А выбирает пару 〈открытый ключ, секретный ключ〉 (для этого
протокола он держит оба ключа в секрете).
2. ЦРК генерирует непрерывный поток ключей.
3. ЦРК шифрует ключи, один за одним, своим открытым ключом.
4. ЦРК передает зашифрованные ключи, один за одним, в сеть.
5. А выбирает ключ случайным образом.
6. А шифрует выбранный ключ своим открытым ключом.
7. А ожидает некоторое время и посылает дважды зашифрованный
ключ обратно в ЦРК.
8. ЦРК расшифровывает дважды зашифрованный ключ своим сек-
ретным ключом, оставляя ключ зашифрованным один раз открытым клю-
чом А.
9. ЦРК посылает зашифрованный ключ назад пользователю А.
10. А расшифровывает ключ своим секретным ключом.
Контрольные вопросы
1. Перечислите основные понятия, связанные с управлением ключе-
вой информацией.
2. Поясните работу обычной системы управления ключами.
3. Расскажите, каким образом осуществляется управление ключами,
основанное на системах с открытым ключом. Охарактеризуйте протокол
обмена секретным ключом.
4. Укажите преимущества систем использующих сертификаты безо-
пасности.
5. Поясните работу протоколов аутентификации.

6. АППАРАТНО-ПРОГРАММНЫЕ СРЕДСТВА КРИПТОГРА-
ФИЧЕСКОЙ ЗАЩИТЫ ИНФОРМАЦИИ
В соответствии с законодательством Российской Федерации в области
защиты информации государственным организациям и предприятиям
предписывается использовать криптографические средства защиты инфор-
мации, сертифицированные ФСБ России (до марта 2003 г. сертифицикация
криптографических средств возлагалась на Федеральное агентство прави-
тельственной связи и информации (ФАПСИ) при Президенте РФ). В на-
стоящее время на рынке средств защиты информации России активно рабо-
тают фирмы "АНКАД", "Информзащита", "ВАЛИДАТА", ФГУП "НТЦ
"Атлас", Пензенский научно-исследовательский электротехнический ин-
ститут (ПНИЭИ), ЗАО "Московское отделение (МО) ПНИЭИ" и др. Спектр
выпускаемой продукции широк. Это аппаратные, аппаратно-программные
средства защиты документальной и речевой информации, комплексы для
реализации PKI (инфраструктуры открытых ключей), средства защиты
электронной почты и пр. Ниже приведены краткие характеристики крипто-
графических средств защиты информации, которые нашли широкое приме-
нение в государственных предприятиях, правоохранительных органах и
финансово-кредитных организациях.
6.1. УСТРОЙСТВА КРИПТОГРАФИЧЕСКОЙ ЗАЩИТЫ ДАННЫХ
СЕРИИ "КРИПТОН"
Устройства криптографической защиты данных (УКЗД) серии "КРИП-
ТОН" – это аппаратные шифраторы для IBM PC-совместимых компьюте-
ров (рис. 6.1) применяются в составе средств и систем криптографической
защиты данных и используются в государственных и коммерческих струк-
турах.
Рис. 6.1. Внешний вид устройства "КРИПТОН"
Устройства "КРИПТОН" гарантируют защиту информации, обрабаты-
ваемой на персональном компьютере и передаваемой по открытым каналам
связи, выполнены в виде плат расширения ISA и PCI персонального ком-
пьютера с процессором 1386 и выше.
Устройства "КРИПТОН" разработаны, производятся и реализуются фир-
мой "АНКАД". Они построены на разработанных этой фирмой специализиро-
ванных 32-разрядных шифр процессорах. Устройства серии КРИПТОН серти-
фицированы ФАПСИ и ФСБ (в том числе в составе абонентских пунктов и
автоматизированных рабочих мест для защиты информации, содержащей све-
дения, составляющие государственную тайну).
Преимущества устройств серии "КРИПТОН":
• аппаратная реализация алгоритма криптографического преобразо-
вания гарантирует целостность алгоритма;
• шифрование производится и ключи шифрования хранятся в самой
плате, а не в оперативной памяти компьютера;
• загрузка ключей шифрования в устройство "КРИПТОН" со смарт-
карт и идентификаторов Touch Memory производится напрямую, минуя
ОЗУ и системную шину компьютера, что исключает возможность перехва-
та ключей;
• применение специализированного шифрпроцессора для выполне-
ния криптографических преобразований разгружает центральный процес-
сор компьютера.
Для устройств "КРИПТОН" разработано специальное программное
обеспечение, которое позволяет:
• шифровать компьютерную информацию (файлы, группы файлов и
разделы дисков), обеспечивая их конфиденциальность;
• осуществлять электронную цифровую подпись файлов, проверяя
их целостность и авторство;
• создавать прозрачно шифруемые логические диски, максимально
облегчая и упрощая работу пользователя с конфиденциальной информаци-
ей;
• формировать криптографически защищенные виртуальные сети,
шифровать IP-трафик;
• создавать системы защиты информации от несанкционированного
доступа и разграничения доступа к компьютеру.
Основные технические данные и характеристики
Алгоритм шифрования ......................................... ГОСТ 28147–89
Размерность ключа шифрования, бит ................. 256
Поддерживаемые операционные системы ......... MS-DOS,
Windows 95(98)/ME/NT
4.0/2000/XP/2003 UNIX
Фирма "АНКАД" выпускает следующие модели УКЗД: КРИПТОН-4,
КРИПТОН-4/PCI, КРИПТОН-8/PCI, КРИПТОН-9/PCI, КРИПТОН-ЗАМОК
и др. Модели отличаются скоростью шифрования и сервисными возможно-
стями.
КРИПТОН-4/PCI, КРИПТОН-8/PCI – устройства криптографической
защиты данных и ограничения доступа к компьютеру.
Шина ...................................................... PCI
Реализация алгоритма шифрования .... аппаратная
Скорость шифрования, Кбайт/с ……... до 1100 (КРИПТОН-4/PCI)
до 8500 (КРИПТОН-8/PCI)
Носители ключей …….......................... дискеты, смарт-карты с
открытой и защищенной
памятью, микропроцессорные
смарт-карты, носители
Touch-Memory
Программы шифрования и ЭЦП серии КРИПТОН/Crypton
Программные средства криптографической защиты информации се-
рии КРИПТОН/Crypton осуществляют функции шифрования, ЭЦП и ком-
плексной защиты информации, призваны обеспечить безопасность различ-
ной конфиденциальной информации – коммерческой, банковской, страхо-
вой, налоговой тайны, персональных данных и т.п.
Программные продукты серии КРИПТОН/Crypton работают автоном-
но или на базе шифраторов КРИПТОН посредством оригинальной библио-
теки Crypton API, которая обеспечивает совместимость шифраторов с лю-
бым программным обеспечением фирмы "АНКАД". Кроме того, фирмой
"АНКАД" разработан программный продукт Crypton Emulator, который
эмулирует функции шифрования устройств криптографической защиты
данных (УКЗД) серии "КРИПТОН", т.е. возможна практически полноцен-
ная замена УКЗД продуктом Crypton Emulator с использованием про-
граммного интерфейса Crypton API. В программном обеспечении Crypton
Emulator реализован алгоритм шифрования ГОСТ 28147–89.
"АНКАД" предлагает следующие комплексные программные продук-
ты:
• КРИПТОН-Шифрование для Windows 95/98/ME/NT
4.0/2000/XP/2003 – архивное и абонентское шифрование.
• КРИПТОН-Подпись для Windows 95/98/ME/NT 4.0/2000/XP/2003 –
электронная цифровая подпись, открытый ключ 512 и 1024 бит.
• CryptonArcMail для Windows 95/98/ME/2000/NT 4.0/XP/2003 – серия
программных продуктов предназначенных для защиты от несанкциониро-
ванного доступа к документам-файлам, передаваемым по электронной поч-
те в локальных и глобальных сетях, единый сервис архивирования, архив-
ного и абонентского шифрования и ЭЦП. Симметричная и ассиметричная
ключевые системы, открытый ключ 512 и 1024 бит.
• CryptonDisk для Windows 95/98/ME/2000/NT 4.0/XP/2003 – прозрач-
ное шифрование логических дисков – создает с помощью устройства
"КРИПТОН" или Crypton Emulator виртуальный логический диск, шиф-
руемый в автоматическом режиме.
• Crypton LITE для Windows 95/98/ME/2000/NT 4.0/XP/2003 – шифро-
вание, ЭЦП с открытым ключом 512 и 1024 бит. Включает в себя: Crypton
API., Crypton Emulator, КРИПТОН-Подпись и КРИПТОН-Шифрование.
• Crypton Wipe для Windows-95/98/ME/NT 4.0/2000/XP/2003 – гаран-
тированное уничтожение информации. Для усложнения восстановления
удаляемой информации файлы предварительно шифруются.
6.2. СРЕДСТВА КРИПТОГРАФИЧЕСКОЙ ЗАЩИТЫ ИНФОРМА-
ЦИИ "ВЕРБА-О", "ВЕРБА-ОW"
Средства криптографической защиты информации (СКЗИ) "Верба-О"
(для OC MS DOS), "Верба-OW" (для ОС Windows) разработаны ЗАО "Мос-
ковское отделение Пензенского научно-исследовательского электротехни-
ческого института" (МО ПНИЭИ) и решают следующие задачи:
• шифрование/расшифрование информации на уровне файлов;
• генерация электронной цифровой подписи (ЭЦП);
• проверка ЭЦП; обнаружение искажений, вносимых злоумышленни-
ками или вирусами в защищаемую информацию.
СКЗИ серии "Верба" поставляются в виде автономного рабочего места
или модулей, встраиваемых в программное обеспечение заказчика.
Программные продукты и аппаратно-программные средства "Верба"
можно классифицировать следующим образом:
• библиотечные модули, предназначенных для вызова криптографиче-
ских функций непосредственно из приложения, осуществляющего обра-
ботку конфиденциальной информации, обеспечивают шифрование и ЭЦП
(программный модуль "VCrypt");
• средства криптографической защиты данных пользователя, предна-
значенные для электронной подписи и шифрования данных пользователей
на рабочих местах с возможностью последующего хранения и передачи по
каналам связи ("Файловый криптоменеджер");
Рис. 6.2. Схема организации виртуальной частной сети c АПК "ШИП" (ЦУКС
– Центр управления ключевой системой)
• средства криптографической защиты клиент-серверных технологий,
предназначенные для использования в системах типа "клиент-сервер", та-
ких как – доступ к базам данных, системы Банк-Клиент и т.п., и имеющие в
своей основе принцип раздельного функционирования систем обработки
запросов и систем криптографической защиты информации ("Криптогра-
фический сервер");
• средства криптографической защиты каналов связи, предназначенные
для защиты информации в каналах связи в режиме on-line по протоколам IP,
X.25, Fray Relay и т.д.
• защищенные почтовые технологии, предназначенные как для организа-
ции собственных защищенных почтовых систем на базе Х.400, так и для орга-
низации защищенного документооборота через Internet приложения. Примене-
ние шифрования и электронной цифровой подписи самого письма и его вло-
жения позволяет обеспечить конфиденциальность, целостность и авторство
передаваемых сообщений (Средства защиты электронной почты "Дионис").
Применение этих средств позволяет создавать виртуальные частные сети
(VPN) и обеспечивать конфиденциальность передаваемых между ними дан-
ных, защищенный выход в Internet, и защищенный on-line доступ в частную
сеть удаленных (мобильных) пользователей (Аппаратно-программный ком-
плекс "Шип"). Типовая схема организации виртуальной частной сети c АПК
"ШИП" приведена на рис. 6.2.
6.3. ПРОГРАММНЫЙ КОМПЛЕКС VCERT PKI
Программный продукт VCERT PKI является результатом совместной
работы компаний ЗАО "МО ПНИЭИ" и ООО "ВАЛИДАТА". Система
управления сертификатами VCERT PKI – это многокомпонентная система,
использующая инфраструктуру открытых ключей для обеспечения конфи-
денциальности информации, контроля целостности и подтверждения автор-
ства электронных документов на основе использования криптографических
процедур, реализованных в соответствии с российскими стандартами и ме-
ждународными рекомендациями.
VCERT PKI условно можно разделить на два компонента: систему
управления сертификатами – инфраструктуру открытых ключей (PKI) и
программный интерфейс к криптографическим функциям для РКI-
приложений.
Система VCERT PKI обеспечивает защиту информации на основе реа-
лизации инфраструктуры открытых ключей с использованием международ-
ного стандарта Х.509, реализована на платформах Windows NT, Windows
95/98.
Программное обеспечение VCERT PKI реализовано по модульному
принципу, в его состав входят следующие основные программные комплек-
сы и модули:
6.3.1. VСА (VCERT Certification Authority) – программный комплекс
Центр Сертификации (ЦС), предназначенный для создания на основе ин-
формации, предоставляемой Центром Регистрации, сертификатов открытых
ключей, списков аннулированных сертификатов и их бумажных копий, а
также хранения эталонной базы сертификатов и списков аннулированных
сертификатов.
6.3.2. VRA (VCERT Registration Authority) – программный комплекс
Центр Регистрации (ЦР), предназначенный для регистрации пользователей
и обеспечения взаимодействия пользователя с Центром Сертификации.
6.3.3. VCS (VCERT Certificates Store) – программный комплекс Спра-
вочник Сертификатов, обеспечивающий администрирование справочника
сертификатов, формирование служебных сообщений на рабочем месте
пользователя, а также генерацию секретных и открытых ключей на рабочем
месте пользователя и запись их на ключевые носители.
6.3.4. VCrypt – программный модуль реализации криптографических
функций и генерации ключевой информации (из состава СКЗИ "Верба-
OW").
Цифровая подпись соответствует требованиям ГОСТ Р 34.10–94 "Ин-
формационная технология. Криптографическая защита информации. Систе-
ма электронной цифровой подписи на базе асимметричного криптографи-
ческого алгоритма". Функция хэширования выполнена в соответствии с
требованиями ГОСТ Р 34.11–94 "Информационная технология. Крипто-
графическая защита информации. Функция хэширования", а алгоритм
шифрования реализован в соответствии с требованиями ГОСТ 28147–89
"Системы обработки информации. Защита криптографическая".
Длины секретного и открытого ключей электронной цифровой подписи
составляют соответственно 256 бит и 512 бит (или 1024 бита), такие же
длины имеют секретный и открытый ключи шифрования. Секретные ключи
подписи могут храниться на ключевых носителях – дискетах 3.5", носите-
лях Touch-Memory или смарт-картах.
Система VCERT PKI обеспечивает:
• генерацию и верификацию электронных цифровых подписей под
файлом или областью памяти в соответствии с ГОСТ Р34.10–94 и ГОСТ
Р34.11–94;
• конфиденциальность и контроль целостности информации посредст-
вом ее шифрования и имитозащиты в соответствии с ГОСТ 28147–89;
• регистрацию электронных запросов пользователей на сертификаты
открытых ключей подписи;
• формирование электронных сертификатов открытых ключей подпи-
си пользователей.
Клиентское программное обеспечение VCERT PKI позволяет пользо-
вателям на своих рабочих местах формировать запросы на сертификаты
открытых ключей, генерировать секретные и открытые ключи подписи и
шифрования, а также получать сообщения о компрометации секретных
ключей и информацию из справочника сертификатов.
Инструментарий разработчика дает возможность встраивать в при-
кладное программное обеспечение криптографические функции генера-
ции/верификации цифровой подписи, шифрования/ расшифрования инфор-
мации.
6.4. СРЕДСТВО КРИПТОГРАФИЧЕСКОЙ ЗАЩИТЫ ИНФОРМА-
ЦИИ КРИПТОПРО CSP
Средство криптографической защиты информации КриптоПро CSP,
разработанное совместно компанией "Крипто-Про" и ФГУП "НТЦ "Атлас",
реализовано в соответствии с криптографическим интерфейсом корпора-
ции Microsoft – CSP (Cryptographic Service Provider) и российскими крип-
тографическими алгоритмами электронной цифровой подписи (ГОСТ
Р34.10–94), хэширования (ГОСТ Р34.11–94) и шифрования и имитозащиты
данных (ГОСТ 28147–89).
Программный комплекс Удостоверяющий центр – КриптоПро УЦ по-
зволяет в полном объеме реализовать инфраструктуру открытых ключей.
В состав КриптоПро УЦ входят следующие компоненты (рис. 6.3): Центр
сертификации (ЦС), Центр регистрации (ЦР), АРМ администратора ЦР,
АРМ пользователя, программный интерфейс взаимодействия с УЦ.
Центр сертификации – базовый компонент системы, предназначенный
для формирования сертификатов открытых ключей пользователей и админи-
страторов Удостоверяющего центра, хранения эталонной
Рис. 6.3. Структура средства криптографической защиты информации Крип-
тоПро CSР
базы сертификатов и списков аннулированных сертификатов. Центр серти-
фикации реализован на платформе Microsoft Windows 2000 Server и взаи-
модействует только с Центром регистрации на базе защищенного сетевого
протокола.
Центр регистрации также работает на платформе Microsoft Windows
2000 Server и использует базу данных Microsoft SQL 2000. Взаимодействие
пользователей с Удостоверяющим центром осуществляется через АРМ
пользователя. ЦР является единственной точкой входа (регистрации) поль-
зователей в системе. Только зарегистрированный пользователь может по-
лучить сертификат открытого ключа в Удостоверяющем центре.
Компонент АРМ Администратора ЦР предназначен для выполнения
организационно-технических мероприятий, связанных с регистрацией
пользователей, генерацией ключей и сертификатов пользователей и взаимо-
действием с Центром регистрации. АРМ администратора ЦР функциониру-
ет в ОС Microsoft Windows 2000 Professional. АРМ администратора взаимо-
действует с Центром регистрации в отдельном сегменте локальной сети на
базе защищенного сетевого протокола.
АРМ администратора ЦР обеспечивает проверку состояния и обра-
ботку запросов пользователей на регистрацию, выдачу и аннулирование
сертификатов открытых ключей, просмотр протоколов работы ЦР и поиск
информации в базе данных ЦР, относящейся к зарегистрированным
пользователям.
АРМ пользователя – это web-приложение, размещенное на сервере ЦР.
АРМ пользователя функционирует в ОС Microsoft Windows 95 и выше
(браузер – MS IE 5.0 и выше). АРМ пользователя обеспечивает шифрова-
ние информации, передаваемой ЦР с использованием протокола TLS
(протокол TLS обеспечивает конфиденциальность и целостность данных при
коммутации двух приложений и позволяет приложениям "клиент-сервер"
взаимодействовать защищенным способом, предотвращающим перехват
информации и подделку сообщений).
К основным функциям АРМ пользователя относятся:
• обеспечение взаимодействия пользователя с ЦР;
• заполнение форм запросов на сертификаты;
• выбор типа сертификата;
• проверка состояния запросов на сертификаты и статусасертифи-
катов;
• генерация секретных ключей;
• получение сертификатов.
Программный интерфейс пользователя предназначен для просмотра
персональной информации из базы данных ЦР, списка сертификатов, полу-
ченных пользователем, и запросов на сертификаты для загрузки, получения
и аннулирования сертификатов.
Интеграция российских средств криптографической защиты информа-
ции со средствами операционной системы и приложениями, использование
инфраструктуры открытых ключей позволяет пользователям и разработчи-
кам обеспечить конфиденциальность, авторство и целостность информации.
Применяя средство криптографической защиты информации КриптоПро
CSP, пользователи операционной системы MS Windows могут воспользо-
ваться стандартными программными средствами корпорации Microsoft для
реализации решений, основанных на инфраструктуре открытых ключей.
6.5. ТЕЛЕФОННЫЙ СКРЕМБЛЕР "ГРОТ"
Телефонный скремблер "Грот" (рис. 6.4) предназначен для защиты
конфиденциальной информации. Он обеспечивает шифрования речевого
сигнала и защиту факсимильных сообщений, передаваемых по телефонной
сети общего применения.
Характеристика работы в канале связи и пользовательские свойства:
• напряжение постоянного тока в абонентской линии: 30…60 В;
• высокая помехоустойчивость;
• автоматическая адаптация к телефонному аппарату абонента, або-
нентской линии, нелинейности трактов АТС;
• устойчивость работы в реальных телефонных каналах России и
стран СНГ, включая междугородные и международные с радиорелейными
вставками и любыми видами уплотнения;
• совместимость с любым типом телефонного и факсимильного ап-
парата, с мини-АТС любого типа, имеющей аналоговый выход;
• работа в линиях, оборудованных системами уплотнения и исполь-
зуемых для охранной сигнализации;
• высокая степень эхокомпенсации;
• низкий уровень шумов в телефонной трубке;
• высокое качество восстановленной речи;
• энергонезависимая память индивидуальных ключей-
идентификаторов;
• упрощенный алгоритм ввода индивидуальных ключей-
идентификаторов за счет использования электронного блокнота индивиду-
альных ключей;
Рис. 6.4. Внешний вид скремблера "Грот"
Шифрование:
• метод шифрования – мозаичный: частотные и временные переста-
новки;
• метод открытого распределения ключей, позволяющий работать
без ручного набора ключей;
• общее количество ключевых комбинаций 2 × 1018;
• возможность введения дополнительного семизначного ключа для
идентификации абонента;
• высокая степень криптографической защиты за счет наличия до-
полнительных мастер-ключей, которые устанавливаются по желанию За-
казчика.
6.6. АППАРАТУРА КРИПТОГРАФИЧЕСКОЙ ЗАЩИТЫ ИНФОР-
МАЦИИ Е-20
Аппаратура криптографической защиты речевой и документальной
информации с гарантированной Е-20 стойкостью (рис. 6.5) обеспечивает:
• режим телефонного аппарата общего пользования;
• режим криптографической защиты речи;
• режим передачи и криптографической защиты данных с встроен-
ным устройством имитозащиты.
Рис. 6.5. Внешний вид аппаратуры Е-20
Работа в закрытом режиме осуществляется при установленном ключе-
вом носителе Data Key.
Аппаратура Е-20 обеспечивает встречную работу с аппаратурой "М-
459-1С" по предварительно коммутированным телефонным каналам обще-
го пользования на скоростях 2400, 4800, 9600 бит/с при использовании мо-
демов "УПС-1Ф". Схема возможного соединения абонентов показана на
рис. 6.6.
Рис. 6.6. Схема возможного соединения абонентов
Аппаратура "М459-1С" предназначена для криптографической защиты
конфиденциальной и секретной телефонной и документальной информа-
ции и обеспечивает:
• работу по выделенным и предварительно коммутированным каналам
связи совместно с модемом УПС-ТФ в дуплексном режиме на скоростях
2400, 4800, 9600 бит/с;
• работу по предварительно коммутированным телефонным каналам
общего пользования для встречной работы с аппаратурой "Е-20";
• передачу/прием документальной информации от ПЭВМ через аппа-
ратуру "Адаптер-ДС".
Внешний вид аппаратуры "М459-1С" показан на рис. 6.7.
Рис. 6.7. Внешний вид аппаратуры "М459-1С"
Контрольные вопросы
1. Каковы назначения и основные характеристики устройства защиты
данных серии КРИПТОН?
2. Каковы назначения и основные характеристики устройства защиты
данных серии "Верба"?
3. Каковы назначения и основные характеристики программного ком-
плекса VCERT PKI?
4. Каковы назначение и основные характеристики средства крипто-
графической защиты информации КриптоПро CSP?
5. Опишите особенности защиты информации скремблером "Грот"?
6. Опишите назначение и способ применения аппаратуры криптогра-
фической защиты информации Е-20?
7. Опишите назначение и способ применения аппаратуры криптогра-
фической защиты информации "М459-1С"?
Ведомственная сеть
спецсвязь
􀀝 􀀝
ПЭВМ
ПЭВМ
℡
ТА
E-20
E-20
E-20 E-20
Сеть
ТфОП
􀂈
􀀞 УПС-ТФ
"М459-1С"
ЗАКЛЮЧЕНИЕ
Выбор методов криптографической защиты информации для конкрет-
ных информационных систем должен быть основан на глубоком анализе
слабых и сильных сторон тех или иных методов защиты. Обоснованный
выбор той или иной системы защиты должен опираться на какие-то крите-
рии эффективности. К сожалению, до сих пор не разработаны подходящие
методики оценки эффективности криптографических систем.
Наиболее простой критерий такой эффективности – вероятность рас-
крытия ключа или мощность множества ключей. По сути это то же самое,
что и криптостойкость. Для ее численной оценки можно использовать так-
же и сложность раскрытия шифра путем перебора всех ключей.
Однако, этот критерий не учитывает других важных требований к
криптосистемам:
− невозможность раскрытия или осмысленной модификации инфор-
мации на основе анализа ее структуры,
− совершенство используемых протоколов защиты,
− минимальный объем используемой ключевой информации,
− минимальная сложность реализации (в количестве машинных опе-
раций), ее стоимость,
− высокая оперативность.
Желательно использование некоторых интегральных показателей,
учитывающих указанные факторы.
Для учета стоимости, трудоемкости и объема ключевой информации
можно использовать удельные показатели – отношение указанных пара-
метров к мощности множества ключей шифра.
Часто более эффективным при выборе и оценке криптографической
системы является использование экспертных оценок и имитационное моде-
лирование.
В любом случае выбранный комплекс криптографических методов
должен сочетать как удобство, гибкость и оперативность использования,
так и надежную защиту от злоумышленников информации, циркулирую-
щей в информационной системе.
СПИСОК ЛИТЕРАТУРЫ
1. Баричев, С.Г. Основы современной криптографии / С.Г. Баричев,
В.В. Гончаров, Р.Е. Серов. – М. : Горячая линия – Телеком, 2001. – 120 с.
2. ГОСТ 28147–89. Системы обработки информации. Защита крип-
тографическая. Алгоритм криптографического преобразования информа-
ции. – М. : Госкомитет СССР по стандартам, 1989.
3. ГОСТ Р 34.10–2001. Информационная технология. Криптографи-
ческая защита информации. Процессы формирования и проверки элек-
тронно-цифровой подписи. – М. : Госстандарт России, 2001.
4. ГОСТ Р 34.10–94. Информационная технология. Криптографиче-
ская защита информации. Процедуры выработки и проверки электронной
цифровой подписи на базе асимметричного криптографического алгоритма. –
М. : Госстандарт России, 1994.
5. ГОСТ Р 34.11–94. Информационная технология. Криптографиче-
ская защита информации. Функция хэширования. – М. : Госстандарт Рос-
сии, 1994.
6. ГОСТ Р 51583. Защита информации. Порядок создания автомати-
зированных систем в защищенном исполнении. – М. : Госстандарт России,
1994.
7. Гостехкомиссия России – точка зрения на техническую защиту
информации. // JetInfo. 1999. – № 11. – С. 2 – 12 (www.jetinfo.ru).
8. Грушо, А.А. Теоретические основы защиты информации / А.А.
Грушо, Е.Е. Тимонина. – М. : Изд-во Агенства "Яхтсмен", 1996. – 192 с.
9. Программно-аппаратные средства обеспечения информационной
безопасности. Теоретические основы компьютерной безопасности : учеб-
ное пособие для вузов / П.Н. Девянин, О.О. Михальский, Д.И. Правиков, А.Ю.
Щербаков. – М. : Радио и связь, 2000. – 192 с.
10. Жельников, В.Г. Криптография от папируса до компьютера / В.Г.
Жельников. – M. : ABF, 1996. – 336 с.
11. Завгородний, В.И. Комплексная защита информации в компью-
терных системах : учебное пособие для вузов / В.И. Завгородний. – М. : Ло-
гос, 2001. – 264 с.
12. Зегжда, Д.П. Основы безопасности информационных систем /
Д.П. Зегжда, А.М. Ивашко. – М. : Горячая Линия – Телеком, 2000. – 452 с.
13. Малюк, А.А. Введение в защиту информации в автоматизирован-
ных системах / А.А. Малюк, С.В. Пазизин, Н.С. Погожин. – М. : Горячая
Линия – Телеком, 2001. – 148 с.
14. Молдовян, А.А. Криптография / А.А. Молдовян, Н.А. Молдо-
вян, Б.Я. Советов. – СПб. : Лань, 2000.
15. Нечаев, В.И. Элементы криптографии (Основы теории защиты
информации) : учебное пособие / В.И. Нечаев ; под ред. В.А. Садовничего.
– М. : Высшая школа, 1999. – 109 с.
16. Обзор криптотехнологий. // JetInfo. – 2001. – № 3. – 16 с.
(www.jetinfo.ru).
17. Руководящий документ. Временное положение по организации
разработки, изготовления и эксплуатации программных и технических
средств защиты информации от несанкционированного доступа информа-
ции в автоматизированных системах и средствах вычислительной техники
// Сборник руководящих документов по защите информации от несанкцио-
нированного доступа. – М. : ГТК при президенте РФ, 1998. – 120 с.
18. Руководящий документ. Защита от несанкционированного досту-
па к информации. Термины и определения // Сборник руководящих доку-
ментов по защите информации от несанкционированного доступа. – М. :
ГТК при президенте РФ, 1998. – 120 с.
19. Саломаа, А. Криптография с открытым ключом / А. Саломаа ;
пер. с англ. – М. : Мир, 1995. – 318 с.
20. Мао, В. Современная криптография: теория и практика / В. Мао. –
СПб. : Вильямс, 2005.
Рис. 1.1. Классификация методов криптографического закрытия информации
Криптографическое закрытие информации
Шифрование Кодирование Другие виды
Вид преоб-
разования
Замена
(подстановка)
Перестановка
Аналитическое
преобразование
Гаммирование
Комбинирован.
Смысловое
Символьное
Рассечение – раз-
несение
Сжатие –
расширение
Способ преобразо-
вания
Простая (одноалфавитная)
Многоалфавитная одноконтурная обык-
новенная
Многоалфавитная одноконтурная моно-
фоническая
Многоалфавитная многконтурная
Простая
Усложненнная по таблице (Вижинера)
Усложненнная по маршрутам (Гамиль-
тона)
По правилам алгебры матриц
По особым зависимостям
С конечной короткой гаммой
С конечной длинной гаммой
С бесконечной гаммой
Замена + перестановка
Замена + гаммирование
Перестановка + гаммирование
Гаммирование+ гаммирование
По специальным таблицам (словарям)
По кодовому алфавиту
Смысловое
Механическое
Разновидность преобразования
x x x x x x x x x x x x x x x x x x x x П
x x x x x x x x x А
Реализация
Рис. 1.1. Классификация методов криптографического закрытия информации